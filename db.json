{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Excalidraw.md","hash":"b61f30a43b17415101bc9daaca025aedd3da7617","modified":1692433374688},{"_id":"source/_posts/Rainmeter ToDolist.md","hash":"ded6718a3202c33c3f3baaab81dc97143ec6bb47","modified":1692366662924},{"_id":"source/_posts/vscodessh.md","hash":"0d85c6aac95ea9beeeab11f5c45fa63c283975c8","modified":1692366662924},{"_id":"source/categories/index.md","hash":"53304f52aa580f411d7033d929173e4ef70efa30","modified":1692366662924},{"_id":"source/tags/index.md","hash":"5da5ecce8eeccb62cabd44618d9e798fbe1ee159","modified":1692366662924},{"_id":"source/_posts/datastructure.md","hash":"6bce201bdbeaec152817e34785ebeab6e3cf8e13","modified":1692366662924},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"656d8b548940d7d214459cd8853007af38e6c465","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1692366662644},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1692366662644},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1692366662644},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1692366662644},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1692366662644},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1692366662644},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1692366662644},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1692366662652},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1692366662640},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1692366662648},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1692366662648},{"_id":"source/_posts/CMU15445 P2cp1.md","hash":"803b89835c990790c2ee283ee19cd0c92eea81c5","modified":1693465748876},{"_id":"source/_posts/CMU15445 P2cp2.md","hash":"0845e1e0c46ed0a5b6d47cd5becdf5c4ddb89fd3","modified":1693543835407},{"_id":"source/_posts/CMU15445 P3.md","hash":"0a3fde3681e1a9505aa4eb210e78b0b230800cf4","modified":1698730834807},{"_id":"source/_data/link.yml","hash":"10f5700b854184288059899e7b30979af5d2c6b7","modified":1698934315093},{"_id":"source/link/index.md","hash":"cf650a41f4b7ec5a42eb6c94bbc18335a0483255","modified":1698934206067},{"_id":"source/_posts/CMU15445 P4.md","hash":"0b7962a0ad1539c42fbad802389715d3d20c1c2b","modified":1698730834807}],"Category":[{"name":"实用技巧","_id":"cllhr6jid0004eqjg9xbi1e7t"},{"name":"知识总结","_id":"cllhr6jim000meqjg2utocunz"},{"name":"CMU15445","_id":"clmuf8mjm0002cjjgfkx8a6yb"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"butterfly配置文档","link_list":[{"name":"Butterfly","link":"https://butterfly.js.org/"}]}]}],"Page":[{"title":"categories","date":"2023-08-06T06:29:48.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-08-06 14:29:48\ntype: \"categories\"\n---\n","updated":"2023-08-18T13:51:02.924Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cllhr6ji30000eqjgdubne954","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"标签内容","date":"2023-08-06T05:46:47.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签内容\ndate: 2023-08-06 13:46:47\ntype : \"tags\"\n---\n","updated":"2023-08-18T13:51:02.924Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cllhr6ji90002eqjg5a0n56qn","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"Link","date":"2023-11-02T14:09:49.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: Link\ndate: 2023-11-02 22:09:49\ntype: \"link\"\n---\n","updated":"2023-11-02T14:10:06.067Z","path":"link/index.html","comments":1,"layout":"page","_id":"cloh9myb70000dlji5cpy86tn","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"butterfly配置文档","link_list":[{"name":"Butterfly","link":"https://butterfly.js.org/"}]}]}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"excalidraw添加中文手写体","date":"2023-08-19T07:00:00.000Z","description":"实用画图工具excalidraw","cover":"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/4-2023-08-19-1530.png","top_img":"rgba(0,0,0,0)","_content":"## Excalidraw\n\n之前一直用mermaid画图，苦于格式限定的太死板，所以找到一款好用的画板[Excalidraw ](https://excalidraw.com/)辅助画图\n\n使用过程中发现了一些问题\n\nexcalidraw的手写体不支持中文，看起来十分违和\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/2023-08-19-1120.png)\n\n所以通过本地部署，导入中文手写字体的方法解决问题\n\n采用了[沐瑶软笔手写体](https://www.fonts.net.cn/font-35068393713.html)，效果如下\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/1-2023-08-19-1120.png)\n\n## 本地部署\n\n### 环境\n\n- Git\n- yarn\n- Nodejs\n\n### 克隆代码\n\n```bash\ngit clone https://github.com/excalidraw/excalidraw.git\n```\n\n### 安装依赖\n\n```bash\nyarn\n```\n\n### 启动\n\n```bash\nyarn start\n```\n\n可以在https://localhost:3000运行使用了\n\n\n\n## 添加中文手写字体\n\n### 添加字体\n\n- 在``public``目录中加入字体文件 ``example.ttf``\n- 在``public/fonts.css``添加对应字体引入\n\n```css\n@font-face {\n    font-family: \"example\";\n    src: url(\"example.ttf\");\n    font-display: swap;\n}\n```\n\n- 在``src/index-node.ts``注册字体\n\n```ts\nregisterFont(\"./public/example.ttf\", { family: \"example\"});\n```\n\n\n\n### 添加常量\n\n- 在``src/constant.ts``中的``FONT-FAMILY``常量中添加font\n\n```ts\t\nexport const FONT_FAMILY = {\n    Virgil: 1,\n    Helvetica: 2,\n    Cascadia: 3,\n    example: 4,  //该行为新增内容， example对应添加字体时的font-family\n};\n```\n\n\n\n### 添加按钮\n\n- 在``/src/actions/actionProperties.tsx``中``actionChangeFontFamily``添加\n\n```tsx\nexport const actionChangeFontFamily = register({\n    ...\n    PanelComponent: \n    \t...\n    \t//以下内容为新增\n    \t{\n            value: FONT_FAMILY.example,\n            text: \"中文手写\",\n            icon:  FreedrawIcon,\n        }\n})\n```\n\n\n\n### 预加载字体资源\n\n- ``index.html``\n\n```html\n<link\n\trel=\"preload\"\n\thref=\"example.ttf\"\n\tas=\"font\"\n\ttype=\"font/ttf\"\n\tcrossorigin=\"anonymous\"\n\t/>\n```\n\n\n\n## 部署gitpage\n\n```b\nyarn build\n```\n\n将``build``文件夹内文件push到 ``username.github.io``的项目仓库中即可\n\n网站[在此](https://xiaopangwa99.github.io/)\n\n","source":"_posts/Excalidraw.md","raw":"---\ntitle: excalidraw添加中文手写体\ncategories: 实用技巧\ntags: \n    - Excalidraw\n    - Nodejs\n    - Yarn\n    - Git\ndate: 2023-08-19 15:00:00\ndescription: 实用画图工具excalidraw\ncover: https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/4-2023-08-19-1530.png\ntop_img: rgba(0,0,0,0)\n---\n## Excalidraw\n\n之前一直用mermaid画图，苦于格式限定的太死板，所以找到一款好用的画板[Excalidraw ](https://excalidraw.com/)辅助画图\n\n使用过程中发现了一些问题\n\nexcalidraw的手写体不支持中文，看起来十分违和\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/2023-08-19-1120.png)\n\n所以通过本地部署，导入中文手写字体的方法解决问题\n\n采用了[沐瑶软笔手写体](https://www.fonts.net.cn/font-35068393713.html)，效果如下\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/1-2023-08-19-1120.png)\n\n## 本地部署\n\n### 环境\n\n- Git\n- yarn\n- Nodejs\n\n### 克隆代码\n\n```bash\ngit clone https://github.com/excalidraw/excalidraw.git\n```\n\n### 安装依赖\n\n```bash\nyarn\n```\n\n### 启动\n\n```bash\nyarn start\n```\n\n可以在https://localhost:3000运行使用了\n\n\n\n## 添加中文手写字体\n\n### 添加字体\n\n- 在``public``目录中加入字体文件 ``example.ttf``\n- 在``public/fonts.css``添加对应字体引入\n\n```css\n@font-face {\n    font-family: \"example\";\n    src: url(\"example.ttf\");\n    font-display: swap;\n}\n```\n\n- 在``src/index-node.ts``注册字体\n\n```ts\nregisterFont(\"./public/example.ttf\", { family: \"example\"});\n```\n\n\n\n### 添加常量\n\n- 在``src/constant.ts``中的``FONT-FAMILY``常量中添加font\n\n```ts\t\nexport const FONT_FAMILY = {\n    Virgil: 1,\n    Helvetica: 2,\n    Cascadia: 3,\n    example: 4,  //该行为新增内容， example对应添加字体时的font-family\n};\n```\n\n\n\n### 添加按钮\n\n- 在``/src/actions/actionProperties.tsx``中``actionChangeFontFamily``添加\n\n```tsx\nexport const actionChangeFontFamily = register({\n    ...\n    PanelComponent: \n    \t...\n    \t//以下内容为新增\n    \t{\n            value: FONT_FAMILY.example,\n            text: \"中文手写\",\n            icon:  FreedrawIcon,\n        }\n})\n```\n\n\n\n### 预加载字体资源\n\n- ``index.html``\n\n```html\n<link\n\trel=\"preload\"\n\thref=\"example.ttf\"\n\tas=\"font\"\n\ttype=\"font/ttf\"\n\tcrossorigin=\"anonymous\"\n\t/>\n```\n\n\n\n## 部署gitpage\n\n```b\nyarn build\n```\n\n将``build``文件夹内文件push到 ``username.github.io``的项目仓库中即可\n\n网站[在此](https://xiaopangwa99.github.io/)\n\n","slug":"Excalidraw","published":1,"updated":"2023-08-19T08:22:54.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllhr6ji60001eqjgbvvkciyr","content":"<h2 id=\"Excalidraw\"><a href=\"#Excalidraw\" class=\"headerlink\" title=\"Excalidraw\"></a>Excalidraw</h2><p>之前一直用mermaid画图，苦于格式限定的太死板，所以找到一款好用的画板<a href=\"https://excalidraw.com/\">Excalidraw </a>辅助画图</p>\n<p>使用过程中发现了一些问题</p>\n<p>excalidraw的手写体不支持中文，看起来十分违和</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/2023-08-19-1120.png\"></p>\n<p>所以通过本地部署，导入中文手写字体的方法解决问题</p>\n<p>采用了<a href=\"https://www.fonts.net.cn/font-35068393713.html\">沐瑶软笔手写体</a>，效果如下</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/1-2023-08-19-1120.png\"></p>\n<h2 id=\"本地部署\"><a href=\"#本地部署\" class=\"headerlink\" title=\"本地部署\"></a>本地部署</h2><h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><ul>\n<li>Git</li>\n<li>yarn</li>\n<li>Nodejs</li>\n</ul>\n<h3 id=\"克隆代码\"><a href=\"#克隆代码\" class=\"headerlink\" title=\"克隆代码\"></a>克隆代码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/excalidraw/excalidraw.git</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn start</span><br></pre></td></tr></table></figure>\n\n<p>可以在<a href=\"https://localhost:3000运行使用了\">https://localhost:3000运行使用了</a></p>\n<h2 id=\"添加中文手写字体\"><a href=\"#添加中文手写字体\" class=\"headerlink\" title=\"添加中文手写字体\"></a>添加中文手写字体</h2><h3 id=\"添加字体\"><a href=\"#添加字体\" class=\"headerlink\" title=\"添加字体\"></a>添加字体</h3><ul>\n<li>在<code>public</code>目录中加入字体文件 <code>example.ttf</code></li>\n<li>在<code>public/fonts.css</code>添加对应字体引入</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@font-face</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: <span class=\"string\">&quot;example&quot;</span>;</span><br><span class=\"line\">    <span class=\"attribute\">src</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;example.ttf&quot;</span>);</span><br><span class=\"line\">    <span class=\"attribute\">font-display</span>: swap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在<code>src/index-node.ts</code>注册字体</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">registerFont</span>(<span class=\"string\">&quot;./public/example.ttf&quot;</span>, &#123; <span class=\"attr\">family</span>: <span class=\"string\">&quot;example&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"添加常量\"><a href=\"#添加常量\" class=\"headerlink\" title=\"添加常量\"></a>添加常量</h3><ul>\n<li>在<code>src/constant.ts</code>中的<code>FONT-FAMILY</code>常量中添加font</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">FONT_FAMILY</span> = &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Virgil</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"title class_\">Helvetica</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"title class_\">Cascadia</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"attr\">example</span>: <span class=\"number\">4</span>,  <span class=\"comment\">//该行为新增内容， example对应添加字体时的font-family</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"添加按钮\"><a href=\"#添加按钮\" class=\"headerlink\" title=\"添加按钮\"></a>添加按钮</h3><ul>\n<li>在<code>/src/actions/actionProperties.tsx</code>中<code>actionChangeFontFamily</code>添加</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> actionChangeFontFamily = <span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"title class_\">PanelComponent</span>: </span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    \t<span class=\"comment\">//以下内容为新增</span></span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"variable constant_\">FONT_FAMILY</span>.<span class=\"property\">example</span>,</span><br><span class=\"line\">            <span class=\"attr\">text</span>: <span class=\"string\">&quot;中文手写&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">icon</span>:  <span class=\"title class_\">FreedrawIcon</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"预加载字体资源\"><a href=\"#预加载字体资源\" class=\"headerlink\" title=\"预加载字体资源\"></a>预加载字体资源</h3><ul>\n<li><code>index.html</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">rel</span>=<span class=\"string\">&quot;preload&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">href</span>=<span class=\"string\">&quot;example.ttf&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">as</span>=<span class=\"string\">&quot;font&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;font/ttf&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">&quot;anonymous&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t/&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"部署gitpage\"><a href=\"#部署gitpage\" class=\"headerlink\" title=\"部署gitpage\"></a>部署gitpage</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn build</span><br></pre></td></tr></table></figure>\n\n<p>将<code>build</code>文件夹内文件push到 <code>username.github.io</code>的项目仓库中即可</p>\n<p>网站<a href=\"https://xiaopangwa99.github.io/\">在此</a></p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h2 id=\"Excalidraw\"><a href=\"#Excalidraw\" class=\"headerlink\" title=\"Excalidraw\"></a>Excalidraw</h2><p>之前一直用mermaid画图，苦于格式限定的太死板，所以找到一款好用的画板<a href=\"https://excalidraw.com/\">Excalidraw </a>辅助画图</p>\n<p>使用过程中发现了一些问题</p>\n<p>excalidraw的手写体不支持中文，看起来十分违和</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/2023-08-19-1120.png\"></p>\n<p>所以通过本地部署，导入中文手写字体的方法解决问题</p>\n<p>采用了<a href=\"https://www.fonts.net.cn/font-35068393713.html\">沐瑶软笔手写体</a>，效果如下</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/19/1-2023-08-19-1120.png\"></p>\n<h2 id=\"本地部署\"><a href=\"#本地部署\" class=\"headerlink\" title=\"本地部署\"></a>本地部署</h2><h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><ul>\n<li>Git</li>\n<li>yarn</li>\n<li>Nodejs</li>\n</ul>\n<h3 id=\"克隆代码\"><a href=\"#克隆代码\" class=\"headerlink\" title=\"克隆代码\"></a>克隆代码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/excalidraw/excalidraw.git</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn start</span><br></pre></td></tr></table></figure>\n\n<p>可以在<a href=\"https://localhost:3000运行使用了\">https://localhost:3000运行使用了</a></p>\n<h2 id=\"添加中文手写字体\"><a href=\"#添加中文手写字体\" class=\"headerlink\" title=\"添加中文手写字体\"></a>添加中文手写字体</h2><h3 id=\"添加字体\"><a href=\"#添加字体\" class=\"headerlink\" title=\"添加字体\"></a>添加字体</h3><ul>\n<li>在<code>public</code>目录中加入字体文件 <code>example.ttf</code></li>\n<li>在<code>public/fonts.css</code>添加对应字体引入</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@font-face</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: <span class=\"string\">&quot;example&quot;</span>;</span><br><span class=\"line\">    <span class=\"attribute\">src</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;example.ttf&quot;</span>);</span><br><span class=\"line\">    <span class=\"attribute\">font-display</span>: swap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在<code>src/index-node.ts</code>注册字体</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">registerFont</span>(<span class=\"string\">&quot;./public/example.ttf&quot;</span>, &#123; <span class=\"attr\">family</span>: <span class=\"string\">&quot;example&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"添加常量\"><a href=\"#添加常量\" class=\"headerlink\" title=\"添加常量\"></a>添加常量</h3><ul>\n<li>在<code>src/constant.ts</code>中的<code>FONT-FAMILY</code>常量中添加font</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">FONT_FAMILY</span> = &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Virgil</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"title class_\">Helvetica</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"title class_\">Cascadia</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"attr\">example</span>: <span class=\"number\">4</span>,  <span class=\"comment\">//该行为新增内容， example对应添加字体时的font-family</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"添加按钮\"><a href=\"#添加按钮\" class=\"headerlink\" title=\"添加按钮\"></a>添加按钮</h3><ul>\n<li>在<code>/src/actions/actionProperties.tsx</code>中<code>actionChangeFontFamily</code>添加</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> actionChangeFontFamily = <span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"title class_\">PanelComponent</span>: </span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    \t<span class=\"comment\">//以下内容为新增</span></span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"variable constant_\">FONT_FAMILY</span>.<span class=\"property\">example</span>,</span><br><span class=\"line\">            <span class=\"attr\">text</span>: <span class=\"string\">&quot;中文手写&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">icon</span>:  <span class=\"title class_\">FreedrawIcon</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"预加载字体资源\"><a href=\"#预加载字体资源\" class=\"headerlink\" title=\"预加载字体资源\"></a>预加载字体资源</h3><ul>\n<li><code>index.html</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">rel</span>=<span class=\"string\">&quot;preload&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">href</span>=<span class=\"string\">&quot;example.ttf&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">as</span>=<span class=\"string\">&quot;font&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;font/ttf&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">&quot;anonymous&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">\t/&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"部署gitpage\"><a href=\"#部署gitpage\" class=\"headerlink\" title=\"部署gitpage\"></a>部署gitpage</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn build</span><br></pre></td></tr></table></figure>\n\n<p>将<code>build</code>文件夹内文件push到 <code>username.github.io</code>的项目仓库中即可</p>\n<p>网站<a href=\"https://xiaopangwa99.github.io/\">在此</a></p>\n"},{"title":"Rainmeter ToDolist","date":"2023-08-12T14:00:00.000Z","description":"一款实用的桌面TODO组件！","cover":"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/nglCyo9G_5c0e15bfde4c6b2b393420bbf57e974d.jpeg","top_img":"rgba(0,0,0,0)","_content":"## 对Todo小组件进行了一定的修改\n\n出于个人需求原因，想找一个可以固定在桌面的待办事项，未找到合适的，故在已有的基础上对[Rainmeter](https://www.rainmeter.net/) [Todo](https://bbs.rainmeter.cn/forum.php?mod=viewthread&tid=113483&highlight=todo)小组件进行了一定程度的修改\n\n- 添加了记录事件完成时间的功能\n- 添加了日志中输出日期分界线功能\n- 修改了全部任务完成（无任务）时的显示问题\n\n\n\n## 1.记录\n\n记录内容在``@Resources``文件夹下``Record.txt``文件中，内容如下：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/aiKktrcm_20230812205111.png)\n\n\n\n## 2.功能\n\n- 左上角标记为日期分界线![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/RoqlEHDY_20230812222208.png)\n\n​\t\t点击后会在``Record.txt``中出现内容：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/yFA9T0WL_20230812221402.png)\n\n- 右上角标记为添加事项![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/KRMPQFdz_20230812222204.png)\n\n​\t\t点击后即可添加事项\n\n​\t\t事件完成后会将完成事件记录在``Record.txt``中\n\n\n\n## 3.资源\n\n点击[这里](https://github.com/xiaopangwa99/rainmeter-todolist)","source":"_posts/Rainmeter ToDolist.md","raw":"---\ntitle: Rainmeter ToDolist\ncategories: 实用技巧\ntags: \n    - Rainmeter\n    - ToDoList\ndate: 2023-08-12 22:00:00\ndescription: 一款实用的桌面TODO组件！\ncover: https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/nglCyo9G_5c0e15bfde4c6b2b393420bbf57e974d.jpeg\ntop_img: rgba(0,0,0,0)\n---\n## 对Todo小组件进行了一定的修改\n\n出于个人需求原因，想找一个可以固定在桌面的待办事项，未找到合适的，故在已有的基础上对[Rainmeter](https://www.rainmeter.net/) [Todo](https://bbs.rainmeter.cn/forum.php?mod=viewthread&tid=113483&highlight=todo)小组件进行了一定程度的修改\n\n- 添加了记录事件完成时间的功能\n- 添加了日志中输出日期分界线功能\n- 修改了全部任务完成（无任务）时的显示问题\n\n\n\n## 1.记录\n\n记录内容在``@Resources``文件夹下``Record.txt``文件中，内容如下：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/aiKktrcm_20230812205111.png)\n\n\n\n## 2.功能\n\n- 左上角标记为日期分界线![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/RoqlEHDY_20230812222208.png)\n\n​\t\t点击后会在``Record.txt``中出现内容：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/yFA9T0WL_20230812221402.png)\n\n- 右上角标记为添加事项![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/KRMPQFdz_20230812222204.png)\n\n​\t\t点击后即可添加事项\n\n​\t\t事件完成后会将完成事件记录在``Record.txt``中\n\n\n\n## 3.资源\n\n点击[这里](https://github.com/xiaopangwa99/rainmeter-todolist)","slug":"Rainmeter ToDolist","published":1,"updated":"2023-08-18T13:51:02.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllhr6ji90003eqjg2d5ofxqr","content":"<h2 id=\"对Todo小组件进行了一定的修改\"><a href=\"#对Todo小组件进行了一定的修改\" class=\"headerlink\" title=\"对Todo小组件进行了一定的修改\"></a>对Todo小组件进行了一定的修改</h2><p>出于个人需求原因，想找一个可以固定在桌面的待办事项，未找到合适的，故在已有的基础上对<a href=\"https://www.rainmeter.net/\">Rainmeter</a> <a href=\"https://bbs.rainmeter.cn/forum.php?mod=viewthread&tid=113483&highlight=todo\">Todo</a>小组件进行了一定程度的修改</p>\n<ul>\n<li>添加了记录事件完成时间的功能</li>\n<li>添加了日志中输出日期分界线功能</li>\n<li>修改了全部任务完成（无任务）时的显示问题</li>\n</ul>\n<h2 id=\"1-记录\"><a href=\"#1-记录\" class=\"headerlink\" title=\"1.记录\"></a>1.记录</h2><p>记录内容在<code>@Resources</code>文件夹下<code>Record.txt</code>文件中，内容如下：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/aiKktrcm_20230812205111.png\"></p>\n<h2 id=\"2-功能\"><a href=\"#2-功能\" class=\"headerlink\" title=\"2.功能\"></a>2.功能</h2><ul>\n<li>左上角标记为日期分界线<img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/RoqlEHDY_20230812222208.png\"></li>\n</ul>\n<p>​\t\t点击后会在<code>Record.txt</code>中出现内容：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/yFA9T0WL_20230812221402.png\"></p>\n<ul>\n<li>右上角标记为添加事项<img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/KRMPQFdz_20230812222204.png\"></li>\n</ul>\n<p>​\t\t点击后即可添加事项</p>\n<p>​\t\t事件完成后会将完成事件记录在<code>Record.txt</code>中</p>\n<h2 id=\"3-资源\"><a href=\"#3-资源\" class=\"headerlink\" title=\"3.资源\"></a>3.资源</h2><p>点击<a href=\"https://github.com/xiaopangwa99/rainmeter-todolist\">这里</a></p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h2 id=\"对Todo小组件进行了一定的修改\"><a href=\"#对Todo小组件进行了一定的修改\" class=\"headerlink\" title=\"对Todo小组件进行了一定的修改\"></a>对Todo小组件进行了一定的修改</h2><p>出于个人需求原因，想找一个可以固定在桌面的待办事项，未找到合适的，故在已有的基础上对<a href=\"https://www.rainmeter.net/\">Rainmeter</a> <a href=\"https://bbs.rainmeter.cn/forum.php?mod=viewthread&tid=113483&highlight=todo\">Todo</a>小组件进行了一定程度的修改</p>\n<ul>\n<li>添加了记录事件完成时间的功能</li>\n<li>添加了日志中输出日期分界线功能</li>\n<li>修改了全部任务完成（无任务）时的显示问题</li>\n</ul>\n<h2 id=\"1-记录\"><a href=\"#1-记录\" class=\"headerlink\" title=\"1.记录\"></a>1.记录</h2><p>记录内容在<code>@Resources</code>文件夹下<code>Record.txt</code>文件中，内容如下：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/aiKktrcm_20230812205111.png\"></p>\n<h2 id=\"2-功能\"><a href=\"#2-功能\" class=\"headerlink\" title=\"2.功能\"></a>2.功能</h2><ul>\n<li>左上角标记为日期分界线<img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/RoqlEHDY_20230812222208.png\"></li>\n</ul>\n<p>​\t\t点击后会在<code>Record.txt</code>中出现内容：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/yFA9T0WL_20230812221402.png\"></p>\n<ul>\n<li>右上角标记为添加事项<img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/12/KRMPQFdz_20230812222204.png\"></li>\n</ul>\n<p>​\t\t点击后即可添加事项</p>\n<p>​\t\t事件完成后会将完成事件记录在<code>Record.txt</code>中</p>\n<h2 id=\"3-资源\"><a href=\"#3-资源\" class=\"headerlink\" title=\"3.资源\"></a>3.资源</h2><p>点击<a href=\"https://github.com/xiaopangwa99/rainmeter-todolist\">这里</a></p>\n"},{"title":"数据结构整理","date":"2023-08-09T02:00:00.000Z","description":"对数据结构知识点的整理","_content":"# 基本定义\n\n## 数据\n\n### 1.数据\n\n能输入计算机且能被计算机处理的各种符号的集合\n\n1）数值型数据：整数、实数等\n\n2）非数值型数据：文字、图像、声音等\n\n### 2.数据元素\n\n数据的基本单位\n\n也称为元素、记录或结点\n\n例：  学号    姓名     专业      性别\n\n​           123    张三     电子      男\n\n### 3.数据项\n\n构成数据元素的不可分割的最小单位\n\n例：学号\n\n### 三者关系\n\n数据>数据元素>数据项\n\n### 4.数据对象\n\n性质相同的数据元素的集合，是数据的一个子集\n\n## **数据结构\n\n数据元素相互之间的关系称为结构\n\n### 1.逻辑结构\n\n#### 1.集合结构\n\n#### 2.线性结构\n\n#### 3.树形结构\n\n#### 4.图形结构\n\n### 2.物理结构或存储结构\n\n数据元素及其关系在计算机内存中的表示\n\n#### 1.顺序存储结构\n\n#### 2.链式存储结构\n\n****\n\n\n\n\n\n\n\n\n\n\n\n## 算法\n\n### 1.时间复杂度\n\n==O(1) < O(log n) < O(n) < O(n*log n) < O(n²) < O(n³) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)==\n\n\n\n\n\n\n\n# 线性表\n\n零个或者多个数据元素的有限序列\n\n\n\n线性表中，一个数据元素可以由若干个数据项组成\n\n## 1.顺序存储结构\n\n### 1.顺序存储定义\n\n线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表数据的元素。\n\n### 2.顺序存储方式\n\n```c\ntypedef struct{\n\tElemType data[MAXSIZE];\n\tint length;\n}Sqlist;\n```\n\n需要三个属性：  1.存储空间的起始位置 ： 数据data ,他的存储位置就是存储空间的存储位置\n\n​\t\t\t\t\t\t\t 2.线性表的最大存储容量：数组长度MAXSIZE\n\n​\t\t\t\t\t\t\t 3.线性表的当前长度：length\n\n### 3.线性表顺序存储结构的优缺点\n\n优点：无需为表中元素之间的逻辑关系而增加额外的存储空间\n\n​\t\t\t可以快速地存取表中的任一位置的元素\n\n\n\n缺点：插入和删除操作需要移动大量元素\n\n​\t\t    当线性表长度变化较大时，难以确定存储空间的容量\n\n​\t\t\t造成存储空间的“碎片”\n\n\n\n## 2.链式存储结构\n\n### 1.定义\n\nn个结点（a<sub>i</sub>的存储映像）链结成一个链表，即为线性表（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>）的链式存储结构\n\n\n\n**a<sub>i</sub>的存储映像**：1.数据域 \n\n​\t\t\t\t\t\t   2.指针域\n\n\n\n**头指针**：链表中第一个结点的存储位置\n\n~~最后一个结点指向空结点NULL~~\n\n\n\n### 2.头指针、头结点的异同\n\n**头指针**：1.头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针\n\n​\t\t\t\t2.头指针具有标志作用，所以常用头指针冠以链表的名字\n\n​\t\t\t\t3.无论链表是否为空，头指针均不为空。头指针是链表的必要元素\n\n\n\n**头结点**：1.头结点是为了操作的统一和方标而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）\n\n​\t\t\t\t2.有了头结点，对在第一元素结点之前插入结点和删除第一节点，其操作与其他结点的操作就统一了\n\n​\t\t\t\t3.头节点不一定就是链表的必需要素\n\n\n\n### 3.链表存储方式\n\n```c\n/*线性表的单链表存储结构*/\ntypedef struct Node{\n\tElemType data;\n\tstruct Node *next;\n}Node;\ntypedef struct Node *LinkList;\n```\n\n\n\n 对于插入或者删除数据越频繁的操作，单链表的效率优势就越明显 \n\n\n\n### 4.单链表结构与顺序存储结构的优缺点\n\n|              | 顺序存储方式                               | 单链表结构                                             |\n| ------------ | ------------------------------------------ | ------------------------------------------------------ |\n| 存储分配方式 | 用一段连续存储单元依次存储线性表的数据元素 | 采用链式存储结构，用一组任意的存储单元存放线性表的元素 |\n| 时间性能     | 查找：O（1）                               | 查找：O（n）                                           |\n|              | 插入和删除：O（n）                         | 插入和删除：O（1）                                     |\n| 空间性能     | 需要预分配存储空间                         | 不需要分配存储空间                                     |\n\n**线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构**\n\n**线性表中的元素个数变化较大或者不知道有多大时，最好用单链表结构**\n\n\n\n### 5.循环链表\n\n### 6.双向链表\n\n双向链表是在单链表的每个结点中，再设置一个指向其前驱节点的指针域\n\n{% mermaid %}\ngraph TD\n A((线性表)) --- B1 & C1\n B1(顺序存储结构)\n C1(链式存储结构) --- D1(单链表) & D2(静态链表) & D3(循环链表) & D4(双向链表)\n{% endmermaid %}\n\n\n\n\n\n\n\n\n\n\n\n\n# 栈与队列\n\n## 栈\n\n#### 1.栈的定义\n\n**栈(stack)是限定仅在表尾进行插入和删除操作的线性表**\n\n\n\n允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。\n\n栈又称为后进后出(Last In First Out)的线性表，简称LIFO结构\n\n\n\n#### 2.栈的顺序存储结构及实现\n\n顺序栈\n\n```C\ntypedef struct{\n\tElemType data[MAXSIZE]；\n\tint top;   /* 用于栈顶指针*/\n}SqStack;\n```\n\n\n\n#### 3.两栈共享空间\n\n```C\ntypedef struct{\n\tElemType data[MAXSIZE]；\n\tint top1;   /* 用于栈1栈顶指针*/\n\tint top2;   /* 用于栈2栈顶指针*/\n}SqDoubleStack;\n```\n\n\n\n使用这样的数据结构通常是两个栈的空间需求有相反关系，比如股票，买入时，一定是有人在卖出\n\n如果是不相同数据类型的栈，这种方法不但不能更好的处理问题，反而会使问题变得更复杂。\n\n\n\n#### 4.栈的链式存储结构及实现\n\n链栈\n\n```C\ntypedef struct StackNode{\n\tSElemType data;\n\tstruct StackNode *next;\n}StackNode, *LinkStackPtr;\n\ntypedef struct{\n\tLinkStackPtr top;\n\tint count;\n}LinkStack;\n```\n\n\n\n#### 5.栈的应用\n\n##### 1.递归\n\n###### 1.递归的定义\n\n一个直接调用自己或者通过一系列的调用语句间接调用自己的函数\n\n\n\n每个递归定义必须至少又一个条件，满足时递归不再进行，即不再引用自身而是返回值退出\n\n\n\n简单地说，在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。\n\n在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是回复了调用的状态\n\n\n\n##### 2.四则运算\n\n## 队列\n\n### 1.队列的定义\n\n队列(queue)是只允许在一段进行插入操作，而在另一端进行删除操作的线性表\n\n\n\n队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一段为队尾，允许删除的一端称为队头\n\n\n\n### 2.队列顺序存储\n\n问题：“假溢出”\n\n解决办法：循环队列\n\n**队列头尾相连的顺序存储结构称为循环队列**\n\n\n\n```C\ntypedef struct {\n\tQElemType data[MAXSIZE];\n\tint front;\t\t\t\t/*头指针*/\n\tint rear;\t\t\t\t/*尾指针，若队列不空，指向队列尾元素的下一个位置*/\n}SqQueue;\n```\n\n\n\n### 3.队列链式存储\n\n队列的链式存储，就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列。\n\n\n\n```C\ntypedef struct QNode{     /*结点结构*/\n    QElemtype data;\n    struct QNode *next;\n}QNode,*QueuePtr;\n\ntypedef struct{           /*队列链表结构*/\n    QueuePtr front, rear; /*队头、队尾指针*/\n}LinkQueue;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 串\n\n## 1.串的定义\n\n串(string)是由零个或多个字符组成的有限序列，又叫字符串\n\n\n\n## 2.串的存储结构\n\n### 2.1顺序存储结构\n\n### 2.2链式存储结构\n\n总的来说不如顺序存储灵活，也不如顺序存储结构好\n\n\n\n## 3.模式匹配算法\n\n**字串的定位操作通常称做串的模式匹配**\n\nn为主串长度、m为要匹配的子串长度\n\n最好情况：一开始就匹配成功，比如\"googlegood\"中找\"google\"，时间复杂度为O(m)\n\n稍差一些：每次首字母不匹配，比如\"abcdefgoogle\"中找\"google\"，时间复杂度为O(n+m)\n\n最坏情况：每次匹配不成功都发生在最后一个位置，比如\"0000000000000000000000000001\"中找\"0000001\"，时间复杂度为O((n-m+1)*m)\n\n**低效**\n\n\n\n#### 3.1 KMP模式匹配算法\n\n思想：\n\n\n\n代码实现：1.初始化\n\n​\t\t\t\t\t2.前后缀相同情况\n\n​\t\t\t\t\t3.前后缀不同情况\n\n​\t\t\t\t\t4.更新next值\n\n```C\nvoid get_Next(*next, s){\n\t/*i 后缀末尾 、 j 前缀末尾【也指i之前（包括i）最长相等前后缀长度】*/\n    \n    //初始化\n    j = 0;\t\t/*前缀从最开始的位置开始*/\n    next[0] = 0;\n    \n    for(i = 1; i < s.size(); i++){\t/*i要从位置1开始*/\n        \n        //前后缀不同情况\n        while(j > 0 && s[i] != s[j])  /*不能写成if*/\n            j = next[j - 1];\n        \n        //前后缀相同情况\n        if (s[i] == s[j])\n            j++;\n        \n        //更新next值\n        next[i] = j;\n    }\n}\n```\n\n\n\n#### 3.2 改进的KMP算法\n\n\n\n代码实现\n\n```C\nvoid get_nextval(*nextval, s){\n    while (i < T[0]){\n        if(j == 0 || T[i] = T[k]){\n             ++i;\n             ++j;\n            //区别如下\n            if (T[i] != T[k])   nextval[i] = j;\t\t/*若当前字符与前缀字符不同，则nextval与next无异*/\n            else   nextval[i] = nextval[j];\t\t\t/*若相同，则将nextval值赋值给nextval在i的位置的值*/\n        }\n        else k = nextval[k];\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 树\n\n## 1.树的定义\n\n树(Tree)是n(n>=0)个结点的有限集。n=0时称为空树。\n\n任意一颗非空树中：1）有且仅有一个特定的根(Root)结点\n\n​\t\t\t\t\t\t\t\t   2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集，其中每个集合本身又是一棵树，并且称为根的子树(Sub Tree)\n\n\n\n### 1.1结点的分类\n\n结点拥有的子树数称为结点的**度(Degree)**\n\n度为0的结点称为**叶结点(Leaf)**或终端结点\n\n度不为0的结点称为非终端结点或分支结点\n\n树的度是树内各结点的度的最大值\n\n\n\n### 1.2结点间的关系\n\n结点的子树的根称为该结点的**孩子(Child)**，相应的，该结点称为孩子的**双亲(Parent)**\n\n同一个双亲的孩子之间互称**兄弟(Sibling)**\n\n结点的祖先是从根到该结点所经分支上的所有结点\n\n以某结点为根的子树中的任一结点都称为该节点的子孙\n\n\n\n### 1.3其他相关概念\n\n**层次(Level)**：从根开始定义起，根为第一层，根的孩子为第二层\n\n双亲在同一层的结点互为**堂兄弟**\n\n树中结点最大层次称为树的**深度(Depth)**\n\n如果将树中结点的各子树看成是从左到右有次序的，不能互换的则称为**有序树**，否则称为**无序树**\n\n\n\n### 1.4线性表与树\n\n|                           线性结构                           |                            树结构                            |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n| 第一个数据元素：无前驱<br />最后一个数据元素：无后继<br />中间元素：一个前驱，一个后继 | 根结点：无双亲，唯一<br />叶结点：无孩子，可以多个<br />中间结点：一个双亲，多个孩子 |\n\n\n\n\n\n\n\n## 2.树的存储结构\n\n### 2.1双亲表示法\n\n在每个结点中，附设一个指示器指示其双亲结点在数组中的位置\n\n| data | parent |\n| :--: | :----: |\n\n其中，data为数据域，parent为指针域，存储该结点的双亲在数组中的下标\n\n\n\n代码实现\n\n```C\n//结点结构\ntypedef struct PTNode{\t\n    TElemType data;\t\t\t/*结点数据*/\n    int parent;\t\t\t\t/*双亲位置*/\n}PTNode;\n\n//树结构\ntypedef struct{\n    PTNode nodes[MAX_TREE_SIZE];\t/*结点数组*/\n    int r,n;\t\t\t\t\t\t/*根的位置和结点数*/\n}PTREE;\n```\n\n\n\n这样的存储结构可以很快找到他的双亲结点，所用时间复杂度为O(1)\n\n但若要知道结点的孩子是什么，就只能遍历整个结构\n\n所以可以增加一个长子域\n\n我们又关注结点的孩子、有关注结点的兄弟、对时间遍历的要求比较高，那么我们可以把此结构扩展为双亲域、长子域、右兄弟域\n\n**存储结构设计是一个非常灵活的过程**\n\n**一个存储结构设计的是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等**\n\n\n\n### 2.2孩子表示法\n\n****\n\n**每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法**\n\n\n\n1. 方案1\n\n   指针域的个数等于树的度\n\n   | data | child1 | child2 |  ……  | childd |\n   | :--: | :----: | :----: | :--: | :----: |\n\n   若树中各结点的度相差很大时，浪费空间\n\n   若相差较小，开辟的空间被充分利用了，则缺点变优点\n\n2. 方案2\n\n   指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数\n\n   | data | degree | child1 | child2 |  ……  | childd |\n   | :--: | :----: | :----: | :----: | :--: | :----: |\n\n   克服了浪费空间的缺点，提高了空间利用率\n\n   但由于各结点的链表结构不同，加上要维护结点的度和数值，在运算上就会带来时间上的损耗\n\n\n\n所以采用孩子表示法\n\n具体办法是：\n\n**把每个结点的孩子排列起来，以单链表作为存储结构，则n个节点有n个孩子链表**\n\n**如果是叶子结点则此单链表为空。**\n\n**然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一堆数组中**\n\n\n\n为此，设计了两种结点结构\n\n1.孩子链表的孩子结点\n\n| child | next |\n| :---: | :--: |\n\n其中，child是数据域，用来存储某个结点在表头数组中的下标；next是指针域，用来存储指向某结点的下一个孩子结点的指针\n\n2.表头数组的表头结点\n\n| data | firstchild |\n| :--: | :--------: |\n\n其中，data是数据域，存储某结点的数据信息；firstchild是头指针域，存储该结点的孩子链表的头指针\n\n\n\n代码实现\n\n```C\n//孩子结点\ntypedef struct CTNode{\n    int child;\n    struct CTNode *next;\n}*ChildPtr;\n\n//表头结构\ntypedef struct{\n    TElemType data;\n    ChildPtr firstchild;\n}CTBox;\n\n//树结构\ntypedef struct{\n    CTBOX nodes[MAX_TREE_SIZE]; \t/*结点数组*/\n    int r,nl\t\t\t\t\t\t/*根的位置和结点数*/\n}CTree;\n```\n\n\n\n### 2.3孩子兄弟表示法\n\n任何一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。\n\n因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟\n\n| data | firstchild | rightsib |\n| :--: | :--------: | :------: |\n\ndata为数据域；firstchild为指针域，存储长子结点的存储地址；rightsib是指针域，存储该结点的右兄弟结点的存储地址；\n\n**将复杂的树变为二叉树**\n\n\n\n\n\n## 3.二叉树\n\n二叉树(Binary Tree)是n(n>=0)个结点的有限集合，该集合或者为空集(称为空二叉树),或者由一个根节点和两棵互不相交、分别称为根结点的左子树和右子树的二叉树组成\n\n\n\n### 3.1二叉树特点\n\n1. 每个结点最多有两棵子树\n2. 左子树和右子树是有顺序的\n3. 即使树中某结点只有一颗子树，也要区分它是左子树还是右子树\n\n\n\n### 3.2特殊二叉树\n\n1. 斜树\n\n   所有结点都只有左子树的二叉树叫左斜树，所有结点都只有右子树的二叉树叫右斜树\n\n2. 满二叉树\n\n   所有分支点都存在左子树和右子树，且所有叶子结点都在同一层\n\n3. 完全二叉树\n\n   对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置相同，称为完全二叉树\n\n\n\n\n\n### 3.3二叉树性质\n\n性质1：在二叉树的第i层最多有2<sup>i-1</sup>个结点(i>=1)\n\n性质2：深度为k的二叉树至多有2<sup>k</sup>-1个结点(k>=1)\n\n性质3：对任何一棵二叉树T，如果其终端节点为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub> = n<sub>2</sub> +1\n\n性质4：具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1\n\n性质5：如果一棵有n个结点的完全二叉树的结点按层序编号(从第1层到第[log<sub>2</sub>n]+1层，每层从左到右)，对任一结点i(1<=i<=n)有：\n\n1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[i/2]\n2. 如果2i>n，则结点无左孩子(结点i为叶子结点);否则其左孩子为结点2i\n3. 如果2i+1>n，则结点i无右孩子；否则其右孩子为结点2i+1\n\n\n\n\n\n## 4.二叉树的存储结构\n\n### 4.1顺序存储结构\n\n一般只用于完全二叉树\n\n\n\n### 4.2二叉链表\n\n二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域\n\n\n\n| lchild | data | rchild |\n| :----: | :--: | :----: |\n\n\n\n```c\n//二叉树的二叉链表结点结构定义\ntypedef struct BiTNode{\n    TElemType data;\t\t\t/*结点结构*/\n    struct BiTNode *lchild, *rchild;\t/*左右孩子指针*/\n}BiTNode, *BiTree\n```\n\n\n\n\n\n## 5.遍历二叉树\n\n**二叉树的遍历时指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次**\n\n\n\n两个关键词：**访问**和**次序**\n\n\n\n\n\n### 5.1前序遍历\n\n规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树\n\n\n\n算法\n\n```c\nvoid PreOrderTraverse(BiTree T){\n    if(T == NULL) return;\n    printf(\"%c\", T->data);\t\t\t/*显示结点数据，可改为其他操作*/\n    PreOrderTraverse(T -> lchild);\t/*先序遍历左子树*/\n    PreOrderTraverse(T -> rchild);\t/*先序遍历右子树*/\n}\n```\n\n\n\n\n\n### 5.2中序遍历\n\n规则是若二叉树为空，则空操作返回，否则从根结点开始(注意不是先访问根结点)，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树\n\n\n\n算法\n\n```C\nvoid InOrderTraverse(BiTree T){\n    if(T == NULL) return;\n    InOrderTraverse(T -> lchild);\t/*中序遍历左子树*/\n    printf(\"%c\", T->data);\t\t\t/*显示结点数据，可改为其他操作*/\n    InOrderTraverse(T -> rchild);\t/*中序遍历右子树*/\n}\n```\n\n\n\n### 5.3后序遍历\n\n规则是若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点\n\n\n\n算法\n\n```c\nvoid PostOrderTraverse(BiTree T){\n    if(T == NULL) return;\n    PostOrderTraverse(T -> lchild);\t/*后序遍历左子树*/\n    PostOrderTraverse(T -> rchild);\t/*后序遍历右子树*/\n    printf(\"%c\", T->data);\t\t\t/*显示结点数据，可改为其他操作*/\n}\n```\n\n\n\n### 5.4层次遍历\n\n规则是若二叉树为空，则空操作返回，否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问\n\n\n\n\n\n\n\n## 6.二叉树的建立\n\n普通二叉树\n\n{% mermaid %}\ngraph TD\n\tA((A)) --- B((B)) & C((C))\n    B ---X(( )) & D((D))\n    style X fill:#f100,stroke-width:0px\n    linkStyle 2 stroke:#off, stroke-width:0px;\n{% endmermaid %}\n\n扩展二叉树\n\n{% mermaid %}\ngraph TD\n\tA((A)) --- B((B)) & C((C))\n    B ---X1((#)) & D((D))\n    D ---X2((#)) & X3((#))\n    C ---X4((#)) & X5((#))\n    classDef X fill:#4169E1\n    class X1,X2,X3,X4,X5 X;\n{% endmermaid %}\n\n\n\n代码实现\n\n```c++\n//按前序输入二叉树中结点值（一个字符）\nvoid CreatBiTree(BiTree *T){\n    TElemType ch;\n    \n    cin >> ch;\n    \n    if(ch == \"#\") T = NULL;\n    else{\n        if(!T = new BiTNode) exit(OVERFLOW);\n       \t\n        T->data = ch;\t\t\t/*生成结点*/\n        CreatBiTree(T->lchild); /*构造左子树*/\n        CreatBiTree(T->rchild); /*构造右子树*/\n    }\n}\n```\n\n\n\n\n\n## 7.线索二叉树\n\n指针域未充分利用\n\n将指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树\n\n| lchild | ltag | data | rtag | rchild |\n| :----: | :--: | :--: | :--: | :----: |\n\n其中\n\n- ltag为0时指向该结点的左孩子，为1时指向该结点的前驱\n- rtag为0时指向该结点的右孩子，为1时指向该结点的后继\n\n\n\n代码实现\n\n```c\ntypedef enum {Link, Thread} PointTag; \t/*Link==0表示指向左右孩子指针*/\n\t\t\t\t\t\t\t\t\t\t/*Thread==1表示指向前驱或后继的线索*/\ntypedef struct BiThrNode{\n    TElemType data;\t\t\t\t\t\t/*结点数据*/\n    struct BiThrNode *lchild, *rchild;\t/*左右孩子指针*/\n    PointerTag LTag,RTagj;\t\t\t\t/*左右标志*/\n}BiThrNode, *BiThrTree;\n```\n\n线索化的过程就是在遍历的过程中修改空指针的过程\n\n中序遍历线索化的递归函数如下\n\n```c\nBiThrTree pre;\t\t\t\t\t/*全局变量，始终指向刚刚访问过的结点*/\nvoid InThreading(BiThrTree p){\n    if(p){\n        InThreading(p->lchild);\n        ///////////////////////\n        if(!p->lchild){\t\t\t/*没有左孩子*/\n            p—>LTag = Thread;\t/*前驱线索*/\n            p->lchild = pre;\t/*左孩子指针指向前驱*/\n        }\n        if(!pre->rchild){\t\t/*前驱没有右孩子*/\n            pre->RTag = Thread; /*后继线索*/\n            pre->rchild = p;\t/*前驱右孩子指针指向后继(当前结点p)*/\n        }\n        pre = p;\t\t\t\t/*保持pre指向p的前驱*/\n        ///////////////////////\n        InThreading(p->rchild);\n    }\n}\n```\n\n遍历代码如下\n\n```c\n//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点\nStatus InOrderTraverse_Thr(BiThrTree T){\n    BiThrTree p;\n    p = T->lchild;\n    while(p!=T){\t\t\t\t\t/*空树或者遍历结束时，p == T*/\n        while(p->LTag == Link)\tp = p->lchild;\n        cout << p->data;\t\t\t/*显示结点数据或其他操作*/\n        while(p->RTag == Thread && p->rchild != T){\n            p = p->rchild;\t\t\t/*访问后继结点*/\n            cout << p->data;\n        }\n        p = p->rchild;\t\t\t\t/*p进至其右子树根*/\n    }\t\t\t\t\t\n}\n```\n\n**如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉树链表的存储结构就是非常不错的选择**\n\n\n\n\n\n## 8.树、森林、二叉树的转换\n\n**树 --> 二叉树**：\n\n1.将所有兄弟结点间增加连线\n\n2.只保留和第一个孩子结点的连线，删除与其他孩子结点连线\n\n3.本身孩子结点为左孩子结点，兄弟结点为右孩子结点\n\n\n\n**森林 --> 二叉树**\n\n1.把每棵树转化为二叉树\n\n2.第一棵二叉树不懂，从第二棵二叉树开始依次将后一棵二叉树的根节点作为前一棵的根节点的右孩子\n\n\n\n## 9.哈夫曼树及其应用\n\n### 9.1哈夫曼树的定义及原理\n\n最基本的压缩编码方法-------哈夫曼编码\n\n\n\n带权路径长度WPL最小的二叉树称作哈夫曼树\n\n\n\n1. 先把有权值的叶子结点按照从小到大的顺序排列成有序序列，即A5,E10, B15, D30, C40\n2. 取头两个最小权值结点形成新结点N<sub>1</sub>，相对较小的为左孩子\n3. N<sub>1</sub>替换A、E，插入有序序列中重复2\n\n\n\n### 9.2哈夫曼编码\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 图\n\n## 1.图的定义及术语\n\n## 2.图的存储结构\n\n### 2.1邻接矩阵\n\n图的邻接矩阵存储方式是用两个数组来表示图。\n\n一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边的信息\n\n{% mermaid %}\ngraph TD\nV0 --- V1 & V2 & V3\nV2 --- V1 &  V3\n{% endmermaid %}\n\n顶点数组： \n\n|  V0  |  V1  |  V2  |  V3  |\n| :--: | :--: | :--: | :--: |\n\n邻接矩阵：\n\n|  0   |  1   |  1   |  1   |\n| :--: | :--: | :--: | :--: |\n|  1   |  0   |  1   |  0   |\n|  1   |  1   |  0   |  1   |\n|  1   |  0   |  1   |  0   |\n\n**邻接矩阵存储结构**\n\n```c\ntypedef struct{\n    VertexType vexs[MAXVEX];\t\t/*顶点表*/\n    EdgeType arc[MAXVEX][MAXVEX];\t/*邻接矩阵，可看作边表*/\n    int numNodes, numEdges;\t\t\t/*图中的定点数和边数*/\n}MGraph;\n```\n\n\n\n**无向网图创建代码**\n\n```c\nvoid CreatMGraph(MGraph *G){\n    int i, j, k, w;\n    cout << \"请输入顶点数和边数\";\n    cin >> G->numNodes >> G->numEdges;\t\t\t\t\t\t/*输入顶点数和边数*/\n    for(i = 0; i < G->numNodes; i++)\tcin >> G->vexs[i];\t/*读入顶点信息，建立顶点表*/\n    for(i = 0; i < G->numNodes; i++)\n        for(j = 0; j < G->numNodes; j++)\n            G->arc[i][j] = INFINITY;\t\t\t\t\t\t/*初始化邻接矩阵*/\n    for(k = 0; k < G->numEdges; k++){\n        cout << \"输入边(vi,vj)的下标i,j和权w：\\n\";\n        cin >> i >> j >> w;\n        G->arc[i][j] = w;\n        G->arc[j][i] = G->arc[i][j];\t\t\t\t\t\t/*无向图，所以矩阵对称*/\n    }\n}\n```\n\n\n\n\n\n### 2.2邻接表\n\n数组与链表相结合的存储方式称为邻接表\n\n1.用数组存储顶点\n\n| data | firstedge |\n| :--: | :-------: |\n\n2.用链表存储临界点\n\n| adjvex | next |\n| :----: | :--: |\n\n有向图中，邻接表可以算出度\n\n逆邻接表可以算入度\n\n```c\ntypedef struct EdgeNode{\t\t\t\t\t/*边表结点*/\n    int adjvex;\t\t\t\t\t\t\t\t/*邻接点域，存储该顶点对应下标*/\n    EdgeType info;\t\t\t\t\t\t\t/*用于存储权值，对非网图可以不要*/\n    struct EdgeNode *next;\t\t\t\t\t/*链域，指向下一个邻接点*/\n}EdgeNode；\n    \ntypedef struct VertexNode{\t\t\t\t\t/*顶点表结点*/\n    VertexType data;\t\t\t\t\t\t/*顶点域，存储顶点信息*/\n    EdgeNode *firstedge;\t\t\t\t\t/*边表头指针*/\n}VertexNode,AdjList[MAXVEX];\n\ntypedef struct{\n    AdjList adjlist;\n    int numNodes, numEdges;\t\t\t\t\t/*图中当前顶点数和边数*/\n}GraphAdjList;\n```\n\n**邻接表的创建**\n\n```c\n//建立图的邻接表结构\nvoid CreatALGraph(GraphAdjList *G){\n    int i, j, k;\n    EdgeNode *e;\n    cout << \"请输入顶点数和边数\";\n    cin >> G->numNodes >> G->numEdges;\n    for(i = 0; i < G->numNodes; i++){\t\t/*读入顶点信息，建立顶点表*/\n        cin >> G->adjList[i].data;\t\t\t/*输入顶点信息*/\n        G->adjList[i].firstedge = NULL;\t\t/*边表置为空表*/\n    }\n    \n    for(k = 0; k < G->numEdges; k++){\t\t/*读入顶点信息，建立边表*/\n        cout << \"输入边(vi,vj)上的顶点序号:\";\n        cin >> i >> j;\n        ////////////////////////////////////////////////////////////\n        e = new EdgeNode;\n        e->adjvex = j;\n        e->next = G->adjList[i].firstedge;\n        G->adjList[i].firstedge = e;\t\t/////头插法\n        e = new EdgeNode;\n        e->adjvex = i;\n        e->next = G->adjList[j].firstedge;\n        G->adjList[j].firstedge = e;\n        ////////////////////////////////////////////////////////////\n    }\n}\n```\n\n\n\n### 2.3十字链表\n\n将邻接表与逆邻接表结合起来\n\n顶点表结点结构如下\n\n| data | firstin | firstout |\n| :--: | :-----: | :------: |\n\n边表结点如下\n\n| tailvex | headvex | headlink | taillink |\n| :-----: | :-----: | :------: | :------: |\n\ntailvex：边起点在顶点表中下标\n\nheadvex：边终点在定点表中下标\n\nheadlink：入边表指针域，指向终点相同的下一条边\n\ntaillink：出边表指针域，指向起点相同的下一条边\n\n\n\n\n\n### 2.4邻接多重表\n\n\n\n### 2.5边集数组\n\n边集数组是由两个一维数组构成。\n\n一个存储顶点信息，一个存储边的信息\n\n顶点数组\n\n|  V0  |  V1  |  V2  |  V3  |  V4  |\n| :--: | :--: | :--: | :--: | :--: |\n\n边数组\n\n| begin | end  | weight |\n| :---: | :--: | :----: |\n\n\n\n\n\n## 3.图的遍历\n\n从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历\n\n**遍历实质**：图的邻接点\n\n\n\n### 3.1深度优先遍历\n\n深度优先遍历(Depth First Search) **DFS**\n\n**类似树的前序遍历**\n\n\n\n从图中某个顶点V出发，访问此顶点，然后从V的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到\n\n若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止\n\n```c\n//邻接矩阵的深度优先递归算法\nvoid DFS(MGraph G, int i){\n    int j;\n    visitet[i] = TRUE;\n    cout << G.vexs[i];\t\t\t\t\t\t\t/*访问顶点，也可做其他操作*/\n    for(j = 0; j < G.numVertexes; j++)\t\t\t\n        if(G.arc[i][j] == 1 && !visited[j])\t\t/*G.arc[i][j]为1代表邻接，visited[i] = 0代表未被访问*/\n            DFS(G, j);\t\t\t\t\t\t\t/*对未访问的顶点做递归调用*/\n}\n```\n\n用**邻接矩阵**表示图，遍历图中每个顶点都要从头扫描该顶点所在行，时间复杂度O(n<sup>2</sup>)\n\n------\n\n\n\n```c\n//邻接表的深度优先递归算法\nvoid DFS(GraphAdjList GL, int i){\n    EdgeNode *p;\n    visit[i] = TRUE;\n    cout << GL.adjList[i].data;\t\t\t\t\t/*打印顶点，也可做其他操作*/\n    p = GL->adjList[i].firstedge;\n    while(p){\n        if(!visited[p->adjvex])\n            DFS(GL, p->adjvex);\n        p = p->next;\n    }\n}\n```\n\n用**邻接表**来表示图，有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点，时间复杂度为O(n+e)\n\n\n\n\n\n### 3.2广度优先遍历\n\n广度优先遍历(Breadth First Search) **BFS**\n\n**类似树的层序遍历**\n\n```c\n//邻接矩阵的广度遍历\nvoid BFS(Graph G){\n    int i, j;\n    InitQueue(Q);\t\t\t\t\t\t\t\t/*辅助队列初始化,置空*/\n    for(i = 0; i < G.numVertexes; i++){\t\t\t/*对每个顶点做循环*/\n        if(!visited[i]){\t\t\t\t\t\t/*若是未被访问过就处理*/\n            visited[i] = TRUE;\t\t\t\t\t/*标记为已访问*/\n            cout << G.vexs[i];\t\t\t\t\t/*访问顶点*/\n            EnQueue(Q,i);\t\t\t\t\t\t/*当前顶点入队*/\n            while(!QueueEmpty(Q)){\t\t\t\t/*若当前队列不为空*/\n                DeQueue(Q,i);\t\t\t\t\t/*将队首元素出队列，赋值给i*/\n                for(j = 0; j < G.numVertexes; j++){\t\t\t\t\n                    if(G.arc[i][j] == 1 && !visited[j]){\t\t/*判断其他顶点，若与当前顶点存在边且未访问过*/\n                        visited[j] == TRUE;\t\t\t\t\t\t\n                        cout << G.vexs[j];\t\t\t\t\t\t/*访问顶点*/\n                        EnQueue(Q,j);\t\t\t\t\t\t\t/*将找到的顶点入队列*/\n                    }\n                }\n            }\n        }\n    }\n    \n}\n```\n\n\n\n```c\n//邻接表的广度遍历\nvoid BFS(GraphAdjList GL){\n    int i;\n    EdgeNode *p;\n    Queue Q;\n    InitQueue(Q);\n    for(i = 0; i < GL->numVertexes; i++){\n        if(!visited[i]){\n            visit[i] = TRUE;\n            cout << G.vexs[i];\t\t\t\t\t/*访问顶点*/\n            EnQueue(Q,i);\t\t\t\t\t\t/*当前顶点入队*/\n            while(!QueueEmpty(Q)){\n                DeQueue(Q,i);\n                p = GL->adjustList[i].firstedge;/*找到当前顶点的边表链的表头指针*/\n                while(p){\n                    if(!visited[p->adjvex]){\t/*若顶点未被访问*/\n                        visited[p->adjvex] = TRUE;\n                        cout << GL->adjList[p->adjvex].data;/*访问顶点*/\n                        EnQueue(Q,p->adjvex);   /*将此顶点入队列*/\n                    }\n                    p = p->next;\t\t\t\t/*指针指向下一个邻接点*/\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n## 4.最小生成树\n\n构造连通网的最小代价生成树称为最小生成树\n\n\n\n### 4.1Prim算法\n\n```c\n//Prim算法生成最小生成树\nvoid MiniSpanTress_Prim(MGraph G){\n    int min, i, j, k;\n    int adjvex[MAXVEX];\t\t\t\t\t\t/*邻接点下标*/\n    int lowcost[MAXVEX];\t\t\t\t\t/*保存权值*/\n    for(i = 1; i < G.numVertexes; i++){\n        lowcost[i] = G.arc[0][i];\t\t\t/*将V0顶点与其他所有点连接的权值存入数组*/\n        adjvex[i] = 0;\t\t\t\t\t\t/*初始化为V0下标*/\n    }\n    for(i = 1; i < G.numVertexes; i++){\n     \tmin = INFINITY;\t\t\t\t\t\t/*初始化最小权值为∞,可设为较大数字*/\n        j = 1; k = 0;\n        //找到最小权值边，并将最小权值边的邻接点存入k\n        while(j < G.numVertexes){\t\t\t\t\n            if(lowcost[j] != 0 && lowcost[j] < min){\n                min = lowcost[j];\n                k = j;\n            }\n        }\n        \n        cout << \"(\" + adjvex[k] + \",\" + k + \")\";\n        lowcost[k] = 0;\t\t\t\t\t\t/*当前点已完成任务*/\n        //将与k相接的边的权值更新至lowcost数组，并将其邻接点adjvex更新为k\n        for(j = 1; j < G.numVertexes; j++){\n            if(lowcost[j] != 0 && G.arc[k][j] < lowcost[j]){\n                lowcost[j] = G.arc[k][j];\n                adjvex[j] = k;\n            }\n        }\n    }\n}\n```\n\n\n\n### 4.2Kruskal算法\n\n```c\n//定义边集数组\ntypedef struct{\n    int begin;\n    int end;\n    int weight;\n}Edge;\n```\n\n```c\n//Kruskal算法生成最小生成树\nvoid MiniSpanTree_Kruskal(MGraph G){\n    int i, n, m;\n    Edge edges[MAXEDGE];\n    int parent[MAXEDGE];\t\t\t\t\t/*判断边是否形成回路*/\n    \n    /*省略按权值排序*/\n    \n    //初始化\n    for(i = 0; i < G.numVertexes; i++){\n        parent[i] = 0\n    }\n    \n    for(i = 0; i < G.numEdges; i++){\n        n = Find(parent, edges[i].begin);\n        m = Find(parent, edges[i].end);\n        if(n != m){\t\t\t\t\t\t\t/*m若与n不相等，即未形成环路*/\n            parent[n] = m;\t\t\t\t\t/*将此边的结尾顶点放入下标为起点的parent中，表示此顶点已在生成树集合中*/\n            printf(\"(%d, %d) %d\", edges[i].begin, edges[i].end, edges[i].weight)\n        }\n    }\n    //查找连接顶点的尾部下标\n    int Find(int *parent, int f){\n        while(parent[f] > 0){\n            f = parent[f];\n        }\n        return f;\n    }\n}\n```\n\n\n\n### 4.3比较\n\n|   算法名   |            Prim算法            |    Kruskal算法     |\n| :--------: | :----------------------------: | :----------------: |\n|  算法思想  |             选择点             |       选择边       |\n| 时间复杂度 | O(n<sup>2</sup>)     n为顶点数 | O(eloge)   e为边数 |\n|  适应范围  |             稠密图             |       稀疏图       |\n\n\n\n\n\n## 5.最短路径\n\n### 5.1Dijkstra算法\n\n数据结构\n\n```c\ntypedef struct{\n    int vexs[MAXVEX];\n    int arc[MAXVEX][MAXVEX];\n    int numVertexes, numEdges;\n}MGraph;\n\nint Patharc[MAXVEX];\t\t\t/*用于存储最短路径下标的数组*/\nint ShortPathTable[MAXVEX];\t\t/*用于存储到各点最短路径的权值和*/\n```\n\n算法代码\n\n```c\n//Dijkstra算法 求V0到其余顶点的最短路径P[v]及带权长度D[v]\nvoid ShorttestPath_Dijkstra(MGraph G, int v0, Pathace *P, ShortPathTable *D){\n    int v, w, k, min;\n    int final[MAXVEX];\t\t\t\t\t\t/*final[k] = 1 表示已求得*/\n    //初始化数据\n    for(v = 0; v < G.arc[v0][v]; v++){\n        final[v] = 0;\n        *D[v] = G.arc[v0][v];\n        *P[v] = -1;\n    }\n    *D[v0] = 0;\n    final[v0] = 1;\n    //开始主循环\n    for(v = 1; v < G.numVertexes; v++){\n        min = INFINITY;\n        //寻找距离v0最近的点\n        for(w = 0; w < G.numVertexes; w++){\n            if(!final[w] && *D[w] < min){\n                k = w;\n                min = *D[w];\n            }\n        }\n        final[k] = 1;\t\t\t\t\t\t/*将目前找到的顶点置1*/\n        //修正当前最短路径及距离\n        for(w = 0; w < G.numVertexes; w++){\n            //如果经过v顶点的路径比现在该路径长度短\n            if(!final[w] && (min + arc[k][w] < *G[w])){\n                *D[w] = min + arc[k][w];\t/*更新最小值*/\n                *P[w] = k;\t\t\t\t\t/*更新路径*/\n            }\n        }\n    }\n}\n```\n\n### 5.2Floyd算法\n\n算法实现\n\n```c\ntypedef int Patharc[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\n//Floyd算法，求G中各顶点V到其余顶点w的最短路径P[v][w]及带权长度D[v][w]\nvoid ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D){\n    int v, w, k;\n    //初始化D与P\n    for(v = 0; v < G.numVertexes; ++v){\n        for(w = 0; w < G.numVertexes; ++w){\n            *D[v][w] = G.arc[v][w];\n            *P[v][w] = w;\n        }\n    }\n    \n    for(k = 0; k < G.numVertexes; ++k){\n        for(v = 0; v < G.numVertexes; ++v){\n            for(w = 0; w < G.numVertexes; ++w){\n                //如果经过k顶点的路径比原两点路径短\n                if(*D[v][w] > *D[v][k] + *D[k][w]){\n                    *D[v][w] = *D[v][k] + *D[k][w];\n                    *P[v][w] = *P[v][k];\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n## 6.拓扑排序\n\n有向无环图\n\n**AOV网**\n\n以顶点表示活动，弧表示活动间优先制约关系\n\n\n\n**拓扑有序序列**\n\n在AOV网没有回路的前提下，将全部活动排列成一个线性序列，若从顶点V<sub>i</sub>到V<sub>j</sub>有一条路径，那么V<sub>i</sub>必在V<sub>j</sub>之前\n\n我们称这样的线性序列为**拓扑有序序列**\n\n**检测AOV中是否存在环**\n\n对有向图构造拓扑有序序列，若所有点都在拓扑有序序列中，则AOV网必不存在环\n\n\n\n## 7.关键路径\n\n**AOE网**\n\n以弧表示活动，以顶点表示活动的开始或者结束事件\n\n**关键路径**\n\n路径长度最长的路径\n\n### 7.1定义参数\n\n|     定义参数      |               作用                |\n| :---------------: | :-------------------------------: |\n| ve(V<sub>j</sub>) | 表示事件V<sub>j</sub>最早发生时间 |\n| vl(V<sub>j</sub>) | 表示事件V<sub>j</sub>最迟发生时间 |\n|       e(i)        |       表示活动i最早开始时间       |\n|       l(i)        |       表示活动i最晚开始时间       |\n\nl(i) - e(i) -----表示完成活动i的时间余量\n\n**关键活动** -----l(i) == e(i)\n\n\n\n**求关键路径步骤**\n\n1. 求ve(V<sub>j</sub>)、vl(V<sub>j</sub>)\n2. 求e(i)、l(i)\n3. 计算l(i) - e(i)\n\n\n\n\n\n# 查找\n\n## 1.查找概论\n\n**查找表(Search Table)**是由同一类型的数据元素构成的集合\n\n**关键字(Key)**是数据元素中的某个数据项的值\n\n若此关键字可以唯一地标记一个记录，则称此关键字为**主关键字(Primary Key)**\n\n对于可以识别多个数据元素的关键词，称为**次关键字(Secondary Key)**\n\n\n\n**查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素**\n\n\n\n**静态查找表**：只做查找操作的查找表\n\n1. 查询特定的数据元素是否在查找表中\n2. 检索特定的数据元素和各种属性\n\n\n\n**动态查找表**：在查找过程中同时插入表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素\n\n1. 查找时插入数据元素\n2. 查找时删除数据元素\n\n\n\n\n\n## 2.顺序表查找\n\n针对线性表进行查找操作，所以为静态查找表\n\n\n\n**顺序查找(Sequential Search)**又叫线性查找，是最基本的查找技术，查找过程如下：\n\n从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较\n\n若某个记录的关键字和给定值相等，则查找成功\n\n若直到最后一个（或者第一个）记录的关键字和给定值比较都不等时，查找失败\n\n\n\n实现算法如下\n\n```c\nint Sequential_Search(int *a, int n, int key){\n    int i;\n    for (i = 1; i <= n; i++){\n        if (a[i] == ket)\n            return i;\n    }\n    return 0;\n}\n```\n\n优化\n\n```c\n//有哨兵顺序查找\nint Sequential_Search2(int *a, int n, int key){\n    int i;\n    a[0] = key;\t\t\t\t\t/*设置a[0]为关键字值，称之为“哨兵”*/\n    i = n;\t\t\t\t\t\t/*循环从数组尾部开始*/\n\twhile (a[i] != key){\n        i--;\n    }\n    return i;\n}\n```\n\n\n\n## 3.有序表查找\n\n### 3.1二分查找\n\n**折半查找(Binary Search)**又称二分查找\n\n前提是线性表中记录必须是**关键码有序**（通常从小到大有序），线性表必须采用顺序存储\n\n\n\n```c\nint Binary_Search(int *a, int n, int key){\n    int low, high, mid;\n    low = 1;\n    high = n;\n    while (low <= high){\n        mid = (low + high) / 2;\n        if (key < a[mid])\n            high = mid - 1;\n        else if(key > a[mid])\n            low = mid + 1;\n        else \n            return mid;\n    }\n    return 0;\n}\n```\n\n\n\n**时间复杂度O(logn)**\n\n\n\n### 3.2插值查找\n\n将二分查找的代码做略微变换\n\n$$mid = \\frac{low + high}{2}$ =$low + \\frac{1}{2}(high - low)$$\n\n改为以下计算方案\n\n$$mid = low + \\frac{key - a[low]}{a[high] - a[low]}(high - low)$$\n\n\n\n\n\n### 3.3斐波那契查找\n\n\n\n```c\nint Fibonacci_Search(int *a, int n, int ket){\t\t/*F[n]为已经计算好的斐波那契数列*/\n    int low, high, mid, i, k;\n    low = 1;\n    high = n;\n    k = 0;\n    while (n > F[k] - 1)\t\t\t\t\t\t\t/*计算n位斐波那契数列的位置*/\n        k++;\t\t\t\t\t\t\t\t\t\t\t\n    for (i = n; i < F[K] - 1; i++)\t\t\t\t\t/*将数值补全*/\n        a[i] = a[n];\n    //查找开始\n    while (low <= high){\t\t\t\t\t\t\t\n        mid = low + F[K - 1] - 1;\t\t\t\t\t/*计算当前分隔下标*/\n        if (key < a[mid]){\n            high = mid - 1;\n            k = k - 1;\n        }\n        else if (key > a[mid]){\n            low = mid + 1;\n            k = k - 2;\n        }\n        else{\n            if (mid <= n)\n                return mid;\n            else\n                return n;\n        }\n    }\n    return 0;\n}\n```\n\n**时间复杂度O(logn)**\n\n### 3.4对比\n\n时间复杂度相同\n\n斐波那契查找只进行简单加减法运算$mid=low+F[k-1]-1$\n\n折半查找进行加法与除法运算$mid=\\frac{low+high}{2}$\n\n插值查找进行复杂四则运算$$mid = low + \\frac{key - a[low]}{a[high] - a[low]}(high - low)$$\n\n三种有序表的查找法本质上是分隔点选择不同，各有优劣\n\n\n\n\n\n## 4.线性索引查找\n\n索引就是把一个关键字与它对应的记录相关联的过程\n\n线性索引就是将索引项集合组织为线性结构，也称为**索引表**\n\n\n\n### 4.1稠密索引\n\n稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项\n\n对于稠密索引来说，**索引项一定是按照关键码有序排列的**\n\n意味着可以用到折半、插值、斐波那契等有序查找法\n\n\n\n### 4.2分块索引\n\n分块有序，是把数据集的记录分成了若干块，并且这些块需要满足一下两个条件\n\n1. 块内无序\n2. 块间有序\n\n我们定义的分块索引项结构分三个部分\n\n- 最大关键码\n- 存储块中记录个数\n- 用于指向块首数据元素的指针\n\n\n\n在分块索引表中查找就是进行以下两步\n\n1. 在分块索引表中查找要查关键字所在的块\n2. 根据块首指针找到相应的块，并在块中顺序查找关键码\n\n\n\n总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中\n\n\n\n### 4.3倒排索引\n\n索引项的通用结构是\n\n- 次关键码\n- 记录号表\n\n其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）\n\n\n\n## 5.二叉排序树\n\n**二叉排序树(Binary Sort Tree)**，又称为二叉查找树。它或者是一棵空树，或者是具有以下性质的二叉树\n\n- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值\n- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值\n- 它的左、右子树也分别为二叉排列树\n\n构造一棵二叉排序树的目的，不是为了排序，而是为了提高查找和插入删除关键字的速度\n\n\n\n### 5.1查找操作\n\n```c\n//二叉树的二叉链表的结点结构定义\ntypedef struct BiTNode{\n    int data;\n    struct BiTNode *lchild, *rchild;\n}BiTNode, *BiTree;\n```\n\n\n\n二叉排序树的查找\n\n```c\nStatus SearchBST(BiTree T, int key, BiTree f, BiTree *p){\n    //递归查找二叉排序树T中是否存在key\n    if (!T){\t\t\t\t\t\t\t\t/*若查找不成功，指针p指向查找路径上访问的最后一个结点并返回FALSE*/\n        *p = f;\n        return FALSE;\n    }\n    else if (key == T->data){\t\t\t\t/*若查找成功，则指针p指向该数据元素结点，并返回TRUE*/\n        *p = T;\n        return TRUE;\n    }\n    else if (key < T->data)\n        return SearchBST(T->lchild, key, T, p); /*在左子树中继续查找*/\n   \telse if (key > T->data)\n        return SearchBST(T->rchild, key, T, p); /*在右子树中继续查找*/\n}\n```\n\n\n\n### 5.2插入操作\n\n将关键字放到树中合适的位置\n\n```c\nStatus InsertBST(BiTree *T, int key){\n    BiTree p, s;\n    if (!SearchBST(*T, key, NULL, &p)){\t\t\t/*查找不成功*/\n        s = new BiTNode;\n        s->data = key;\n        s->lchild = s->rchild = NULL;\n        if (!p)\n            *T = s;\t\t\t\t\t\t\t\t/*插入s为新的根结点*/\n        else if (key < p->data;)\t\t\t\t\n            p->lchild = s;\t\t\t\t\t\t/*插入s为左孩子*/\n        else\n            p->rchild = s;\t\t\t\t\t\t/*插入s为右孩子*/\n        return TRUE;\n    }    \n    else \n        return FALSE;\t\t\t\t\t\t\t/*树中已有与关键字相同结点，不再插入*/\n}\n```\n\n\n\n### 5.3删除操作\n\n删除结点三种情况\n\n- 叶子结点\n- 仅有左子树或右子树结点\n- 左右子树都有的结点\n\n```c\n//查找关键字等于key的结点，找到则删除数据结点\nStatus DeleteBST(BiTree *T, int key){\n    if (!T)\n        return FLASE;\n    else{\n        if (key == T->data)\t\t\t\t\t\t/*找到关键字key的数据元素*/\n            return Delete(T);\n        else if (key < T->data)\n            return DeleteBST(T->lchild, key);\n        else \n            return DeleteBST(T->rchild, key);\n    }\n}\n```\n\n上述代码与二叉排序树查找几乎完全相同，区别在于找到后执行的是删除操作\n\n\n\n```C\nStatus Delete(BiTree *p){\n    //从二叉排序树中删除结点p，并重接他的左右子树\n    BiTree *q, *s;\n    if (p->rchild == NULL){\t\t\t\t\t\t/*右子树空则重接左子树(叶子也走此分支)*/\n        q = p;\n        p = p->lchild;\n        delete(q);\n    }\n    else if (p->lchild == NULL){\t\t\t\t/*左子树空则重接右子树*/\n        q = p;\n        p = p->rchild;\n        delete q;\n    }\n    else {\t\t\t\t\t\t\t\t\t\t/*左右均不空*/\n        q = p;\n        s = p->lchild;\n        while (s->rchild){\t\t\t\t\t\t/*找到左子树的右结点（找到待删结点的前驱）*/\n            q = s;\n            s = s->rchild;\n        }\t\t\t\t\t\n        p->data = s->data;\n        if (q != p)\n            q->rchild = s->lchild;\n        else\n            q->lchild = s->lchild;\n        delete s;\n    } \n}\n```\n\n\n\n## 6.平衡二叉树\n\n平衡二叉树是一种二叉排序树，其中每个结点的左子树和右子树高度差至多为1\n\n是一种高度平衡的二叉排序树，二叉树上节点的左子树高度减去右子树高度的值称为**平衡因子BF(Balance Factor)**\n\n那么平衡二叉树上所有结点的平衡因子只可能是1、0、-1\n\n距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为**最小不平衡树**\n\n\n\n{% mermaid %}\ngraph TD\n\n\tA1((A)) --- B1((B)) & D1(( ))\n\tB1 --- C1((C)) & E1(( ))\n\t%%style D fill:#f100,stroke-width:0px\n    %%style E fill:#f100,stroke-width:0px%% 设置F属性为填充为白色，边框宽度为0\n    linkStyle 1 stroke:#off, stroke-width:0px;\n    linkStyle 3 stroke:#off, stroke-width:0px;\n    \n    \n\tA2((A)) --- B2((B)) & D2(( ))\n\tB2 --- C2(( )) & E2((C))\n    linkStyle 5 stroke:#off, stroke-width:0px;\n    linkStyle 6 stroke:#off, stroke-width:0px;\n    \n    A3((A)) --- B3(( )) & D3((B))\n\tD3 --- C3((C)) & E3(( ))\n    linkStyle 8 stroke:#off, stroke-width:0px;\n    linkStyle 11 stroke:#off, stroke-width:0px;\n    \n    A4((A)) --- B4(( )) & D4((B))\n\tD4 --- C4(( )) & E4((C))\n    linkStyle 12 stroke:#off, stroke-width:0px;\n    linkStyle 14 stroke:#off, stroke-width:0px;\n    \n    class D1,E1,D2,C2,B3,E3,B4,C4 X;\n\tclassDef X fill:#f100, stroke-width:0px;\n{% endmermaid %}\n\n{% mermaid %}\ngraph TD\n\tA1((B)) --- B1((C)) & D1((A))\n\tA2((C)) --- B2((B)) & D2((A))\n\tA3((C)) --- B3((A)) & D3((B))\n\tA4((B)) --- B4((A)) & D4((C))\n{% endmermaid %}\n\n### 6.1代码实现\n\n**结点结构**\n\n增加一个变量`bf`用来存储平衡因子\n\n```c\ntypedef struct BiTNode;{\n    int data;\n    int bf;\n    struct BiTNode *lchild, *rchild;\n}BiTNode, *BiTree;\n```\n\n**右旋操作**\n\n```c\n//对P为根的二叉排序树作右旋处理\nvoid R_Rotate(BiTree *p){\n    BiTree *L;\n    L = p->lchild;\n    p->lchild = L->lchild;\n    L->rchild = p;\n    p = L;\n}\n```\n\n**左旋操作**\n\n```c\n//对P为根的二叉排序树作左旋处理\nvoid L_Rotate(BiTree *p){\n    BiTree *R;\n\tR = p->rchild;\n    p->rchild = R->lchild;\n    R->lchild = p;\n    p = L;\n}\n```\n\n**左平衡旋转**\n\n```c\n#define LH +1\t\t\t\t\t\t\t\t\t\t/*左高*/\n#define EH 0\t\t\t\t\t\t\t\t\t\t/*等高*/\n#define RH -1\t\t\t\t\t\t\t\t\t\t/*右高*/\n\nvoid LeftBalance(BiTree *T){\n    BiTree *L, *Lr;\n    L = T->lchild;\n    switch (L->bf){\t\t\t\t\t\t\t\t\t/*检查T的左子树平衡度，并做相应处理*/\n        case LH:\t\t\t\t\t\t\t\t\t/*（LL）新结点插入在T的左孩子的左子树上，要作单右旋处理*/\n            T->bf = L->bf =EH;\n            R_Rotate(T);\n            break;\n        case RH:\t\t\t\t\t\t\t\t\t/*新结点插入在T的左孩子的右子树上，要做双旋处理*/\n            Lr =L->rchild;\t\t\t\t\t\t\t/*Lr指向T的左孩子的右子树根*/\n            switch (Lr->bf){\t\t\t\t\t\t/*修改T及其左孩子的平衡因子*/\n                case LH:\n                    T->bf = RH;\n                    L->bf = EH;\n                 \tbreak;\n                case EH:\n                    T->bf = L->bf =EH;\n                \tbreak;\n                case RH:\n                    T->bf = EH;\n                    L->bf = LH;\n                    break;\n            }\n            Lr->bf =EH;\n            L_Rotate(T->lchild);\n            R_Rotate(T);\n    }\n}\n```\n\n**右平衡旋转**\n\n```c\nvoid RightBalance(BiTree *T){\n    BiTree *R, *Rl;\n    R = T->lchild;\n    switch (R->bf){\t\t\t\t\t\t\t\t\t/*检查T的右子树平衡度，并做相应处理*/\n        case RH:\t\t\t\t\t\t\t\t\t/*（RR）新结点插入在T的右孩子的右子树上，要作单左旋处理*/\n            T->bf = R->bf =EH;\n            L_Rotate(T);\n            break;\n        case LH:\t\t\t\t\t\t\t\t\t/*新结点插入在T的右孩子的左子树上，要做双旋处理*/\n            Rl =R->lchild;\t\t\t\t\t\t\t/*Rl指向T的右孩子的左子树根*/\n            switch (Rl->bf){\t\t\t\t\t\t/*修改T及其右孩子的平衡因子*/\n                case RH:\n                    T->bf = LH;\n                    R->bf = EH;\n                 \tbreak;\n                case EH:\n                    T->bf = R>bf =EH;\n                \tbreak;\n                case LH:\n                    T->bf = EH;\n                    R->bf = RH;\n                    break;\n            }\n            Rl->bf =EH;\n            R_Rotate(T->rchild);\n            L_Rotate(T);\n    }\n}\n```\n\n\n\n\n\n## 7.多路查找树（B树）\n\n**多路查找树（Muiltl-Way Search Tree）**，其每个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素\n\n\n\n设置一个结点数据元素上限set a cap on the num of items\n\n如果超出上限，就将其中一个元素给双亲结点if more than cap, give an item to parent\n\n**left-middle**\n\n再将超出上限的结点分成左右两个结点\n\n\n\n### 7.1 2-3树\n\n每个结点都有两个孩子或三个孩子\n\n一个2结点包含一个元素和两个孩子（或没有孩子）\n\n一个3结点包含一小一大两个元素和三个孩子（或没有孩子）\n\n\n\n\n\n### 7.2 2-3-4树\n\n一个4结点包含小中大3个元素和4个孩子（或没有孩子）\n\n\n\n### 7.3 B树\n\n**B树(B-tree)**是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例\n\n结点最大的孩子数目称为B树的阶\n\n\n\n### 7.4 B+树\n\n\n\n## 8.散列表（哈希表）\n\n### 8.1定义\n\n$存储位置 = f (关键字)$\n\n散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系$f$,使得每个关键字key对应一个存储位置$f(key)$\n\n对应关系$f$称为**散列函数**，又称**哈希(Hash)函数**\n\n采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为**散列表**或**哈希表(Hash Table)**\n\n\n\n散列技术既是一种存储方法，也是一种查找方法\n\n散列技术最适合的求解问题是查找与给定值相等的记录\n\n\n\n两个关键字$key_1 \\neq key_2$，但是却有$f(key_1) = f(key)_2$，这种现象我们称为**冲突(collision)**，并把$key_1$和$key_2$称为这个函数的同义词(synonym)\n\n\n\n### 8.2构造方法\n\n 原则\n\n1. 计算简单\n2. 散列地址分布均匀\n\n\n\n**1.直接定址法**\n\n去关键字的某个线性函数值为散列地址\n\n$f(key) = a * key + b$\n\n\n\n**2.数字分析法**\n\n\n\n**3.平方取中法**\n\n\n\n**4.折叠法**\n\n\n\n**5.除留余数法**\n\nf(key) = key  mod  p\n\n**6.随机数法**\n\n\n\n### 8.3处理散列冲突\n\n**1.开放定址法**\n\n开放定址法是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入\n\n公式是\n\n$f_i(key) = (f(key)+d_i) MOD m$  $d_i = 1, 2, 3, …, m-1$\n\n**线性探测法**\n\n本来就不为同义词却争夺同一地址的情况，称为**堆积**\n\n\n\n$f_i(key) = (f(key)+d_i) MOD m$  $d_i = 1^2, -1^, 2^2, -2^2,…,q^2, -q^2, q\\leq m/2$\n\n增加平方运算的目的是为了不让关键字都聚集在某一块区域，这种方法称为**二次探测法**\n\n\n\n\n\n**2.再散列函数法**\n\n对于散列表，实现准备多个散列函数\n\n$f_i(key) = RH_i(key)$\n\n\n\n这种方法可以使得关键字不产生聚集，相应增加了计算时间\n\n\n\n**3.链地址法**\n\n将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表\n\n在散列表中只存储所有同义词子表头指针，无论有多少冲突，都只是在当前位置给单链表增加节点的问题\n\n\n\n提供了不会出现找不到地址的保障，但查找时需要遍历单链表造成性能损耗\n\n\n\n**4.公共溢出区法**\n\n为所有冲突关键字建立一个公共溢出区来存放\n\n查找时，对给定值通过散列表计算出散列地址后，先于基本表的相应位置进行对比，相等则查找成功\n\n不相等，则到溢出表进行顺序查找\n\n\n\n相对于基本表而言，冲突数据较少的情况下，公共溢出区的结构对查找性能来说还是非常高的\n\n\n\n### 8.4散列表查找的实现\n\n```c\n#define SUCCESS 1\n#define UNSUCCESS 0\n#define HASHSIZE 12\n#define NULLKEY -32768\n\ntypedef struct{\n    int *elem;\t\t\t\t/*数据元素存储基址，动态分配数组*/\n    int count;\t\t\t\t/*当前数据元素个数*/\n}HashTable;\n\nint m = 0;\t\t\t\t\t/*散列表表长，全局变量*/\n```\n\n\n\n```c\n//初始化散列表\nStatus InitHashTable(HashTable *H){\n    int i;\n    m = HASHSIZE;\n    H->count = m;\n    H->elem = new int;\n    for (i = 0; i < m; i++){\n        H->elem[i] = NULLKEY；\n    }\n    return OK;\n}\n```\n\n\n\n```c\n//散列函数\nint Hash(int key){\n    return key % m;        /*除留余数法*/\n}\n```\n\n\n\n```c\n//插入关键字进散列表\nvoid InsertHash(HashTable *H, int key){\n    int addr = Hash(key);\t\t\t\t/*求散列地址*/\n    while (H->elem[addr] != NULLKEY){\t/*若不为空，则冲突*/\n        addr = (addr + 1) % m;\t\t\t/*开放定址法的线性探测*/\n    }\n    H->elem[addr] = key;\t\t\t\t/*直到有空位后插入关键字*/\n}\n```\n\n\n\n```c\n//散列表查找关键字\nStatus SearchHash(HashTable H, int key, int *addr){\n    *addr = Hash(key);\t\t\t\t\t/*求散列地址*/\n    while (H.elem[*addr] != key){\t\t\n        *addr = (*addr + 1) % m;\t\t/*开放定址法的线性探测*/\n        if (H.elem[*addr] == NULLKEY || *addr == Hash(key))\t\t/*若循环回到原点*/\n            return UNSUCCESS;\n    }\n    return SUCCESS;\n}\n```\n\n\n\n\n\n# 排序\n\n优秀排序算法的首要条件就是**速度**\n\n## 1.基本概念与分类\n\n**1.排序的稳定性**\n\n假设$k_i = k_j$，且在排序前的序列中$r_i$领先与$r_j$即（$i < j$）\n\n如果排序后$r_i$仍领先与$r_j$，则称所用的排序方法是稳定的；\n\n反之，若可能使得排序后的序列中$r_j$领先与$r_i$，则称所用的排序的方法是不稳定的\n\n\n\n**2.内排序与外排序**\n\n内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中\n\n外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行\n\n\n\n## 2.结构与函数\n\n```c\n#define MAXSIZE 1000\ntypedef struct{\n    int r[MAXSIZE + 1];\n    int length;\n}SqList;\n```\n\n\n\n```c\n//交换L中数组r的下标为i和j的值\nvoid swap(SqList *L, int i, int j){\n    int temp = L->r[i];\n    L->r[i] = L->r[j];\n    L->r[j]\t= temp;\n}\n```\n\n\n\n## 3.冒泡排序\n\n冒泡排序是一种交换排序，最基本的思想是两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止\n\n```c\n//对顺序表进行冒泡排序\nvoid BubbleSort(SqList *L){\n    int i,j;\n    for (i = 1; i < L->length; i++){\n        for (j = L->length - 1; j >= i; j--){\n            if (L->r[j - 1] > L->r[j])\n                swap(L, j-1, j);\n        }\n    }\n}\n```\n\n\n\n冒泡排序优化\n\n```c\n//改进\nvoid BubbleSort(SqList *L){\n    int i,j;\n    /////////\n    Status flag = TRUE;\n    /////////\n    for (i = 1; i < L->length && flag; i++){\n        flag = FALSE;\n        for (j = L->length - 1; j >= i; j--){\n            if (L->r[j - 1] > L->r[j]){\n                swap(L, j-1, j);\n                flag = TRUE;\n            } \n        }\n    }\n}\n```\n\n**总的时间复杂度为O($n^2$)**\n\n\n\n## 4.简单选择排序\n\n```c\n//对顺序表L作简单选择排序\nvoid SelectSort(SqList *L){\n    int i, j, min;\n    for (i = 1; i < L->length; i++){\n        min = i;\t\t\t\t\t\t\t\t/*当前下标定义为最小值*/\n        for (j = i + 1; j <= L->length; j++){\n            if (L->r[min] > L->r[j])\t\t\t/*如果有小于当前最小值的关键字，将此关键字下标赋值给min*/\n                min = j;\n        }\n        if (i != min)\t\t\t\t\t\t\t/*若min不等于i，说明找到最小值，交换*/\n            swap(L, i, min);\n    }\n}\n```\n\n**时间复杂度为O($n^2$)**\n\n性能上略优于冒泡排序\n\n\n\n## 5.直接插入排序\n\n直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表\n\n```c\n//对顺序表L作直接插入排序\nvoid InsertSort(SqList *L){\n    int i, j;\n    for (i = 2; i <= L->length; i++){\n        if (L->r[i] < L->r[i - 1]){\t\t\t\t/*将L->r[i]插入有序子表*/\n            L->r[0] = L->r[i];\t\t\t\t\t/*设置哨兵*/\n            for (j = i - 1; L->r[j] > L->r[0]; j--)\n                L->r[j + 1] = L->r[j];\t\t\t/*记录后移*/\n            L->r[j + 1] = L->r[0];\t\t\t\t/*插入到正确位置*/\n        }\n    }\n}\n```\n\n**时间复杂度为O($n^2$)**\n\n性能上略优于冒泡排序和简单选择排序\n\n\n\n## 6.希尔排序\n\n(shell Sort)\n\n**基本有序**：小的关键字基本在前面，大的基本在后面，不大不小的基本在中间\n\n将相距某个”增量“的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序\n\n\n\n```c\n//希尔排序算法\nvoid ShellSort(SqList *L){\n    int i, j, k = 0;\n    int increment = L->length;\n    do{\n        increment = increment/3 + 1;\t\t\t\t\t/*增量序列*/\n        for (i = increment + 1; i <= L->length){\n            if (L->r[i] < L->r[i - increment]){\t\t\t/*需将L->[i]插入有序增量子表*/\n                L->r[0] = L->r[i];\t\t\t\t\t\t/*暂存在L->r[0]*/\n                for (j = i - increment; j > 0 && L->r[0] < L->r[j]; j -= increment)\n                    L->r[j + increment] = L->r[j];\t\t/*记录后移，查找插入位置*/\n                L->r[j + increment] = L->r[0];\t\t\t/*插入*/\n            }\n        }\n    }while (increment > 1);\n}\n```\n\n**增量序列最后一个增量值必须等于1**\n\n时间复杂度O($n^\\frac{3}{2}$)\n\n\n\n## 7.堆排序\n\n堆是具有下列性质的二叉树：\n\n- 每个结点的值都大于或等于其左右孩子结点的值，称为**大顶堆**\n- 或者每个结点的值都小于或等于其左右孩子结点的值，称为**小顶堆**\n\n\n\n```c\n//对顺序表L进行堆排序\nvoid HeapSort(SqList *L){\n    int i;\n    for (i = L->length/2; i > 0; i--)\t\t\t\t\t/*构造大顶堆*/\n        HeapAdjust(L, i, L->length);\n    for (i = L->length; i > 1; i--){\t\t\t\t\t\n        swap(L, 1, i);\t\t\t\t\t\t\t\t\t/*将堆顶记录和当前未经排序子序列最后一记录交换*/\n        HeapAdjust(L, 1, i - 1);\t\t\t\t\t\t/*将L->r[1..i - 1]重新调整为大顶堆*/\n    }\n}\n```\n\n\n\n```c\n//堆调整\nvoid HeapAdjust(SqList *L, int s, int m){\n    int temp, j;\n    temp = L->r[s];\n    for (j = 2 * s; j <= m; j *= 2){\t\t\t\t\t/*沿关键字较大的孩子结点向下筛选*/\n        if (j < m && L->r[j] < L->r[j + 1])\n            ++j;\t\t\t\t\t\t\t\t\t\t/*j为关键字中较大的记录的下标*/\n        if (temp >= L->r[j])\n            break;\t\t\t\t\t\t\t\t\t\t/*rc应插入在位置s上*/\n        L->r[s] = L->r[j];\n        s = j;\n    }\n    L->r[s] = temp;\t\t\t\t\t\t\t\t\t\t/*插入*/\n}\n```\n\n\n\n```c\n//排序\nfor (i = L->lenth; i > 1; i--){\n    swap(L, 1, i);\n    HeapAdjust(L, 1, i - 1);\n}\n```\n\n\n\n**时间复杂度O(nlogn)**\n\n记录的比较是跳跃式进行，所以堆排序是一种不稳定的排序方法\n\n初始构建堆所需要的次数较多，不适合待排序序列个数较少情况\n\n\n\n## 8.归并排序\n\n**归并排序（Merging Sort）**\n\n```c\n//对顺序表L作归并排序\nvoid MergeSort(SqList *L){\n    Msort(L->r, L->r, 1, L->length);\n}\n```\n\n\n\n```c\nvoid MSort(int SR[], int TR1[], int s, int t){\n    int m;\n    int TR2[MAXSIZE + 1];\n    if (s == t){\n        TR1[s] = SR[s];\n    }\n    else{\t\n        m = (s + t) / 2;\t\t\t\t\t/*将SR[s..t]平分为SR[s..m]和s[m+1..t]*/\n        MSort(SR, TR2, s, m);\t\t\t\t/*将SR[s..m]归并为有序序列TR2[s..m]*/\n        MSort(SR, TR2, m + 1, t);\t\t\t/*将SR[m+1..t]归并为有序序列TR2[m+1..t]*/\n        Merge(SR, TR2, s, m, t);\t\t\t/*将TR2[s..m]和TR2[m+1..t]归并到TR1[s..m]*/\n    }\n}\n```\n\n\n\n```c\n//将SR[s..m]和SR[m+1..t]归并到TR[s..m]\nvoid Merge(int SR[], int TR[], int i, int m, int n){\n    int j, k, l;\n    for (j = m + 1, k = i; i <= m && j <= n; k++){\t\t\t/*将SR中记录由小到大并入TR*/\n        if (SR[i] < SR[J])\n            TR[k] = SR[i++];\n        else\n            TR[k] = SR[j++];\n        if (i <= m){\n            for (l = 0; l <= m - i; l++)\n                TR[k + l] = SR[i + l];\t\t\t\t\t\t/*将剩余SR[i..m]复制到TR*/\n        }\n        if (j <= n){\n            for (l = 0; l <= n - j; l++)\n                TR[k + l] = SR[j + l];\t\t\t\t\t\t/*将剩余SR[j..n]复制到TR*/\n        }\n    }\n}\n```\n\n**时间复杂度O(nlogn)**\n\n归并排序是一种稳定的排序算法，比较占用内存，但效率高且稳定\n\n\n\n## 9.快速排序\n\n**快速排序（Quick Sort）**的基本思想是：通过一趟排序将待排记录分割成独立的两部分\n\n其中一部分记录的关键字比另一部分小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的\n\n\n\n```c\n//对顺序表L作快速排序\nvoid QuickSort(SqList *L){\n    QSort(L, 1, L->length);\n}\n```\n\n\n\n```c\n//对顺序表L中子序列L->r[low..high]作快速排序\nvoid QSort(SqList *L, int low, int high){\n    int pivot;\n    if (low < high){\n        //将L->r[low..high]一分为二，算出枢轴值pivot\n        pivot = Partition(L, low, high);\n        QSort(L, low, pivot - 1);\t\t\t/*对低子表递归排序*/\n        QSort(L, pivot + 1, high);\t\t\t/*对高子表递归排序*/\n    }\n}\n```\n\nPatition（）要做的，就是选取当中一个关键字，想尽办法将它放到一个位置\n\n使得它左边的值都比它小，右边的值都比它大，这样的关键词称为枢轴(Pivot)\n\n\n\n```c\nint Patition(SqList *L, int low, int high){\n    int pivotkey;\n    pivotkey = L->r[low];\t\t\t\t/*用子表的第一个记录作枢轴记录*/\n    while (low < high){\t\t\t\t\t/*从表的两端交替地向中间扫描*/\n        while (low < high && L->r[low] >= pivotkey)\n            high--;\n        swap(L, low, high);\t\t\t\t/*将比枢轴记录小的记录交换到低端*/\n        \n        while (low < high && L->r[low] <= pivotkey)\n            low++;\n        swap(L, low, high);\n    }\n    return low;\t\t\t\t\t\t\t/*返回枢轴所在位置*/\n}\n```\n\n**时间复杂度O($n^2$)**\n\n由于关键字比较和交换是跳跃进行，因此快速排序是一种不稳定排序\n\n\n\n#### **快速排序优化**\n\n##### 1.优化选取枢轴\n\n- 固定选取（原）\n- 随机选取\n- 三数取中\n\n```c\nint pivotkey;\n\nint m = low + (high - low) / 2;\nif (L->r[low] > L ->r[high])\n    swap(L, low, high);\nif (L->r[m] > L ->r[high])\n    swap(L, m, high);\nif (L->r[low] > L ->r[m])\n    swap(L, low, high);\n//此时，r[low]已经为整个序列左、中、右三个关键字的中间值\n\npivokey = L->r[low];\n```\n\n- 九数取中\n\n\n\n##### 2.优化不必要的交换\n\n==``L->r[0] = pivotkey``==\n\n采用替换而不是交换的方式进行操作\n\nL->r[low] = L->r[high]\n\n```c\nint Patition(SqList *L, int low, int high){\n    int pivotkey;\n    pivotkey = L->r[low];\t\t\t\t/*用子表的第一个记录作枢轴记录*/\n    L->r[0] = pivotkey\n    while (low < high){\t\t\t\t\t/*从表的两端交替地向中间扫描*/\n        while (low < high && L->r[low] >= pivotkey)\n            high--;\n        L->r[low] = L->r[high]\t\t\t/*采用替换而不是交换的方式进行操作*/\n        \n        while (low < high && L->r[low] <= pivotkey)\n            low++;\n        L->r[high] = L->r[low]\n    }\n    L->r[low] = L->r[0]\n    return low;\t\t\t\t\t\t\t/*返回枢轴所在位置*/\n}\n```\n\n##### 3.优化小数组时的排序方案\n\n```c\n#define MAX_LENGTH_INSERT_SORT 7\nvoid QSort(SqList *L, int low, int high){\n    int pivot;\n    if ((high - low) > MAX_LENGTH_INSERT_SORT){\n        ......\t\t\t\t\t\t\t/*采用快速排序*/\n    }\n    else\n        InsertSort(L);\t\t\t\t\t/*直接用插入排序*/\n}\n```\n\n\n\n##### 4.优化递归操作\n\n\n\n\n\n## 10.总结对比\n\n|   排序方法   |        平均情况        |      最好情况      |   最坏情况    |     辅助空间      | 稳定性 |\n| :----------: | :--------------------: | :----------------: | :-----------: | :---------------: | :----: |\n|   冒泡排序   |        O($n^2$)        |       O($n$)       |   O($n^2$)    |       O(1)        |  稳定  |\n| 简单选择排序 |        O($n^2$)        |      O($n^2$)      |   O($n^2$)    |       O(1)        |  稳定  |\n| 直接插入排序 |        O($n^2$)        |       O($n)$       |   O($n^2$)    |       O(1)        |  稳定  |\n|   希尔排序   | O($n\\log{n}$)~O($n^2$) | O($n^\\frac{3}{2}$) |   O($n^2$)    |       O(1)        | 不稳定 |\n|    堆排序    |     O($n\\log{n}$)      |   O($n\\log{n}$)    | O($n\\log{n}$) |       O(1)        | 不稳定 |\n|   归并排序   |     O($n\\log{n}$)      |   O($n\\log{n}$)    | O($n\\log{n}$) |       O(n)        |  稳定  |\n|   快速排序   |     O($n\\log{n}$)      |   O($n\\log{n}$)    |   O($n^2$)    | O($\\log{n}$)~O(1) | 不稳定 |\n\n\n\n- 简单算法：冒泡、简单选择、直接插入\n- 改进算法：希尔、堆、归并、快速\n\n\n\n从**平均情况**看，最后三种改进算法胜过希尔排序，并远胜于3钟简单算法\n\n从**最好情况**看，冒泡和直接插入排序更胜一筹。如果待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法\n\n从**最坏情况**看，堆排序与归并排序强于快速排序及其他简单排序\n\n从**稳定性**看，归并排序独占鳌头，对非常在乎排序稳定性的应用中，归并排序是个好算法\n\n从**待排序记录的个数**上看，待排序的个数越小，采用简单排序方法就越合适\n","source":"_posts/datastructure.md","raw":"---\ntitle: 数据结构整理\ncategories: 知识总结\ntags:\n    - data structure\ndate: 2023-08-09 10:00:00\ndescription: 对数据结构知识点的整理\n---\n# 基本定义\n\n## 数据\n\n### 1.数据\n\n能输入计算机且能被计算机处理的各种符号的集合\n\n1）数值型数据：整数、实数等\n\n2）非数值型数据：文字、图像、声音等\n\n### 2.数据元素\n\n数据的基本单位\n\n也称为元素、记录或结点\n\n例：  学号    姓名     专业      性别\n\n​           123    张三     电子      男\n\n### 3.数据项\n\n构成数据元素的不可分割的最小单位\n\n例：学号\n\n### 三者关系\n\n数据>数据元素>数据项\n\n### 4.数据对象\n\n性质相同的数据元素的集合，是数据的一个子集\n\n## **数据结构\n\n数据元素相互之间的关系称为结构\n\n### 1.逻辑结构\n\n#### 1.集合结构\n\n#### 2.线性结构\n\n#### 3.树形结构\n\n#### 4.图形结构\n\n### 2.物理结构或存储结构\n\n数据元素及其关系在计算机内存中的表示\n\n#### 1.顺序存储结构\n\n#### 2.链式存储结构\n\n****\n\n\n\n\n\n\n\n\n\n\n\n## 算法\n\n### 1.时间复杂度\n\n==O(1) < O(log n) < O(n) < O(n*log n) < O(n²) < O(n³) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)==\n\n\n\n\n\n\n\n# 线性表\n\n零个或者多个数据元素的有限序列\n\n\n\n线性表中，一个数据元素可以由若干个数据项组成\n\n## 1.顺序存储结构\n\n### 1.顺序存储定义\n\n线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表数据的元素。\n\n### 2.顺序存储方式\n\n```c\ntypedef struct{\n\tElemType data[MAXSIZE];\n\tint length;\n}Sqlist;\n```\n\n需要三个属性：  1.存储空间的起始位置 ： 数据data ,他的存储位置就是存储空间的存储位置\n\n​\t\t\t\t\t\t\t 2.线性表的最大存储容量：数组长度MAXSIZE\n\n​\t\t\t\t\t\t\t 3.线性表的当前长度：length\n\n### 3.线性表顺序存储结构的优缺点\n\n优点：无需为表中元素之间的逻辑关系而增加额外的存储空间\n\n​\t\t\t可以快速地存取表中的任一位置的元素\n\n\n\n缺点：插入和删除操作需要移动大量元素\n\n​\t\t    当线性表长度变化较大时，难以确定存储空间的容量\n\n​\t\t\t造成存储空间的“碎片”\n\n\n\n## 2.链式存储结构\n\n### 1.定义\n\nn个结点（a<sub>i</sub>的存储映像）链结成一个链表，即为线性表（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>）的链式存储结构\n\n\n\n**a<sub>i</sub>的存储映像**：1.数据域 \n\n​\t\t\t\t\t\t   2.指针域\n\n\n\n**头指针**：链表中第一个结点的存储位置\n\n~~最后一个结点指向空结点NULL~~\n\n\n\n### 2.头指针、头结点的异同\n\n**头指针**：1.头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针\n\n​\t\t\t\t2.头指针具有标志作用，所以常用头指针冠以链表的名字\n\n​\t\t\t\t3.无论链表是否为空，头指针均不为空。头指针是链表的必要元素\n\n\n\n**头结点**：1.头结点是为了操作的统一和方标而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）\n\n​\t\t\t\t2.有了头结点，对在第一元素结点之前插入结点和删除第一节点，其操作与其他结点的操作就统一了\n\n​\t\t\t\t3.头节点不一定就是链表的必需要素\n\n\n\n### 3.链表存储方式\n\n```c\n/*线性表的单链表存储结构*/\ntypedef struct Node{\n\tElemType data;\n\tstruct Node *next;\n}Node;\ntypedef struct Node *LinkList;\n```\n\n\n\n 对于插入或者删除数据越频繁的操作，单链表的效率优势就越明显 \n\n\n\n### 4.单链表结构与顺序存储结构的优缺点\n\n|              | 顺序存储方式                               | 单链表结构                                             |\n| ------------ | ------------------------------------------ | ------------------------------------------------------ |\n| 存储分配方式 | 用一段连续存储单元依次存储线性表的数据元素 | 采用链式存储结构，用一组任意的存储单元存放线性表的元素 |\n| 时间性能     | 查找：O（1）                               | 查找：O（n）                                           |\n|              | 插入和删除：O（n）                         | 插入和删除：O（1）                                     |\n| 空间性能     | 需要预分配存储空间                         | 不需要分配存储空间                                     |\n\n**线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构**\n\n**线性表中的元素个数变化较大或者不知道有多大时，最好用单链表结构**\n\n\n\n### 5.循环链表\n\n### 6.双向链表\n\n双向链表是在单链表的每个结点中，再设置一个指向其前驱节点的指针域\n\n{% mermaid %}\ngraph TD\n A((线性表)) --- B1 & C1\n B1(顺序存储结构)\n C1(链式存储结构) --- D1(单链表) & D2(静态链表) & D3(循环链表) & D4(双向链表)\n{% endmermaid %}\n\n\n\n\n\n\n\n\n\n\n\n\n# 栈与队列\n\n## 栈\n\n#### 1.栈的定义\n\n**栈(stack)是限定仅在表尾进行插入和删除操作的线性表**\n\n\n\n允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。\n\n栈又称为后进后出(Last In First Out)的线性表，简称LIFO结构\n\n\n\n#### 2.栈的顺序存储结构及实现\n\n顺序栈\n\n```C\ntypedef struct{\n\tElemType data[MAXSIZE]；\n\tint top;   /* 用于栈顶指针*/\n}SqStack;\n```\n\n\n\n#### 3.两栈共享空间\n\n```C\ntypedef struct{\n\tElemType data[MAXSIZE]；\n\tint top1;   /* 用于栈1栈顶指针*/\n\tint top2;   /* 用于栈2栈顶指针*/\n}SqDoubleStack;\n```\n\n\n\n使用这样的数据结构通常是两个栈的空间需求有相反关系，比如股票，买入时，一定是有人在卖出\n\n如果是不相同数据类型的栈，这种方法不但不能更好的处理问题，反而会使问题变得更复杂。\n\n\n\n#### 4.栈的链式存储结构及实现\n\n链栈\n\n```C\ntypedef struct StackNode{\n\tSElemType data;\n\tstruct StackNode *next;\n}StackNode, *LinkStackPtr;\n\ntypedef struct{\n\tLinkStackPtr top;\n\tint count;\n}LinkStack;\n```\n\n\n\n#### 5.栈的应用\n\n##### 1.递归\n\n###### 1.递归的定义\n\n一个直接调用自己或者通过一系列的调用语句间接调用自己的函数\n\n\n\n每个递归定义必须至少又一个条件，满足时递归不再进行，即不再引用自身而是返回值退出\n\n\n\n简单地说，在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。\n\n在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是回复了调用的状态\n\n\n\n##### 2.四则运算\n\n## 队列\n\n### 1.队列的定义\n\n队列(queue)是只允许在一段进行插入操作，而在另一端进行删除操作的线性表\n\n\n\n队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一段为队尾，允许删除的一端称为队头\n\n\n\n### 2.队列顺序存储\n\n问题：“假溢出”\n\n解决办法：循环队列\n\n**队列头尾相连的顺序存储结构称为循环队列**\n\n\n\n```C\ntypedef struct {\n\tQElemType data[MAXSIZE];\n\tint front;\t\t\t\t/*头指针*/\n\tint rear;\t\t\t\t/*尾指针，若队列不空，指向队列尾元素的下一个位置*/\n}SqQueue;\n```\n\n\n\n### 3.队列链式存储\n\n队列的链式存储，就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列。\n\n\n\n```C\ntypedef struct QNode{     /*结点结构*/\n    QElemtype data;\n    struct QNode *next;\n}QNode,*QueuePtr;\n\ntypedef struct{           /*队列链表结构*/\n    QueuePtr front, rear; /*队头、队尾指针*/\n}LinkQueue;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 串\n\n## 1.串的定义\n\n串(string)是由零个或多个字符组成的有限序列，又叫字符串\n\n\n\n## 2.串的存储结构\n\n### 2.1顺序存储结构\n\n### 2.2链式存储结构\n\n总的来说不如顺序存储灵活，也不如顺序存储结构好\n\n\n\n## 3.模式匹配算法\n\n**字串的定位操作通常称做串的模式匹配**\n\nn为主串长度、m为要匹配的子串长度\n\n最好情况：一开始就匹配成功，比如\"googlegood\"中找\"google\"，时间复杂度为O(m)\n\n稍差一些：每次首字母不匹配，比如\"abcdefgoogle\"中找\"google\"，时间复杂度为O(n+m)\n\n最坏情况：每次匹配不成功都发生在最后一个位置，比如\"0000000000000000000000000001\"中找\"0000001\"，时间复杂度为O((n-m+1)*m)\n\n**低效**\n\n\n\n#### 3.1 KMP模式匹配算法\n\n思想：\n\n\n\n代码实现：1.初始化\n\n​\t\t\t\t\t2.前后缀相同情况\n\n​\t\t\t\t\t3.前后缀不同情况\n\n​\t\t\t\t\t4.更新next值\n\n```C\nvoid get_Next(*next, s){\n\t/*i 后缀末尾 、 j 前缀末尾【也指i之前（包括i）最长相等前后缀长度】*/\n    \n    //初始化\n    j = 0;\t\t/*前缀从最开始的位置开始*/\n    next[0] = 0;\n    \n    for(i = 1; i < s.size(); i++){\t/*i要从位置1开始*/\n        \n        //前后缀不同情况\n        while(j > 0 && s[i] != s[j])  /*不能写成if*/\n            j = next[j - 1];\n        \n        //前后缀相同情况\n        if (s[i] == s[j])\n            j++;\n        \n        //更新next值\n        next[i] = j;\n    }\n}\n```\n\n\n\n#### 3.2 改进的KMP算法\n\n\n\n代码实现\n\n```C\nvoid get_nextval(*nextval, s){\n    while (i < T[0]){\n        if(j == 0 || T[i] = T[k]){\n             ++i;\n             ++j;\n            //区别如下\n            if (T[i] != T[k])   nextval[i] = j;\t\t/*若当前字符与前缀字符不同，则nextval与next无异*/\n            else   nextval[i] = nextval[j];\t\t\t/*若相同，则将nextval值赋值给nextval在i的位置的值*/\n        }\n        else k = nextval[k];\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 树\n\n## 1.树的定义\n\n树(Tree)是n(n>=0)个结点的有限集。n=0时称为空树。\n\n任意一颗非空树中：1）有且仅有一个特定的根(Root)结点\n\n​\t\t\t\t\t\t\t\t   2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集，其中每个集合本身又是一棵树，并且称为根的子树(Sub Tree)\n\n\n\n### 1.1结点的分类\n\n结点拥有的子树数称为结点的**度(Degree)**\n\n度为0的结点称为**叶结点(Leaf)**或终端结点\n\n度不为0的结点称为非终端结点或分支结点\n\n树的度是树内各结点的度的最大值\n\n\n\n### 1.2结点间的关系\n\n结点的子树的根称为该结点的**孩子(Child)**，相应的，该结点称为孩子的**双亲(Parent)**\n\n同一个双亲的孩子之间互称**兄弟(Sibling)**\n\n结点的祖先是从根到该结点所经分支上的所有结点\n\n以某结点为根的子树中的任一结点都称为该节点的子孙\n\n\n\n### 1.3其他相关概念\n\n**层次(Level)**：从根开始定义起，根为第一层，根的孩子为第二层\n\n双亲在同一层的结点互为**堂兄弟**\n\n树中结点最大层次称为树的**深度(Depth)**\n\n如果将树中结点的各子树看成是从左到右有次序的，不能互换的则称为**有序树**，否则称为**无序树**\n\n\n\n### 1.4线性表与树\n\n|                           线性结构                           |                            树结构                            |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n| 第一个数据元素：无前驱<br />最后一个数据元素：无后继<br />中间元素：一个前驱，一个后继 | 根结点：无双亲，唯一<br />叶结点：无孩子，可以多个<br />中间结点：一个双亲，多个孩子 |\n\n\n\n\n\n\n\n## 2.树的存储结构\n\n### 2.1双亲表示法\n\n在每个结点中，附设一个指示器指示其双亲结点在数组中的位置\n\n| data | parent |\n| :--: | :----: |\n\n其中，data为数据域，parent为指针域，存储该结点的双亲在数组中的下标\n\n\n\n代码实现\n\n```C\n//结点结构\ntypedef struct PTNode{\t\n    TElemType data;\t\t\t/*结点数据*/\n    int parent;\t\t\t\t/*双亲位置*/\n}PTNode;\n\n//树结构\ntypedef struct{\n    PTNode nodes[MAX_TREE_SIZE];\t/*结点数组*/\n    int r,n;\t\t\t\t\t\t/*根的位置和结点数*/\n}PTREE;\n```\n\n\n\n这样的存储结构可以很快找到他的双亲结点，所用时间复杂度为O(1)\n\n但若要知道结点的孩子是什么，就只能遍历整个结构\n\n所以可以增加一个长子域\n\n我们又关注结点的孩子、有关注结点的兄弟、对时间遍历的要求比较高，那么我们可以把此结构扩展为双亲域、长子域、右兄弟域\n\n**存储结构设计是一个非常灵活的过程**\n\n**一个存储结构设计的是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等**\n\n\n\n### 2.2孩子表示法\n\n****\n\n**每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法**\n\n\n\n1. 方案1\n\n   指针域的个数等于树的度\n\n   | data | child1 | child2 |  ……  | childd |\n   | :--: | :----: | :----: | :--: | :----: |\n\n   若树中各结点的度相差很大时，浪费空间\n\n   若相差较小，开辟的空间被充分利用了，则缺点变优点\n\n2. 方案2\n\n   指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数\n\n   | data | degree | child1 | child2 |  ……  | childd |\n   | :--: | :----: | :----: | :----: | :--: | :----: |\n\n   克服了浪费空间的缺点，提高了空间利用率\n\n   但由于各结点的链表结构不同，加上要维护结点的度和数值，在运算上就会带来时间上的损耗\n\n\n\n所以采用孩子表示法\n\n具体办法是：\n\n**把每个结点的孩子排列起来，以单链表作为存储结构，则n个节点有n个孩子链表**\n\n**如果是叶子结点则此单链表为空。**\n\n**然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一堆数组中**\n\n\n\n为此，设计了两种结点结构\n\n1.孩子链表的孩子结点\n\n| child | next |\n| :---: | :--: |\n\n其中，child是数据域，用来存储某个结点在表头数组中的下标；next是指针域，用来存储指向某结点的下一个孩子结点的指针\n\n2.表头数组的表头结点\n\n| data | firstchild |\n| :--: | :--------: |\n\n其中，data是数据域，存储某结点的数据信息；firstchild是头指针域，存储该结点的孩子链表的头指针\n\n\n\n代码实现\n\n```C\n//孩子结点\ntypedef struct CTNode{\n    int child;\n    struct CTNode *next;\n}*ChildPtr;\n\n//表头结构\ntypedef struct{\n    TElemType data;\n    ChildPtr firstchild;\n}CTBox;\n\n//树结构\ntypedef struct{\n    CTBOX nodes[MAX_TREE_SIZE]; \t/*结点数组*/\n    int r,nl\t\t\t\t\t\t/*根的位置和结点数*/\n}CTree;\n```\n\n\n\n### 2.3孩子兄弟表示法\n\n任何一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。\n\n因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟\n\n| data | firstchild | rightsib |\n| :--: | :--------: | :------: |\n\ndata为数据域；firstchild为指针域，存储长子结点的存储地址；rightsib是指针域，存储该结点的右兄弟结点的存储地址；\n\n**将复杂的树变为二叉树**\n\n\n\n\n\n## 3.二叉树\n\n二叉树(Binary Tree)是n(n>=0)个结点的有限集合，该集合或者为空集(称为空二叉树),或者由一个根节点和两棵互不相交、分别称为根结点的左子树和右子树的二叉树组成\n\n\n\n### 3.1二叉树特点\n\n1. 每个结点最多有两棵子树\n2. 左子树和右子树是有顺序的\n3. 即使树中某结点只有一颗子树，也要区分它是左子树还是右子树\n\n\n\n### 3.2特殊二叉树\n\n1. 斜树\n\n   所有结点都只有左子树的二叉树叫左斜树，所有结点都只有右子树的二叉树叫右斜树\n\n2. 满二叉树\n\n   所有分支点都存在左子树和右子树，且所有叶子结点都在同一层\n\n3. 完全二叉树\n\n   对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置相同，称为完全二叉树\n\n\n\n\n\n### 3.3二叉树性质\n\n性质1：在二叉树的第i层最多有2<sup>i-1</sup>个结点(i>=1)\n\n性质2：深度为k的二叉树至多有2<sup>k</sup>-1个结点(k>=1)\n\n性质3：对任何一棵二叉树T，如果其终端节点为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub> = n<sub>2</sub> +1\n\n性质4：具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1\n\n性质5：如果一棵有n个结点的完全二叉树的结点按层序编号(从第1层到第[log<sub>2</sub>n]+1层，每层从左到右)，对任一结点i(1<=i<=n)有：\n\n1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[i/2]\n2. 如果2i>n，则结点无左孩子(结点i为叶子结点);否则其左孩子为结点2i\n3. 如果2i+1>n，则结点i无右孩子；否则其右孩子为结点2i+1\n\n\n\n\n\n## 4.二叉树的存储结构\n\n### 4.1顺序存储结构\n\n一般只用于完全二叉树\n\n\n\n### 4.2二叉链表\n\n二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域\n\n\n\n| lchild | data | rchild |\n| :----: | :--: | :----: |\n\n\n\n```c\n//二叉树的二叉链表结点结构定义\ntypedef struct BiTNode{\n    TElemType data;\t\t\t/*结点结构*/\n    struct BiTNode *lchild, *rchild;\t/*左右孩子指针*/\n}BiTNode, *BiTree\n```\n\n\n\n\n\n## 5.遍历二叉树\n\n**二叉树的遍历时指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次**\n\n\n\n两个关键词：**访问**和**次序**\n\n\n\n\n\n### 5.1前序遍历\n\n规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树\n\n\n\n算法\n\n```c\nvoid PreOrderTraverse(BiTree T){\n    if(T == NULL) return;\n    printf(\"%c\", T->data);\t\t\t/*显示结点数据，可改为其他操作*/\n    PreOrderTraverse(T -> lchild);\t/*先序遍历左子树*/\n    PreOrderTraverse(T -> rchild);\t/*先序遍历右子树*/\n}\n```\n\n\n\n\n\n### 5.2中序遍历\n\n规则是若二叉树为空，则空操作返回，否则从根结点开始(注意不是先访问根结点)，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树\n\n\n\n算法\n\n```C\nvoid InOrderTraverse(BiTree T){\n    if(T == NULL) return;\n    InOrderTraverse(T -> lchild);\t/*中序遍历左子树*/\n    printf(\"%c\", T->data);\t\t\t/*显示结点数据，可改为其他操作*/\n    InOrderTraverse(T -> rchild);\t/*中序遍历右子树*/\n}\n```\n\n\n\n### 5.3后序遍历\n\n规则是若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点\n\n\n\n算法\n\n```c\nvoid PostOrderTraverse(BiTree T){\n    if(T == NULL) return;\n    PostOrderTraverse(T -> lchild);\t/*后序遍历左子树*/\n    PostOrderTraverse(T -> rchild);\t/*后序遍历右子树*/\n    printf(\"%c\", T->data);\t\t\t/*显示结点数据，可改为其他操作*/\n}\n```\n\n\n\n### 5.4层次遍历\n\n规则是若二叉树为空，则空操作返回，否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问\n\n\n\n\n\n\n\n## 6.二叉树的建立\n\n普通二叉树\n\n{% mermaid %}\ngraph TD\n\tA((A)) --- B((B)) & C((C))\n    B ---X(( )) & D((D))\n    style X fill:#f100,stroke-width:0px\n    linkStyle 2 stroke:#off, stroke-width:0px;\n{% endmermaid %}\n\n扩展二叉树\n\n{% mermaid %}\ngraph TD\n\tA((A)) --- B((B)) & C((C))\n    B ---X1((#)) & D((D))\n    D ---X2((#)) & X3((#))\n    C ---X4((#)) & X5((#))\n    classDef X fill:#4169E1\n    class X1,X2,X3,X4,X5 X;\n{% endmermaid %}\n\n\n\n代码实现\n\n```c++\n//按前序输入二叉树中结点值（一个字符）\nvoid CreatBiTree(BiTree *T){\n    TElemType ch;\n    \n    cin >> ch;\n    \n    if(ch == \"#\") T = NULL;\n    else{\n        if(!T = new BiTNode) exit(OVERFLOW);\n       \t\n        T->data = ch;\t\t\t/*生成结点*/\n        CreatBiTree(T->lchild); /*构造左子树*/\n        CreatBiTree(T->rchild); /*构造右子树*/\n    }\n}\n```\n\n\n\n\n\n## 7.线索二叉树\n\n指针域未充分利用\n\n将指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树\n\n| lchild | ltag | data | rtag | rchild |\n| :----: | :--: | :--: | :--: | :----: |\n\n其中\n\n- ltag为0时指向该结点的左孩子，为1时指向该结点的前驱\n- rtag为0时指向该结点的右孩子，为1时指向该结点的后继\n\n\n\n代码实现\n\n```c\ntypedef enum {Link, Thread} PointTag; \t/*Link==0表示指向左右孩子指针*/\n\t\t\t\t\t\t\t\t\t\t/*Thread==1表示指向前驱或后继的线索*/\ntypedef struct BiThrNode{\n    TElemType data;\t\t\t\t\t\t/*结点数据*/\n    struct BiThrNode *lchild, *rchild;\t/*左右孩子指针*/\n    PointerTag LTag,RTagj;\t\t\t\t/*左右标志*/\n}BiThrNode, *BiThrTree;\n```\n\n线索化的过程就是在遍历的过程中修改空指针的过程\n\n中序遍历线索化的递归函数如下\n\n```c\nBiThrTree pre;\t\t\t\t\t/*全局变量，始终指向刚刚访问过的结点*/\nvoid InThreading(BiThrTree p){\n    if(p){\n        InThreading(p->lchild);\n        ///////////////////////\n        if(!p->lchild){\t\t\t/*没有左孩子*/\n            p—>LTag = Thread;\t/*前驱线索*/\n            p->lchild = pre;\t/*左孩子指针指向前驱*/\n        }\n        if(!pre->rchild){\t\t/*前驱没有右孩子*/\n            pre->RTag = Thread; /*后继线索*/\n            pre->rchild = p;\t/*前驱右孩子指针指向后继(当前结点p)*/\n        }\n        pre = p;\t\t\t\t/*保持pre指向p的前驱*/\n        ///////////////////////\n        InThreading(p->rchild);\n    }\n}\n```\n\n遍历代码如下\n\n```c\n//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点\nStatus InOrderTraverse_Thr(BiThrTree T){\n    BiThrTree p;\n    p = T->lchild;\n    while(p!=T){\t\t\t\t\t/*空树或者遍历结束时，p == T*/\n        while(p->LTag == Link)\tp = p->lchild;\n        cout << p->data;\t\t\t/*显示结点数据或其他操作*/\n        while(p->RTag == Thread && p->rchild != T){\n            p = p->rchild;\t\t\t/*访问后继结点*/\n            cout << p->data;\n        }\n        p = p->rchild;\t\t\t\t/*p进至其右子树根*/\n    }\t\t\t\t\t\n}\n```\n\n**如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉树链表的存储结构就是非常不错的选择**\n\n\n\n\n\n## 8.树、森林、二叉树的转换\n\n**树 --> 二叉树**：\n\n1.将所有兄弟结点间增加连线\n\n2.只保留和第一个孩子结点的连线，删除与其他孩子结点连线\n\n3.本身孩子结点为左孩子结点，兄弟结点为右孩子结点\n\n\n\n**森林 --> 二叉树**\n\n1.把每棵树转化为二叉树\n\n2.第一棵二叉树不懂，从第二棵二叉树开始依次将后一棵二叉树的根节点作为前一棵的根节点的右孩子\n\n\n\n## 9.哈夫曼树及其应用\n\n### 9.1哈夫曼树的定义及原理\n\n最基本的压缩编码方法-------哈夫曼编码\n\n\n\n带权路径长度WPL最小的二叉树称作哈夫曼树\n\n\n\n1. 先把有权值的叶子结点按照从小到大的顺序排列成有序序列，即A5,E10, B15, D30, C40\n2. 取头两个最小权值结点形成新结点N<sub>1</sub>，相对较小的为左孩子\n3. N<sub>1</sub>替换A、E，插入有序序列中重复2\n\n\n\n### 9.2哈夫曼编码\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 图\n\n## 1.图的定义及术语\n\n## 2.图的存储结构\n\n### 2.1邻接矩阵\n\n图的邻接矩阵存储方式是用两个数组来表示图。\n\n一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边的信息\n\n{% mermaid %}\ngraph TD\nV0 --- V1 & V2 & V3\nV2 --- V1 &  V3\n{% endmermaid %}\n\n顶点数组： \n\n|  V0  |  V1  |  V2  |  V3  |\n| :--: | :--: | :--: | :--: |\n\n邻接矩阵：\n\n|  0   |  1   |  1   |  1   |\n| :--: | :--: | :--: | :--: |\n|  1   |  0   |  1   |  0   |\n|  1   |  1   |  0   |  1   |\n|  1   |  0   |  1   |  0   |\n\n**邻接矩阵存储结构**\n\n```c\ntypedef struct{\n    VertexType vexs[MAXVEX];\t\t/*顶点表*/\n    EdgeType arc[MAXVEX][MAXVEX];\t/*邻接矩阵，可看作边表*/\n    int numNodes, numEdges;\t\t\t/*图中的定点数和边数*/\n}MGraph;\n```\n\n\n\n**无向网图创建代码**\n\n```c\nvoid CreatMGraph(MGraph *G){\n    int i, j, k, w;\n    cout << \"请输入顶点数和边数\";\n    cin >> G->numNodes >> G->numEdges;\t\t\t\t\t\t/*输入顶点数和边数*/\n    for(i = 0; i < G->numNodes; i++)\tcin >> G->vexs[i];\t/*读入顶点信息，建立顶点表*/\n    for(i = 0; i < G->numNodes; i++)\n        for(j = 0; j < G->numNodes; j++)\n            G->arc[i][j] = INFINITY;\t\t\t\t\t\t/*初始化邻接矩阵*/\n    for(k = 0; k < G->numEdges; k++){\n        cout << \"输入边(vi,vj)的下标i,j和权w：\\n\";\n        cin >> i >> j >> w;\n        G->arc[i][j] = w;\n        G->arc[j][i] = G->arc[i][j];\t\t\t\t\t\t/*无向图，所以矩阵对称*/\n    }\n}\n```\n\n\n\n\n\n### 2.2邻接表\n\n数组与链表相结合的存储方式称为邻接表\n\n1.用数组存储顶点\n\n| data | firstedge |\n| :--: | :-------: |\n\n2.用链表存储临界点\n\n| adjvex | next |\n| :----: | :--: |\n\n有向图中，邻接表可以算出度\n\n逆邻接表可以算入度\n\n```c\ntypedef struct EdgeNode{\t\t\t\t\t/*边表结点*/\n    int adjvex;\t\t\t\t\t\t\t\t/*邻接点域，存储该顶点对应下标*/\n    EdgeType info;\t\t\t\t\t\t\t/*用于存储权值，对非网图可以不要*/\n    struct EdgeNode *next;\t\t\t\t\t/*链域，指向下一个邻接点*/\n}EdgeNode；\n    \ntypedef struct VertexNode{\t\t\t\t\t/*顶点表结点*/\n    VertexType data;\t\t\t\t\t\t/*顶点域，存储顶点信息*/\n    EdgeNode *firstedge;\t\t\t\t\t/*边表头指针*/\n}VertexNode,AdjList[MAXVEX];\n\ntypedef struct{\n    AdjList adjlist;\n    int numNodes, numEdges;\t\t\t\t\t/*图中当前顶点数和边数*/\n}GraphAdjList;\n```\n\n**邻接表的创建**\n\n```c\n//建立图的邻接表结构\nvoid CreatALGraph(GraphAdjList *G){\n    int i, j, k;\n    EdgeNode *e;\n    cout << \"请输入顶点数和边数\";\n    cin >> G->numNodes >> G->numEdges;\n    for(i = 0; i < G->numNodes; i++){\t\t/*读入顶点信息，建立顶点表*/\n        cin >> G->adjList[i].data;\t\t\t/*输入顶点信息*/\n        G->adjList[i].firstedge = NULL;\t\t/*边表置为空表*/\n    }\n    \n    for(k = 0; k < G->numEdges; k++){\t\t/*读入顶点信息，建立边表*/\n        cout << \"输入边(vi,vj)上的顶点序号:\";\n        cin >> i >> j;\n        ////////////////////////////////////////////////////////////\n        e = new EdgeNode;\n        e->adjvex = j;\n        e->next = G->adjList[i].firstedge;\n        G->adjList[i].firstedge = e;\t\t/////头插法\n        e = new EdgeNode;\n        e->adjvex = i;\n        e->next = G->adjList[j].firstedge;\n        G->adjList[j].firstedge = e;\n        ////////////////////////////////////////////////////////////\n    }\n}\n```\n\n\n\n### 2.3十字链表\n\n将邻接表与逆邻接表结合起来\n\n顶点表结点结构如下\n\n| data | firstin | firstout |\n| :--: | :-----: | :------: |\n\n边表结点如下\n\n| tailvex | headvex | headlink | taillink |\n| :-----: | :-----: | :------: | :------: |\n\ntailvex：边起点在顶点表中下标\n\nheadvex：边终点在定点表中下标\n\nheadlink：入边表指针域，指向终点相同的下一条边\n\ntaillink：出边表指针域，指向起点相同的下一条边\n\n\n\n\n\n### 2.4邻接多重表\n\n\n\n### 2.5边集数组\n\n边集数组是由两个一维数组构成。\n\n一个存储顶点信息，一个存储边的信息\n\n顶点数组\n\n|  V0  |  V1  |  V2  |  V3  |  V4  |\n| :--: | :--: | :--: | :--: | :--: |\n\n边数组\n\n| begin | end  | weight |\n| :---: | :--: | :----: |\n\n\n\n\n\n## 3.图的遍历\n\n从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历\n\n**遍历实质**：图的邻接点\n\n\n\n### 3.1深度优先遍历\n\n深度优先遍历(Depth First Search) **DFS**\n\n**类似树的前序遍历**\n\n\n\n从图中某个顶点V出发，访问此顶点，然后从V的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到\n\n若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止\n\n```c\n//邻接矩阵的深度优先递归算法\nvoid DFS(MGraph G, int i){\n    int j;\n    visitet[i] = TRUE;\n    cout << G.vexs[i];\t\t\t\t\t\t\t/*访问顶点，也可做其他操作*/\n    for(j = 0; j < G.numVertexes; j++)\t\t\t\n        if(G.arc[i][j] == 1 && !visited[j])\t\t/*G.arc[i][j]为1代表邻接，visited[i] = 0代表未被访问*/\n            DFS(G, j);\t\t\t\t\t\t\t/*对未访问的顶点做递归调用*/\n}\n```\n\n用**邻接矩阵**表示图，遍历图中每个顶点都要从头扫描该顶点所在行，时间复杂度O(n<sup>2</sup>)\n\n------\n\n\n\n```c\n//邻接表的深度优先递归算法\nvoid DFS(GraphAdjList GL, int i){\n    EdgeNode *p;\n    visit[i] = TRUE;\n    cout << GL.adjList[i].data;\t\t\t\t\t/*打印顶点，也可做其他操作*/\n    p = GL->adjList[i].firstedge;\n    while(p){\n        if(!visited[p->adjvex])\n            DFS(GL, p->adjvex);\n        p = p->next;\n    }\n}\n```\n\n用**邻接表**来表示图，有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点，时间复杂度为O(n+e)\n\n\n\n\n\n### 3.2广度优先遍历\n\n广度优先遍历(Breadth First Search) **BFS**\n\n**类似树的层序遍历**\n\n```c\n//邻接矩阵的广度遍历\nvoid BFS(Graph G){\n    int i, j;\n    InitQueue(Q);\t\t\t\t\t\t\t\t/*辅助队列初始化,置空*/\n    for(i = 0; i < G.numVertexes; i++){\t\t\t/*对每个顶点做循环*/\n        if(!visited[i]){\t\t\t\t\t\t/*若是未被访问过就处理*/\n            visited[i] = TRUE;\t\t\t\t\t/*标记为已访问*/\n            cout << G.vexs[i];\t\t\t\t\t/*访问顶点*/\n            EnQueue(Q,i);\t\t\t\t\t\t/*当前顶点入队*/\n            while(!QueueEmpty(Q)){\t\t\t\t/*若当前队列不为空*/\n                DeQueue(Q,i);\t\t\t\t\t/*将队首元素出队列，赋值给i*/\n                for(j = 0; j < G.numVertexes; j++){\t\t\t\t\n                    if(G.arc[i][j] == 1 && !visited[j]){\t\t/*判断其他顶点，若与当前顶点存在边且未访问过*/\n                        visited[j] == TRUE;\t\t\t\t\t\t\n                        cout << G.vexs[j];\t\t\t\t\t\t/*访问顶点*/\n                        EnQueue(Q,j);\t\t\t\t\t\t\t/*将找到的顶点入队列*/\n                    }\n                }\n            }\n        }\n    }\n    \n}\n```\n\n\n\n```c\n//邻接表的广度遍历\nvoid BFS(GraphAdjList GL){\n    int i;\n    EdgeNode *p;\n    Queue Q;\n    InitQueue(Q);\n    for(i = 0; i < GL->numVertexes; i++){\n        if(!visited[i]){\n            visit[i] = TRUE;\n            cout << G.vexs[i];\t\t\t\t\t/*访问顶点*/\n            EnQueue(Q,i);\t\t\t\t\t\t/*当前顶点入队*/\n            while(!QueueEmpty(Q)){\n                DeQueue(Q,i);\n                p = GL->adjustList[i].firstedge;/*找到当前顶点的边表链的表头指针*/\n                while(p){\n                    if(!visited[p->adjvex]){\t/*若顶点未被访问*/\n                        visited[p->adjvex] = TRUE;\n                        cout << GL->adjList[p->adjvex].data;/*访问顶点*/\n                        EnQueue(Q,p->adjvex);   /*将此顶点入队列*/\n                    }\n                    p = p->next;\t\t\t\t/*指针指向下一个邻接点*/\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n## 4.最小生成树\n\n构造连通网的最小代价生成树称为最小生成树\n\n\n\n### 4.1Prim算法\n\n```c\n//Prim算法生成最小生成树\nvoid MiniSpanTress_Prim(MGraph G){\n    int min, i, j, k;\n    int adjvex[MAXVEX];\t\t\t\t\t\t/*邻接点下标*/\n    int lowcost[MAXVEX];\t\t\t\t\t/*保存权值*/\n    for(i = 1; i < G.numVertexes; i++){\n        lowcost[i] = G.arc[0][i];\t\t\t/*将V0顶点与其他所有点连接的权值存入数组*/\n        adjvex[i] = 0;\t\t\t\t\t\t/*初始化为V0下标*/\n    }\n    for(i = 1; i < G.numVertexes; i++){\n     \tmin = INFINITY;\t\t\t\t\t\t/*初始化最小权值为∞,可设为较大数字*/\n        j = 1; k = 0;\n        //找到最小权值边，并将最小权值边的邻接点存入k\n        while(j < G.numVertexes){\t\t\t\t\n            if(lowcost[j] != 0 && lowcost[j] < min){\n                min = lowcost[j];\n                k = j;\n            }\n        }\n        \n        cout << \"(\" + adjvex[k] + \",\" + k + \")\";\n        lowcost[k] = 0;\t\t\t\t\t\t/*当前点已完成任务*/\n        //将与k相接的边的权值更新至lowcost数组，并将其邻接点adjvex更新为k\n        for(j = 1; j < G.numVertexes; j++){\n            if(lowcost[j] != 0 && G.arc[k][j] < lowcost[j]){\n                lowcost[j] = G.arc[k][j];\n                adjvex[j] = k;\n            }\n        }\n    }\n}\n```\n\n\n\n### 4.2Kruskal算法\n\n```c\n//定义边集数组\ntypedef struct{\n    int begin;\n    int end;\n    int weight;\n}Edge;\n```\n\n```c\n//Kruskal算法生成最小生成树\nvoid MiniSpanTree_Kruskal(MGraph G){\n    int i, n, m;\n    Edge edges[MAXEDGE];\n    int parent[MAXEDGE];\t\t\t\t\t/*判断边是否形成回路*/\n    \n    /*省略按权值排序*/\n    \n    //初始化\n    for(i = 0; i < G.numVertexes; i++){\n        parent[i] = 0\n    }\n    \n    for(i = 0; i < G.numEdges; i++){\n        n = Find(parent, edges[i].begin);\n        m = Find(parent, edges[i].end);\n        if(n != m){\t\t\t\t\t\t\t/*m若与n不相等，即未形成环路*/\n            parent[n] = m;\t\t\t\t\t/*将此边的结尾顶点放入下标为起点的parent中，表示此顶点已在生成树集合中*/\n            printf(\"(%d, %d) %d\", edges[i].begin, edges[i].end, edges[i].weight)\n        }\n    }\n    //查找连接顶点的尾部下标\n    int Find(int *parent, int f){\n        while(parent[f] > 0){\n            f = parent[f];\n        }\n        return f;\n    }\n}\n```\n\n\n\n### 4.3比较\n\n|   算法名   |            Prim算法            |    Kruskal算法     |\n| :--------: | :----------------------------: | :----------------: |\n|  算法思想  |             选择点             |       选择边       |\n| 时间复杂度 | O(n<sup>2</sup>)     n为顶点数 | O(eloge)   e为边数 |\n|  适应范围  |             稠密图             |       稀疏图       |\n\n\n\n\n\n## 5.最短路径\n\n### 5.1Dijkstra算法\n\n数据结构\n\n```c\ntypedef struct{\n    int vexs[MAXVEX];\n    int arc[MAXVEX][MAXVEX];\n    int numVertexes, numEdges;\n}MGraph;\n\nint Patharc[MAXVEX];\t\t\t/*用于存储最短路径下标的数组*/\nint ShortPathTable[MAXVEX];\t\t/*用于存储到各点最短路径的权值和*/\n```\n\n算法代码\n\n```c\n//Dijkstra算法 求V0到其余顶点的最短路径P[v]及带权长度D[v]\nvoid ShorttestPath_Dijkstra(MGraph G, int v0, Pathace *P, ShortPathTable *D){\n    int v, w, k, min;\n    int final[MAXVEX];\t\t\t\t\t\t/*final[k] = 1 表示已求得*/\n    //初始化数据\n    for(v = 0; v < G.arc[v0][v]; v++){\n        final[v] = 0;\n        *D[v] = G.arc[v0][v];\n        *P[v] = -1;\n    }\n    *D[v0] = 0;\n    final[v0] = 1;\n    //开始主循环\n    for(v = 1; v < G.numVertexes; v++){\n        min = INFINITY;\n        //寻找距离v0最近的点\n        for(w = 0; w < G.numVertexes; w++){\n            if(!final[w] && *D[w] < min){\n                k = w;\n                min = *D[w];\n            }\n        }\n        final[k] = 1;\t\t\t\t\t\t/*将目前找到的顶点置1*/\n        //修正当前最短路径及距离\n        for(w = 0; w < G.numVertexes; w++){\n            //如果经过v顶点的路径比现在该路径长度短\n            if(!final[w] && (min + arc[k][w] < *G[w])){\n                *D[w] = min + arc[k][w];\t/*更新最小值*/\n                *P[w] = k;\t\t\t\t\t/*更新路径*/\n            }\n        }\n    }\n}\n```\n\n### 5.2Floyd算法\n\n算法实现\n\n```c\ntypedef int Patharc[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\n//Floyd算法，求G中各顶点V到其余顶点w的最短路径P[v][w]及带权长度D[v][w]\nvoid ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D){\n    int v, w, k;\n    //初始化D与P\n    for(v = 0; v < G.numVertexes; ++v){\n        for(w = 0; w < G.numVertexes; ++w){\n            *D[v][w] = G.arc[v][w];\n            *P[v][w] = w;\n        }\n    }\n    \n    for(k = 0; k < G.numVertexes; ++k){\n        for(v = 0; v < G.numVertexes; ++v){\n            for(w = 0; w < G.numVertexes; ++w){\n                //如果经过k顶点的路径比原两点路径短\n                if(*D[v][w] > *D[v][k] + *D[k][w]){\n                    *D[v][w] = *D[v][k] + *D[k][w];\n                    *P[v][w] = *P[v][k];\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n## 6.拓扑排序\n\n有向无环图\n\n**AOV网**\n\n以顶点表示活动，弧表示活动间优先制约关系\n\n\n\n**拓扑有序序列**\n\n在AOV网没有回路的前提下，将全部活动排列成一个线性序列，若从顶点V<sub>i</sub>到V<sub>j</sub>有一条路径，那么V<sub>i</sub>必在V<sub>j</sub>之前\n\n我们称这样的线性序列为**拓扑有序序列**\n\n**检测AOV中是否存在环**\n\n对有向图构造拓扑有序序列，若所有点都在拓扑有序序列中，则AOV网必不存在环\n\n\n\n## 7.关键路径\n\n**AOE网**\n\n以弧表示活动，以顶点表示活动的开始或者结束事件\n\n**关键路径**\n\n路径长度最长的路径\n\n### 7.1定义参数\n\n|     定义参数      |               作用                |\n| :---------------: | :-------------------------------: |\n| ve(V<sub>j</sub>) | 表示事件V<sub>j</sub>最早发生时间 |\n| vl(V<sub>j</sub>) | 表示事件V<sub>j</sub>最迟发生时间 |\n|       e(i)        |       表示活动i最早开始时间       |\n|       l(i)        |       表示活动i最晚开始时间       |\n\nl(i) - e(i) -----表示完成活动i的时间余量\n\n**关键活动** -----l(i) == e(i)\n\n\n\n**求关键路径步骤**\n\n1. 求ve(V<sub>j</sub>)、vl(V<sub>j</sub>)\n2. 求e(i)、l(i)\n3. 计算l(i) - e(i)\n\n\n\n\n\n# 查找\n\n## 1.查找概论\n\n**查找表(Search Table)**是由同一类型的数据元素构成的集合\n\n**关键字(Key)**是数据元素中的某个数据项的值\n\n若此关键字可以唯一地标记一个记录，则称此关键字为**主关键字(Primary Key)**\n\n对于可以识别多个数据元素的关键词，称为**次关键字(Secondary Key)**\n\n\n\n**查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素**\n\n\n\n**静态查找表**：只做查找操作的查找表\n\n1. 查询特定的数据元素是否在查找表中\n2. 检索特定的数据元素和各种属性\n\n\n\n**动态查找表**：在查找过程中同时插入表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素\n\n1. 查找时插入数据元素\n2. 查找时删除数据元素\n\n\n\n\n\n## 2.顺序表查找\n\n针对线性表进行查找操作，所以为静态查找表\n\n\n\n**顺序查找(Sequential Search)**又叫线性查找，是最基本的查找技术，查找过程如下：\n\n从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较\n\n若某个记录的关键字和给定值相等，则查找成功\n\n若直到最后一个（或者第一个）记录的关键字和给定值比较都不等时，查找失败\n\n\n\n实现算法如下\n\n```c\nint Sequential_Search(int *a, int n, int key){\n    int i;\n    for (i = 1; i <= n; i++){\n        if (a[i] == ket)\n            return i;\n    }\n    return 0;\n}\n```\n\n优化\n\n```c\n//有哨兵顺序查找\nint Sequential_Search2(int *a, int n, int key){\n    int i;\n    a[0] = key;\t\t\t\t\t/*设置a[0]为关键字值，称之为“哨兵”*/\n    i = n;\t\t\t\t\t\t/*循环从数组尾部开始*/\n\twhile (a[i] != key){\n        i--;\n    }\n    return i;\n}\n```\n\n\n\n## 3.有序表查找\n\n### 3.1二分查找\n\n**折半查找(Binary Search)**又称二分查找\n\n前提是线性表中记录必须是**关键码有序**（通常从小到大有序），线性表必须采用顺序存储\n\n\n\n```c\nint Binary_Search(int *a, int n, int key){\n    int low, high, mid;\n    low = 1;\n    high = n;\n    while (low <= high){\n        mid = (low + high) / 2;\n        if (key < a[mid])\n            high = mid - 1;\n        else if(key > a[mid])\n            low = mid + 1;\n        else \n            return mid;\n    }\n    return 0;\n}\n```\n\n\n\n**时间复杂度O(logn)**\n\n\n\n### 3.2插值查找\n\n将二分查找的代码做略微变换\n\n$$mid = \\frac{low + high}{2}$ =$low + \\frac{1}{2}(high - low)$$\n\n改为以下计算方案\n\n$$mid = low + \\frac{key - a[low]}{a[high] - a[low]}(high - low)$$\n\n\n\n\n\n### 3.3斐波那契查找\n\n\n\n```c\nint Fibonacci_Search(int *a, int n, int ket){\t\t/*F[n]为已经计算好的斐波那契数列*/\n    int low, high, mid, i, k;\n    low = 1;\n    high = n;\n    k = 0;\n    while (n > F[k] - 1)\t\t\t\t\t\t\t/*计算n位斐波那契数列的位置*/\n        k++;\t\t\t\t\t\t\t\t\t\t\t\n    for (i = n; i < F[K] - 1; i++)\t\t\t\t\t/*将数值补全*/\n        a[i] = a[n];\n    //查找开始\n    while (low <= high){\t\t\t\t\t\t\t\n        mid = low + F[K - 1] - 1;\t\t\t\t\t/*计算当前分隔下标*/\n        if (key < a[mid]){\n            high = mid - 1;\n            k = k - 1;\n        }\n        else if (key > a[mid]){\n            low = mid + 1;\n            k = k - 2;\n        }\n        else{\n            if (mid <= n)\n                return mid;\n            else\n                return n;\n        }\n    }\n    return 0;\n}\n```\n\n**时间复杂度O(logn)**\n\n### 3.4对比\n\n时间复杂度相同\n\n斐波那契查找只进行简单加减法运算$mid=low+F[k-1]-1$\n\n折半查找进行加法与除法运算$mid=\\frac{low+high}{2}$\n\n插值查找进行复杂四则运算$$mid = low + \\frac{key - a[low]}{a[high] - a[low]}(high - low)$$\n\n三种有序表的查找法本质上是分隔点选择不同，各有优劣\n\n\n\n\n\n## 4.线性索引查找\n\n索引就是把一个关键字与它对应的记录相关联的过程\n\n线性索引就是将索引项集合组织为线性结构，也称为**索引表**\n\n\n\n### 4.1稠密索引\n\n稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项\n\n对于稠密索引来说，**索引项一定是按照关键码有序排列的**\n\n意味着可以用到折半、插值、斐波那契等有序查找法\n\n\n\n### 4.2分块索引\n\n分块有序，是把数据集的记录分成了若干块，并且这些块需要满足一下两个条件\n\n1. 块内无序\n2. 块间有序\n\n我们定义的分块索引项结构分三个部分\n\n- 最大关键码\n- 存储块中记录个数\n- 用于指向块首数据元素的指针\n\n\n\n在分块索引表中查找就是进行以下两步\n\n1. 在分块索引表中查找要查关键字所在的块\n2. 根据块首指针找到相应的块，并在块中顺序查找关键码\n\n\n\n总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中\n\n\n\n### 4.3倒排索引\n\n索引项的通用结构是\n\n- 次关键码\n- 记录号表\n\n其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）\n\n\n\n## 5.二叉排序树\n\n**二叉排序树(Binary Sort Tree)**，又称为二叉查找树。它或者是一棵空树，或者是具有以下性质的二叉树\n\n- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值\n- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值\n- 它的左、右子树也分别为二叉排列树\n\n构造一棵二叉排序树的目的，不是为了排序，而是为了提高查找和插入删除关键字的速度\n\n\n\n### 5.1查找操作\n\n```c\n//二叉树的二叉链表的结点结构定义\ntypedef struct BiTNode{\n    int data;\n    struct BiTNode *lchild, *rchild;\n}BiTNode, *BiTree;\n```\n\n\n\n二叉排序树的查找\n\n```c\nStatus SearchBST(BiTree T, int key, BiTree f, BiTree *p){\n    //递归查找二叉排序树T中是否存在key\n    if (!T){\t\t\t\t\t\t\t\t/*若查找不成功，指针p指向查找路径上访问的最后一个结点并返回FALSE*/\n        *p = f;\n        return FALSE;\n    }\n    else if (key == T->data){\t\t\t\t/*若查找成功，则指针p指向该数据元素结点，并返回TRUE*/\n        *p = T;\n        return TRUE;\n    }\n    else if (key < T->data)\n        return SearchBST(T->lchild, key, T, p); /*在左子树中继续查找*/\n   \telse if (key > T->data)\n        return SearchBST(T->rchild, key, T, p); /*在右子树中继续查找*/\n}\n```\n\n\n\n### 5.2插入操作\n\n将关键字放到树中合适的位置\n\n```c\nStatus InsertBST(BiTree *T, int key){\n    BiTree p, s;\n    if (!SearchBST(*T, key, NULL, &p)){\t\t\t/*查找不成功*/\n        s = new BiTNode;\n        s->data = key;\n        s->lchild = s->rchild = NULL;\n        if (!p)\n            *T = s;\t\t\t\t\t\t\t\t/*插入s为新的根结点*/\n        else if (key < p->data;)\t\t\t\t\n            p->lchild = s;\t\t\t\t\t\t/*插入s为左孩子*/\n        else\n            p->rchild = s;\t\t\t\t\t\t/*插入s为右孩子*/\n        return TRUE;\n    }    \n    else \n        return FALSE;\t\t\t\t\t\t\t/*树中已有与关键字相同结点，不再插入*/\n}\n```\n\n\n\n### 5.3删除操作\n\n删除结点三种情况\n\n- 叶子结点\n- 仅有左子树或右子树结点\n- 左右子树都有的结点\n\n```c\n//查找关键字等于key的结点，找到则删除数据结点\nStatus DeleteBST(BiTree *T, int key){\n    if (!T)\n        return FLASE;\n    else{\n        if (key == T->data)\t\t\t\t\t\t/*找到关键字key的数据元素*/\n            return Delete(T);\n        else if (key < T->data)\n            return DeleteBST(T->lchild, key);\n        else \n            return DeleteBST(T->rchild, key);\n    }\n}\n```\n\n上述代码与二叉排序树查找几乎完全相同，区别在于找到后执行的是删除操作\n\n\n\n```C\nStatus Delete(BiTree *p){\n    //从二叉排序树中删除结点p，并重接他的左右子树\n    BiTree *q, *s;\n    if (p->rchild == NULL){\t\t\t\t\t\t/*右子树空则重接左子树(叶子也走此分支)*/\n        q = p;\n        p = p->lchild;\n        delete(q);\n    }\n    else if (p->lchild == NULL){\t\t\t\t/*左子树空则重接右子树*/\n        q = p;\n        p = p->rchild;\n        delete q;\n    }\n    else {\t\t\t\t\t\t\t\t\t\t/*左右均不空*/\n        q = p;\n        s = p->lchild;\n        while (s->rchild){\t\t\t\t\t\t/*找到左子树的右结点（找到待删结点的前驱）*/\n            q = s;\n            s = s->rchild;\n        }\t\t\t\t\t\n        p->data = s->data;\n        if (q != p)\n            q->rchild = s->lchild;\n        else\n            q->lchild = s->lchild;\n        delete s;\n    } \n}\n```\n\n\n\n## 6.平衡二叉树\n\n平衡二叉树是一种二叉排序树，其中每个结点的左子树和右子树高度差至多为1\n\n是一种高度平衡的二叉排序树，二叉树上节点的左子树高度减去右子树高度的值称为**平衡因子BF(Balance Factor)**\n\n那么平衡二叉树上所有结点的平衡因子只可能是1、0、-1\n\n距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为**最小不平衡树**\n\n\n\n{% mermaid %}\ngraph TD\n\n\tA1((A)) --- B1((B)) & D1(( ))\n\tB1 --- C1((C)) & E1(( ))\n\t%%style D fill:#f100,stroke-width:0px\n    %%style E fill:#f100,stroke-width:0px%% 设置F属性为填充为白色，边框宽度为0\n    linkStyle 1 stroke:#off, stroke-width:0px;\n    linkStyle 3 stroke:#off, stroke-width:0px;\n    \n    \n\tA2((A)) --- B2((B)) & D2(( ))\n\tB2 --- C2(( )) & E2((C))\n    linkStyle 5 stroke:#off, stroke-width:0px;\n    linkStyle 6 stroke:#off, stroke-width:0px;\n    \n    A3((A)) --- B3(( )) & D3((B))\n\tD3 --- C3((C)) & E3(( ))\n    linkStyle 8 stroke:#off, stroke-width:0px;\n    linkStyle 11 stroke:#off, stroke-width:0px;\n    \n    A4((A)) --- B4(( )) & D4((B))\n\tD4 --- C4(( )) & E4((C))\n    linkStyle 12 stroke:#off, stroke-width:0px;\n    linkStyle 14 stroke:#off, stroke-width:0px;\n    \n    class D1,E1,D2,C2,B3,E3,B4,C4 X;\n\tclassDef X fill:#f100, stroke-width:0px;\n{% endmermaid %}\n\n{% mermaid %}\ngraph TD\n\tA1((B)) --- B1((C)) & D1((A))\n\tA2((C)) --- B2((B)) & D2((A))\n\tA3((C)) --- B3((A)) & D3((B))\n\tA4((B)) --- B4((A)) & D4((C))\n{% endmermaid %}\n\n### 6.1代码实现\n\n**结点结构**\n\n增加一个变量`bf`用来存储平衡因子\n\n```c\ntypedef struct BiTNode;{\n    int data;\n    int bf;\n    struct BiTNode *lchild, *rchild;\n}BiTNode, *BiTree;\n```\n\n**右旋操作**\n\n```c\n//对P为根的二叉排序树作右旋处理\nvoid R_Rotate(BiTree *p){\n    BiTree *L;\n    L = p->lchild;\n    p->lchild = L->lchild;\n    L->rchild = p;\n    p = L;\n}\n```\n\n**左旋操作**\n\n```c\n//对P为根的二叉排序树作左旋处理\nvoid L_Rotate(BiTree *p){\n    BiTree *R;\n\tR = p->rchild;\n    p->rchild = R->lchild;\n    R->lchild = p;\n    p = L;\n}\n```\n\n**左平衡旋转**\n\n```c\n#define LH +1\t\t\t\t\t\t\t\t\t\t/*左高*/\n#define EH 0\t\t\t\t\t\t\t\t\t\t/*等高*/\n#define RH -1\t\t\t\t\t\t\t\t\t\t/*右高*/\n\nvoid LeftBalance(BiTree *T){\n    BiTree *L, *Lr;\n    L = T->lchild;\n    switch (L->bf){\t\t\t\t\t\t\t\t\t/*检查T的左子树平衡度，并做相应处理*/\n        case LH:\t\t\t\t\t\t\t\t\t/*（LL）新结点插入在T的左孩子的左子树上，要作单右旋处理*/\n            T->bf = L->bf =EH;\n            R_Rotate(T);\n            break;\n        case RH:\t\t\t\t\t\t\t\t\t/*新结点插入在T的左孩子的右子树上，要做双旋处理*/\n            Lr =L->rchild;\t\t\t\t\t\t\t/*Lr指向T的左孩子的右子树根*/\n            switch (Lr->bf){\t\t\t\t\t\t/*修改T及其左孩子的平衡因子*/\n                case LH:\n                    T->bf = RH;\n                    L->bf = EH;\n                 \tbreak;\n                case EH:\n                    T->bf = L->bf =EH;\n                \tbreak;\n                case RH:\n                    T->bf = EH;\n                    L->bf = LH;\n                    break;\n            }\n            Lr->bf =EH;\n            L_Rotate(T->lchild);\n            R_Rotate(T);\n    }\n}\n```\n\n**右平衡旋转**\n\n```c\nvoid RightBalance(BiTree *T){\n    BiTree *R, *Rl;\n    R = T->lchild;\n    switch (R->bf){\t\t\t\t\t\t\t\t\t/*检查T的右子树平衡度，并做相应处理*/\n        case RH:\t\t\t\t\t\t\t\t\t/*（RR）新结点插入在T的右孩子的右子树上，要作单左旋处理*/\n            T->bf = R->bf =EH;\n            L_Rotate(T);\n            break;\n        case LH:\t\t\t\t\t\t\t\t\t/*新结点插入在T的右孩子的左子树上，要做双旋处理*/\n            Rl =R->lchild;\t\t\t\t\t\t\t/*Rl指向T的右孩子的左子树根*/\n            switch (Rl->bf){\t\t\t\t\t\t/*修改T及其右孩子的平衡因子*/\n                case RH:\n                    T->bf = LH;\n                    R->bf = EH;\n                 \tbreak;\n                case EH:\n                    T->bf = R>bf =EH;\n                \tbreak;\n                case LH:\n                    T->bf = EH;\n                    R->bf = RH;\n                    break;\n            }\n            Rl->bf =EH;\n            R_Rotate(T->rchild);\n            L_Rotate(T);\n    }\n}\n```\n\n\n\n\n\n## 7.多路查找树（B树）\n\n**多路查找树（Muiltl-Way Search Tree）**，其每个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素\n\n\n\n设置一个结点数据元素上限set a cap on the num of items\n\n如果超出上限，就将其中一个元素给双亲结点if more than cap, give an item to parent\n\n**left-middle**\n\n再将超出上限的结点分成左右两个结点\n\n\n\n### 7.1 2-3树\n\n每个结点都有两个孩子或三个孩子\n\n一个2结点包含一个元素和两个孩子（或没有孩子）\n\n一个3结点包含一小一大两个元素和三个孩子（或没有孩子）\n\n\n\n\n\n### 7.2 2-3-4树\n\n一个4结点包含小中大3个元素和4个孩子（或没有孩子）\n\n\n\n### 7.3 B树\n\n**B树(B-tree)**是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例\n\n结点最大的孩子数目称为B树的阶\n\n\n\n### 7.4 B+树\n\n\n\n## 8.散列表（哈希表）\n\n### 8.1定义\n\n$存储位置 = f (关键字)$\n\n散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系$f$,使得每个关键字key对应一个存储位置$f(key)$\n\n对应关系$f$称为**散列函数**，又称**哈希(Hash)函数**\n\n采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为**散列表**或**哈希表(Hash Table)**\n\n\n\n散列技术既是一种存储方法，也是一种查找方法\n\n散列技术最适合的求解问题是查找与给定值相等的记录\n\n\n\n两个关键字$key_1 \\neq key_2$，但是却有$f(key_1) = f(key)_2$，这种现象我们称为**冲突(collision)**，并把$key_1$和$key_2$称为这个函数的同义词(synonym)\n\n\n\n### 8.2构造方法\n\n 原则\n\n1. 计算简单\n2. 散列地址分布均匀\n\n\n\n**1.直接定址法**\n\n去关键字的某个线性函数值为散列地址\n\n$f(key) = a * key + b$\n\n\n\n**2.数字分析法**\n\n\n\n**3.平方取中法**\n\n\n\n**4.折叠法**\n\n\n\n**5.除留余数法**\n\nf(key) = key  mod  p\n\n**6.随机数法**\n\n\n\n### 8.3处理散列冲突\n\n**1.开放定址法**\n\n开放定址法是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入\n\n公式是\n\n$f_i(key) = (f(key)+d_i) MOD m$  $d_i = 1, 2, 3, …, m-1$\n\n**线性探测法**\n\n本来就不为同义词却争夺同一地址的情况，称为**堆积**\n\n\n\n$f_i(key) = (f(key)+d_i) MOD m$  $d_i = 1^2, -1^, 2^2, -2^2,…,q^2, -q^2, q\\leq m/2$\n\n增加平方运算的目的是为了不让关键字都聚集在某一块区域，这种方法称为**二次探测法**\n\n\n\n\n\n**2.再散列函数法**\n\n对于散列表，实现准备多个散列函数\n\n$f_i(key) = RH_i(key)$\n\n\n\n这种方法可以使得关键字不产生聚集，相应增加了计算时间\n\n\n\n**3.链地址法**\n\n将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表\n\n在散列表中只存储所有同义词子表头指针，无论有多少冲突，都只是在当前位置给单链表增加节点的问题\n\n\n\n提供了不会出现找不到地址的保障，但查找时需要遍历单链表造成性能损耗\n\n\n\n**4.公共溢出区法**\n\n为所有冲突关键字建立一个公共溢出区来存放\n\n查找时，对给定值通过散列表计算出散列地址后，先于基本表的相应位置进行对比，相等则查找成功\n\n不相等，则到溢出表进行顺序查找\n\n\n\n相对于基本表而言，冲突数据较少的情况下，公共溢出区的结构对查找性能来说还是非常高的\n\n\n\n### 8.4散列表查找的实现\n\n```c\n#define SUCCESS 1\n#define UNSUCCESS 0\n#define HASHSIZE 12\n#define NULLKEY -32768\n\ntypedef struct{\n    int *elem;\t\t\t\t/*数据元素存储基址，动态分配数组*/\n    int count;\t\t\t\t/*当前数据元素个数*/\n}HashTable;\n\nint m = 0;\t\t\t\t\t/*散列表表长，全局变量*/\n```\n\n\n\n```c\n//初始化散列表\nStatus InitHashTable(HashTable *H){\n    int i;\n    m = HASHSIZE;\n    H->count = m;\n    H->elem = new int;\n    for (i = 0; i < m; i++){\n        H->elem[i] = NULLKEY；\n    }\n    return OK;\n}\n```\n\n\n\n```c\n//散列函数\nint Hash(int key){\n    return key % m;        /*除留余数法*/\n}\n```\n\n\n\n```c\n//插入关键字进散列表\nvoid InsertHash(HashTable *H, int key){\n    int addr = Hash(key);\t\t\t\t/*求散列地址*/\n    while (H->elem[addr] != NULLKEY){\t/*若不为空，则冲突*/\n        addr = (addr + 1) % m;\t\t\t/*开放定址法的线性探测*/\n    }\n    H->elem[addr] = key;\t\t\t\t/*直到有空位后插入关键字*/\n}\n```\n\n\n\n```c\n//散列表查找关键字\nStatus SearchHash(HashTable H, int key, int *addr){\n    *addr = Hash(key);\t\t\t\t\t/*求散列地址*/\n    while (H.elem[*addr] != key){\t\t\n        *addr = (*addr + 1) % m;\t\t/*开放定址法的线性探测*/\n        if (H.elem[*addr] == NULLKEY || *addr == Hash(key))\t\t/*若循环回到原点*/\n            return UNSUCCESS;\n    }\n    return SUCCESS;\n}\n```\n\n\n\n\n\n# 排序\n\n优秀排序算法的首要条件就是**速度**\n\n## 1.基本概念与分类\n\n**1.排序的稳定性**\n\n假设$k_i = k_j$，且在排序前的序列中$r_i$领先与$r_j$即（$i < j$）\n\n如果排序后$r_i$仍领先与$r_j$，则称所用的排序方法是稳定的；\n\n反之，若可能使得排序后的序列中$r_j$领先与$r_i$，则称所用的排序的方法是不稳定的\n\n\n\n**2.内排序与外排序**\n\n内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中\n\n外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行\n\n\n\n## 2.结构与函数\n\n```c\n#define MAXSIZE 1000\ntypedef struct{\n    int r[MAXSIZE + 1];\n    int length;\n}SqList;\n```\n\n\n\n```c\n//交换L中数组r的下标为i和j的值\nvoid swap(SqList *L, int i, int j){\n    int temp = L->r[i];\n    L->r[i] = L->r[j];\n    L->r[j]\t= temp;\n}\n```\n\n\n\n## 3.冒泡排序\n\n冒泡排序是一种交换排序，最基本的思想是两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止\n\n```c\n//对顺序表进行冒泡排序\nvoid BubbleSort(SqList *L){\n    int i,j;\n    for (i = 1; i < L->length; i++){\n        for (j = L->length - 1; j >= i; j--){\n            if (L->r[j - 1] > L->r[j])\n                swap(L, j-1, j);\n        }\n    }\n}\n```\n\n\n\n冒泡排序优化\n\n```c\n//改进\nvoid BubbleSort(SqList *L){\n    int i,j;\n    /////////\n    Status flag = TRUE;\n    /////////\n    for (i = 1; i < L->length && flag; i++){\n        flag = FALSE;\n        for (j = L->length - 1; j >= i; j--){\n            if (L->r[j - 1] > L->r[j]){\n                swap(L, j-1, j);\n                flag = TRUE;\n            } \n        }\n    }\n}\n```\n\n**总的时间复杂度为O($n^2$)**\n\n\n\n## 4.简单选择排序\n\n```c\n//对顺序表L作简单选择排序\nvoid SelectSort(SqList *L){\n    int i, j, min;\n    for (i = 1; i < L->length; i++){\n        min = i;\t\t\t\t\t\t\t\t/*当前下标定义为最小值*/\n        for (j = i + 1; j <= L->length; j++){\n            if (L->r[min] > L->r[j])\t\t\t/*如果有小于当前最小值的关键字，将此关键字下标赋值给min*/\n                min = j;\n        }\n        if (i != min)\t\t\t\t\t\t\t/*若min不等于i，说明找到最小值，交换*/\n            swap(L, i, min);\n    }\n}\n```\n\n**时间复杂度为O($n^2$)**\n\n性能上略优于冒泡排序\n\n\n\n## 5.直接插入排序\n\n直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表\n\n```c\n//对顺序表L作直接插入排序\nvoid InsertSort(SqList *L){\n    int i, j;\n    for (i = 2; i <= L->length; i++){\n        if (L->r[i] < L->r[i - 1]){\t\t\t\t/*将L->r[i]插入有序子表*/\n            L->r[0] = L->r[i];\t\t\t\t\t/*设置哨兵*/\n            for (j = i - 1; L->r[j] > L->r[0]; j--)\n                L->r[j + 1] = L->r[j];\t\t\t/*记录后移*/\n            L->r[j + 1] = L->r[0];\t\t\t\t/*插入到正确位置*/\n        }\n    }\n}\n```\n\n**时间复杂度为O($n^2$)**\n\n性能上略优于冒泡排序和简单选择排序\n\n\n\n## 6.希尔排序\n\n(shell Sort)\n\n**基本有序**：小的关键字基本在前面，大的基本在后面，不大不小的基本在中间\n\n将相距某个”增量“的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序\n\n\n\n```c\n//希尔排序算法\nvoid ShellSort(SqList *L){\n    int i, j, k = 0;\n    int increment = L->length;\n    do{\n        increment = increment/3 + 1;\t\t\t\t\t/*增量序列*/\n        for (i = increment + 1; i <= L->length){\n            if (L->r[i] < L->r[i - increment]){\t\t\t/*需将L->[i]插入有序增量子表*/\n                L->r[0] = L->r[i];\t\t\t\t\t\t/*暂存在L->r[0]*/\n                for (j = i - increment; j > 0 && L->r[0] < L->r[j]; j -= increment)\n                    L->r[j + increment] = L->r[j];\t\t/*记录后移，查找插入位置*/\n                L->r[j + increment] = L->r[0];\t\t\t/*插入*/\n            }\n        }\n    }while (increment > 1);\n}\n```\n\n**增量序列最后一个增量值必须等于1**\n\n时间复杂度O($n^\\frac{3}{2}$)\n\n\n\n## 7.堆排序\n\n堆是具有下列性质的二叉树：\n\n- 每个结点的值都大于或等于其左右孩子结点的值，称为**大顶堆**\n- 或者每个结点的值都小于或等于其左右孩子结点的值，称为**小顶堆**\n\n\n\n```c\n//对顺序表L进行堆排序\nvoid HeapSort(SqList *L){\n    int i;\n    for (i = L->length/2; i > 0; i--)\t\t\t\t\t/*构造大顶堆*/\n        HeapAdjust(L, i, L->length);\n    for (i = L->length; i > 1; i--){\t\t\t\t\t\n        swap(L, 1, i);\t\t\t\t\t\t\t\t\t/*将堆顶记录和当前未经排序子序列最后一记录交换*/\n        HeapAdjust(L, 1, i - 1);\t\t\t\t\t\t/*将L->r[1..i - 1]重新调整为大顶堆*/\n    }\n}\n```\n\n\n\n```c\n//堆调整\nvoid HeapAdjust(SqList *L, int s, int m){\n    int temp, j;\n    temp = L->r[s];\n    for (j = 2 * s; j <= m; j *= 2){\t\t\t\t\t/*沿关键字较大的孩子结点向下筛选*/\n        if (j < m && L->r[j] < L->r[j + 1])\n            ++j;\t\t\t\t\t\t\t\t\t\t/*j为关键字中较大的记录的下标*/\n        if (temp >= L->r[j])\n            break;\t\t\t\t\t\t\t\t\t\t/*rc应插入在位置s上*/\n        L->r[s] = L->r[j];\n        s = j;\n    }\n    L->r[s] = temp;\t\t\t\t\t\t\t\t\t\t/*插入*/\n}\n```\n\n\n\n```c\n//排序\nfor (i = L->lenth; i > 1; i--){\n    swap(L, 1, i);\n    HeapAdjust(L, 1, i - 1);\n}\n```\n\n\n\n**时间复杂度O(nlogn)**\n\n记录的比较是跳跃式进行，所以堆排序是一种不稳定的排序方法\n\n初始构建堆所需要的次数较多，不适合待排序序列个数较少情况\n\n\n\n## 8.归并排序\n\n**归并排序（Merging Sort）**\n\n```c\n//对顺序表L作归并排序\nvoid MergeSort(SqList *L){\n    Msort(L->r, L->r, 1, L->length);\n}\n```\n\n\n\n```c\nvoid MSort(int SR[], int TR1[], int s, int t){\n    int m;\n    int TR2[MAXSIZE + 1];\n    if (s == t){\n        TR1[s] = SR[s];\n    }\n    else{\t\n        m = (s + t) / 2;\t\t\t\t\t/*将SR[s..t]平分为SR[s..m]和s[m+1..t]*/\n        MSort(SR, TR2, s, m);\t\t\t\t/*将SR[s..m]归并为有序序列TR2[s..m]*/\n        MSort(SR, TR2, m + 1, t);\t\t\t/*将SR[m+1..t]归并为有序序列TR2[m+1..t]*/\n        Merge(SR, TR2, s, m, t);\t\t\t/*将TR2[s..m]和TR2[m+1..t]归并到TR1[s..m]*/\n    }\n}\n```\n\n\n\n```c\n//将SR[s..m]和SR[m+1..t]归并到TR[s..m]\nvoid Merge(int SR[], int TR[], int i, int m, int n){\n    int j, k, l;\n    for (j = m + 1, k = i; i <= m && j <= n; k++){\t\t\t/*将SR中记录由小到大并入TR*/\n        if (SR[i] < SR[J])\n            TR[k] = SR[i++];\n        else\n            TR[k] = SR[j++];\n        if (i <= m){\n            for (l = 0; l <= m - i; l++)\n                TR[k + l] = SR[i + l];\t\t\t\t\t\t/*将剩余SR[i..m]复制到TR*/\n        }\n        if (j <= n){\n            for (l = 0; l <= n - j; l++)\n                TR[k + l] = SR[j + l];\t\t\t\t\t\t/*将剩余SR[j..n]复制到TR*/\n        }\n    }\n}\n```\n\n**时间复杂度O(nlogn)**\n\n归并排序是一种稳定的排序算法，比较占用内存，但效率高且稳定\n\n\n\n## 9.快速排序\n\n**快速排序（Quick Sort）**的基本思想是：通过一趟排序将待排记录分割成独立的两部分\n\n其中一部分记录的关键字比另一部分小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的\n\n\n\n```c\n//对顺序表L作快速排序\nvoid QuickSort(SqList *L){\n    QSort(L, 1, L->length);\n}\n```\n\n\n\n```c\n//对顺序表L中子序列L->r[low..high]作快速排序\nvoid QSort(SqList *L, int low, int high){\n    int pivot;\n    if (low < high){\n        //将L->r[low..high]一分为二，算出枢轴值pivot\n        pivot = Partition(L, low, high);\n        QSort(L, low, pivot - 1);\t\t\t/*对低子表递归排序*/\n        QSort(L, pivot + 1, high);\t\t\t/*对高子表递归排序*/\n    }\n}\n```\n\nPatition（）要做的，就是选取当中一个关键字，想尽办法将它放到一个位置\n\n使得它左边的值都比它小，右边的值都比它大，这样的关键词称为枢轴(Pivot)\n\n\n\n```c\nint Patition(SqList *L, int low, int high){\n    int pivotkey;\n    pivotkey = L->r[low];\t\t\t\t/*用子表的第一个记录作枢轴记录*/\n    while (low < high){\t\t\t\t\t/*从表的两端交替地向中间扫描*/\n        while (low < high && L->r[low] >= pivotkey)\n            high--;\n        swap(L, low, high);\t\t\t\t/*将比枢轴记录小的记录交换到低端*/\n        \n        while (low < high && L->r[low] <= pivotkey)\n            low++;\n        swap(L, low, high);\n    }\n    return low;\t\t\t\t\t\t\t/*返回枢轴所在位置*/\n}\n```\n\n**时间复杂度O($n^2$)**\n\n由于关键字比较和交换是跳跃进行，因此快速排序是一种不稳定排序\n\n\n\n#### **快速排序优化**\n\n##### 1.优化选取枢轴\n\n- 固定选取（原）\n- 随机选取\n- 三数取中\n\n```c\nint pivotkey;\n\nint m = low + (high - low) / 2;\nif (L->r[low] > L ->r[high])\n    swap(L, low, high);\nif (L->r[m] > L ->r[high])\n    swap(L, m, high);\nif (L->r[low] > L ->r[m])\n    swap(L, low, high);\n//此时，r[low]已经为整个序列左、中、右三个关键字的中间值\n\npivokey = L->r[low];\n```\n\n- 九数取中\n\n\n\n##### 2.优化不必要的交换\n\n==``L->r[0] = pivotkey``==\n\n采用替换而不是交换的方式进行操作\n\nL->r[low] = L->r[high]\n\n```c\nint Patition(SqList *L, int low, int high){\n    int pivotkey;\n    pivotkey = L->r[low];\t\t\t\t/*用子表的第一个记录作枢轴记录*/\n    L->r[0] = pivotkey\n    while (low < high){\t\t\t\t\t/*从表的两端交替地向中间扫描*/\n        while (low < high && L->r[low] >= pivotkey)\n            high--;\n        L->r[low] = L->r[high]\t\t\t/*采用替换而不是交换的方式进行操作*/\n        \n        while (low < high && L->r[low] <= pivotkey)\n            low++;\n        L->r[high] = L->r[low]\n    }\n    L->r[low] = L->r[0]\n    return low;\t\t\t\t\t\t\t/*返回枢轴所在位置*/\n}\n```\n\n##### 3.优化小数组时的排序方案\n\n```c\n#define MAX_LENGTH_INSERT_SORT 7\nvoid QSort(SqList *L, int low, int high){\n    int pivot;\n    if ((high - low) > MAX_LENGTH_INSERT_SORT){\n        ......\t\t\t\t\t\t\t/*采用快速排序*/\n    }\n    else\n        InsertSort(L);\t\t\t\t\t/*直接用插入排序*/\n}\n```\n\n\n\n##### 4.优化递归操作\n\n\n\n\n\n## 10.总结对比\n\n|   排序方法   |        平均情况        |      最好情况      |   最坏情况    |     辅助空间      | 稳定性 |\n| :----------: | :--------------------: | :----------------: | :-----------: | :---------------: | :----: |\n|   冒泡排序   |        O($n^2$)        |       O($n$)       |   O($n^2$)    |       O(1)        |  稳定  |\n| 简单选择排序 |        O($n^2$)        |      O($n^2$)      |   O($n^2$)    |       O(1)        |  稳定  |\n| 直接插入排序 |        O($n^2$)        |       O($n)$       |   O($n^2$)    |       O(1)        |  稳定  |\n|   希尔排序   | O($n\\log{n}$)~O($n^2$) | O($n^\\frac{3}{2}$) |   O($n^2$)    |       O(1)        | 不稳定 |\n|    堆排序    |     O($n\\log{n}$)      |   O($n\\log{n}$)    | O($n\\log{n}$) |       O(1)        | 不稳定 |\n|   归并排序   |     O($n\\log{n}$)      |   O($n\\log{n}$)    | O($n\\log{n}$) |       O(n)        |  稳定  |\n|   快速排序   |     O($n\\log{n}$)      |   O($n\\log{n}$)    |   O($n^2$)    | O($\\log{n}$)~O(1) | 不稳定 |\n\n\n\n- 简单算法：冒泡、简单选择、直接插入\n- 改进算法：希尔、堆、归并、快速\n\n\n\n从**平均情况**看，最后三种改进算法胜过希尔排序，并远胜于3钟简单算法\n\n从**最好情况**看，冒泡和直接插入排序更胜一筹。如果待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法\n\n从**最坏情况**看，堆排序与归并排序强于快速排序及其他简单排序\n\n从**稳定性**看，归并排序独占鳌头，对非常在乎排序稳定性的应用中，归并排序是个好算法\n\n从**待排序记录的个数**上看，待排序的个数越小，采用简单排序方法就越合适\n","slug":"datastructure","published":1,"updated":"2023-08-18T13:51:02.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllhr6jik000keqjg2urrc1tx","content":"<h1 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h1><h2 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h2><h3 id=\"1-数据\"><a href=\"#1-数据\" class=\"headerlink\" title=\"1.数据\"></a>1.数据</h3><p>能输入计算机且能被计算机处理的各种符号的集合</p>\n<p>1）数值型数据：整数、实数等</p>\n<p>2）非数值型数据：文字、图像、声音等</p>\n<h3 id=\"2-数据元素\"><a href=\"#2-数据元素\" class=\"headerlink\" title=\"2.数据元素\"></a>2.数据元素</h3><p>数据的基本单位</p>\n<p>也称为元素、记录或结点</p>\n<p>例：  学号    姓名     专业      性别</p>\n<p>​           123    张三     电子      男</p>\n<h3 id=\"3-数据项\"><a href=\"#3-数据项\" class=\"headerlink\" title=\"3.数据项\"></a>3.数据项</h3><p>构成数据元素的不可分割的最小单位</p>\n<p>例：学号</p>\n<h3 id=\"三者关系\"><a href=\"#三者关系\" class=\"headerlink\" title=\"三者关系\"></a>三者关系</h3><p>数据&gt;数据元素&gt;数据项</p>\n<h3 id=\"4-数据对象\"><a href=\"#4-数据对象\" class=\"headerlink\" title=\"4.数据对象\"></a>4.数据对象</h3><p>性质相同的数据元素的集合，是数据的一个子集</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"**数据结构\"></a>**数据结构</h2><p>数据元素相互之间的关系称为结构</p>\n<h3 id=\"1-逻辑结构\"><a href=\"#1-逻辑结构\" class=\"headerlink\" title=\"1.逻辑结构\"></a>1.逻辑结构</h3><h4 id=\"1-集合结构\"><a href=\"#1-集合结构\" class=\"headerlink\" title=\"1.集合结构\"></a>1.集合结构</h4><h4 id=\"2-线性结构\"><a href=\"#2-线性结构\" class=\"headerlink\" title=\"2.线性结构\"></a>2.线性结构</h4><h4 id=\"3-树形结构\"><a href=\"#3-树形结构\" class=\"headerlink\" title=\"3.树形结构\"></a>3.树形结构</h4><h4 id=\"4-图形结构\"><a href=\"#4-图形结构\" class=\"headerlink\" title=\"4.图形结构\"></a>4.图形结构</h4><h3 id=\"2-物理结构或存储结构\"><a href=\"#2-物理结构或存储结构\" class=\"headerlink\" title=\"2.物理结构或存储结构\"></a>2.物理结构或存储结构</h3><p>数据元素及其关系在计算机内存中的表示</p>\n<h4 id=\"1-顺序存储结构\"><a href=\"#1-顺序存储结构\" class=\"headerlink\" title=\"1.顺序存储结构\"></a>1.顺序存储结构</h4><h4 id=\"2-链式存储结构\"><a href=\"#2-链式存储结构\" class=\"headerlink\" title=\"2.链式存储结构\"></a>2.链式存储结构</h4><hr>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"1-时间复杂度\"><a href=\"#1-时间复杂度\" class=\"headerlink\" title=\"1.时间复杂度\"></a>1.时间复杂度</h3><p>&#x3D;&#x3D;O(1) &lt; O(log n) &lt; O(n) &lt; O(n*log n) &lt; O(n²) &lt; O(n³) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)&#x3D;&#x3D;</p>\n<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><p>零个或者多个数据元素的有限序列</p>\n<p>线性表中，一个数据元素可以由若干个数据项组成</p>\n<h2 id=\"1-顺序存储结构-1\"><a href=\"#1-顺序存储结构-1\" class=\"headerlink\" title=\"1.顺序存储结构\"></a>1.顺序存储结构</h2><h3 id=\"1-顺序存储定义\"><a href=\"#1-顺序存储定义\" class=\"headerlink\" title=\"1.顺序存储定义\"></a>1.顺序存储定义</h3><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表数据的元素。</p>\n<h3 id=\"2-顺序存储方式\"><a href=\"#2-顺序存储方式\" class=\"headerlink\" title=\"2.顺序存储方式\"></a>2.顺序存储方式</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType data[MAXSIZE];</span><br><span class=\"line\">\t<span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;Sqlist;</span><br></pre></td></tr></table></figure>\n\n<p>需要三个属性：  1.存储空间的起始位置 ： 数据data ,他的存储位置就是存储空间的存储位置</p>\n<p>​\t\t\t\t\t\t\t 2.线性表的最大存储容量：数组长度MAXSIZE</p>\n<p>​\t\t\t\t\t\t\t 3.线性表的当前长度：length</p>\n<h3 id=\"3-线性表顺序存储结构的优缺点\"><a href=\"#3-线性表顺序存储结构的优缺点\" class=\"headerlink\" title=\"3.线性表顺序存储结构的优缺点\"></a>3.线性表顺序存储结构的优缺点</h3><p>优点：无需为表中元素之间的逻辑关系而增加额外的存储空间</p>\n<p>​\t\t\t可以快速地存取表中的任一位置的元素</p>\n<p>缺点：插入和删除操作需要移动大量元素</p>\n<p>​\t\t    当线性表长度变化较大时，难以确定存储空间的容量</p>\n<p>​\t\t\t造成存储空间的“碎片”</p>\n<h2 id=\"2-链式存储结构-1\"><a href=\"#2-链式存储结构-1\" class=\"headerlink\" title=\"2.链式存储结构\"></a>2.链式存储结构</h2><h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h3><p>n个结点（a<sub>i</sub>的存储映像）链结成一个链表，即为线性表（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>）的链式存储结构</p>\n<p><strong>a<sub>i</sub>的存储映像</strong>：1.数据域 </p>\n<p>​\t\t\t\t\t\t   2.指针域</p>\n<p><strong>头指针</strong>：链表中第一个结点的存储位置</p>\n<p><del>最后一个结点指向空结点NULL</del></p>\n<h3 id=\"2-头指针、头结点的异同\"><a href=\"#2-头指针、头结点的异同\" class=\"headerlink\" title=\"2.头指针、头结点的异同\"></a>2.头指针、头结点的异同</h3><p><strong>头指针</strong>：1.头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</p>\n<p>​\t\t\t\t2.头指针具有标志作用，所以常用头指针冠以链表的名字</p>\n<p>​\t\t\t\t3.无论链表是否为空，头指针均不为空。头指针是链表的必要元素</p>\n<p><strong>头结点</strong>：1.头结点是为了操作的统一和方标而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</p>\n<p>​\t\t\t\t2.有了头结点，对在第一元素结点之前插入结点和删除第一节点，其操作与其他结点的操作就统一了</p>\n<p>​\t\t\t\t3.头节点不一定就是链表的必需要素</p>\n<h3 id=\"3-链表存储方式\"><a href=\"#3-链表存储方式\" class=\"headerlink\" title=\"3.链表存储方式\"></a>3.链表存储方式</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*线性表的单链表存储结构*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Node;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">LinkList</span>;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p> 对于插入或者删除数据越频繁的操作，单链表的效率优势就越明显 </p>\n<h3 id=\"4-单链表结构与顺序存储结构的优缺点\"><a href=\"#4-单链表结构与顺序存储结构的优缺点\" class=\"headerlink\" title=\"4.单链表结构与顺序存储结构的优缺点\"></a>4.单链表结构与顺序存储结构的优缺点</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>顺序存储方式</th>\n<th>单链表结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储分配方式</td>\n<td>用一段连续存储单元依次存储线性表的数据元素</td>\n<td>采用链式存储结构，用一组任意的存储单元存放线性表的元素</td>\n</tr>\n<tr>\n<td>时间性能</td>\n<td>查找：O（1）</td>\n<td>查找：O（n）</td>\n</tr>\n<tr>\n<td></td>\n<td>插入和删除：O（n）</td>\n<td>插入和删除：O（1）</td>\n</tr>\n<tr>\n<td>空间性能</td>\n<td>需要预分配存储空间</td>\n<td>不需要分配存储空间</td>\n</tr>\n</tbody></table>\n<p><strong>线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构</strong></p>\n<p><strong>线性表中的元素个数变化较大或者不知道有多大时，最好用单链表结构</strong></p>\n<h3 id=\"5-循环链表\"><a href=\"#5-循环链表\" class=\"headerlink\" title=\"5.循环链表\"></a>5.循环链表</h3><h3 id=\"6-双向链表\"><a href=\"#6-双向链表\" class=\"headerlink\" title=\"6.双向链表\"></a>6.双向链表</h3><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱节点的指针域</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n A((线性表)) --- B1 &amp; C1\n B1(顺序存储结构)\n C1(链式存储结构) --- D1(单链表) &amp; D2(静态链表) &amp; D3(循环链表) &amp; D4(双向链表)\n  </pre></div>\n\n\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h4 id=\"1-栈的定义\"><a href=\"#1-栈的定义\" class=\"headerlink\" title=\"1.栈的定义\"></a>1.栈的定义</h4><p><strong>栈(stack)是限定仅在表尾进行插入和删除操作的线性表</strong></p>\n<p>允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。</p>\n<p>栈又称为后进后出(Last In First Out)的线性表，简称LIFO结构</p>\n<h4 id=\"2-栈的顺序存储结构及实现\"><a href=\"#2-栈的顺序存储结构及实现\" class=\"headerlink\" title=\"2.栈的顺序存储结构及实现\"></a>2.栈的顺序存储结构及实现</h4><p>顺序栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType data[MAXSIZE]；</span><br><span class=\"line\">\t<span class=\"type\">int</span> top;   <span class=\"comment\">/* 用于栈顶指针*/</span></span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-两栈共享空间\"><a href=\"#3-两栈共享空间\" class=\"headerlink\" title=\"3.两栈共享空间\"></a>3.两栈共享空间</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType data[MAXSIZE]；</span><br><span class=\"line\">\t<span class=\"type\">int</span> top1;   <span class=\"comment\">/* 用于栈1栈顶指针*/</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> top2;   <span class=\"comment\">/* 用于栈2栈顶指针*/</span></span><br><span class=\"line\">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用这样的数据结构通常是两个栈的空间需求有相反关系，比如股票，买入时，一定是有人在卖出</p>\n<p>如果是不相同数据类型的栈，这种方法不但不能更好的处理问题，反而会使问题变得更复杂。</p>\n<h4 id=\"4-栈的链式存储结构及实现\"><a href=\"#4-栈的链式存储结构及实现\" class=\"headerlink\" title=\"4.栈的链式存储结构及实现\"></a>4.栈的链式存储结构及实现</h4><p>链栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span>&#123;</span></span><br><span class=\"line\">\tSElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;StackNode, *LinkStackPtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tLinkStackPtr top;</span><br><span class=\"line\">\t<span class=\"type\">int</span> count;</span><br><span class=\"line\">&#125;LinkStack;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-栈的应用\"><a href=\"#5-栈的应用\" class=\"headerlink\" title=\"5.栈的应用\"></a>5.栈的应用</h4><h5 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1.递归\"></a>1.递归</h5><h6 id=\"1-递归的定义\"><a href=\"#1-递归的定义\" class=\"headerlink\" title=\"1.递归的定义\"></a>1.递归的定义</h6><p>一个直接调用自己或者通过一系列的调用语句间接调用自己的函数</p>\n<p>每个递归定义必须至少又一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>\n<p>简单地说，在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。</p>\n<p>在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是回复了调用的状态</p>\n<h5 id=\"2-四则运算\"><a href=\"#2-四则运算\" class=\"headerlink\" title=\"2.四则运算\"></a>2.四则运算</h5><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"1-队列的定义\"><a href=\"#1-队列的定义\" class=\"headerlink\" title=\"1.队列的定义\"></a>1.队列的定义</h3><p>队列(queue)是只允许在一段进行插入操作，而在另一端进行删除操作的线性表</p>\n<p>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一段为队尾，允许删除的一端称为队头</p>\n<h3 id=\"2-队列顺序存储\"><a href=\"#2-队列顺序存储\" class=\"headerlink\" title=\"2.队列顺序存储\"></a>2.队列顺序存储</h3><p>问题：“假溢出”</p>\n<p>解决办法：循环队列</p>\n<p><strong>队列头尾相连的顺序存储结构称为循环队列</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tQElemType data[MAXSIZE];</span><br><span class=\"line\">\t<span class=\"type\">int</span> front;\t\t\t\t<span class=\"comment\">/*头指针*/</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> rear;\t\t\t\t<span class=\"comment\">/*尾指针，若队列不空，指向队列尾元素的下一个位置*/</span></span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-队列链式存储\"><a href=\"#3-队列链式存储\" class=\"headerlink\" title=\"3.队列链式存储\"></a>3.队列链式存储</h3><p>队列的链式存储，就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span>&#123;</span>     <span class=\"comment\">/*结点结构*/</span></span><br><span class=\"line\">    QElemtype data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>           <span class=\"comment\">/*队列链表结构*/</span></span><br><span class=\"line\">    QueuePtr front, rear; <span class=\"comment\">/*队头、队尾指针*/</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h1><h2 id=\"1-串的定义\"><a href=\"#1-串的定义\" class=\"headerlink\" title=\"1.串的定义\"></a>1.串的定义</h2><p>串(string)是由零个或多个字符组成的有限序列，又叫字符串</p>\n<h2 id=\"2-串的存储结构\"><a href=\"#2-串的存储结构\" class=\"headerlink\" title=\"2.串的存储结构\"></a>2.串的存储结构</h2><h3 id=\"2-1顺序存储结构\"><a href=\"#2-1顺序存储结构\" class=\"headerlink\" title=\"2.1顺序存储结构\"></a>2.1顺序存储结构</h3><h3 id=\"2-2链式存储结构\"><a href=\"#2-2链式存储结构\" class=\"headerlink\" title=\"2.2链式存储结构\"></a>2.2链式存储结构</h3><p>总的来说不如顺序存储灵活，也不如顺序存储结构好</p>\n<h2 id=\"3-模式匹配算法\"><a href=\"#3-模式匹配算法\" class=\"headerlink\" title=\"3.模式匹配算法\"></a>3.模式匹配算法</h2><p><strong>字串的定位操作通常称做串的模式匹配</strong></p>\n<p>n为主串长度、m为要匹配的子串长度</p>\n<p>最好情况：一开始就匹配成功，比如”googlegood”中找”google”，时间复杂度为O(m)</p>\n<p>稍差一些：每次首字母不匹配，比如”abcdefgoogle”中找”google”，时间复杂度为O(n+m)</p>\n<p>最坏情况：每次匹配不成功都发生在最后一个位置，比如”0000000000000000000000000001”中找”0000001”，时间复杂度为O((n-m+1)*m)</p>\n<p><strong>低效</strong></p>\n<h4 id=\"3-1-KMP模式匹配算法\"><a href=\"#3-1-KMP模式匹配算法\" class=\"headerlink\" title=\"3.1 KMP模式匹配算法\"></a>3.1 KMP模式匹配算法</h4><p>思想：</p>\n<p>代码实现：1.初始化</p>\n<p>​\t\t\t\t\t2.前后缀相同情况</p>\n<p>​\t\t\t\t\t3.前后缀不同情况</p>\n<p>​\t\t\t\t\t4.更新next值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">get_Next</span><span class=\"params\">(*next, s)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*i 后缀末尾 、 j 前缀末尾【也指i之前（包括i）最长相等前后缀长度】*/</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    j = <span class=\"number\">0</span>;\t\t<span class=\"comment\">/*前缀从最开始的位置开始*/</span></span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; s.size(); i++)&#123;\t<span class=\"comment\">/*i要从位置1开始*/</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//前后缀不同情况</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; s[i] != s[j])  <span class=\"comment\">/*不能写成if*/</span></span><br><span class=\"line\">            j = next[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//前后缀相同情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i] == s[j])</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//更新next值</span></span><br><span class=\"line\">        next[i] = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-改进的KMP算法\"><a href=\"#3-2-改进的KMP算法\" class=\"headerlink\" title=\"3.2 改进的KMP算法\"></a>3.2 改进的KMP算法</h4><p>代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">get_nextval</span><span class=\"params\">(*nextval, s)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; T[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || T[i] = T[k])&#123;</span><br><span class=\"line\">             ++i;</span><br><span class=\"line\">             ++j;</span><br><span class=\"line\">            <span class=\"comment\">//区别如下</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (T[i] != T[k])   nextval[i] = j;\t\t<span class=\"comment\">/*若当前字符与前缀字符不同，则nextval与next无异*/</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>   nextval[i] = nextval[j];\t\t\t<span class=\"comment\">/*若相同，则将nextval值赋值给nextval在i的位置的值*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> k = nextval[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h2 id=\"1-树的定义\"><a href=\"#1-树的定义\" class=\"headerlink\" title=\"1.树的定义\"></a>1.树的定义</h2><p>树(Tree)是n(n&gt;&#x3D;0)个结点的有限集。n&#x3D;0时称为空树。</p>\n<p>任意一颗非空树中：1）有且仅有一个特定的根(Root)结点</p>\n<p>​\t\t\t\t\t\t\t\t   2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每个集合本身又是一棵树，并且称为根的子树(Sub Tree)</p>\n<h3 id=\"1-1结点的分类\"><a href=\"#1-1结点的分类\" class=\"headerlink\" title=\"1.1结点的分类\"></a>1.1结点的分类</h3><p>结点拥有的子树数称为结点的<strong>度(Degree)</strong></p>\n<p>度为0的结点称为**叶结点(Leaf)**或终端结点</p>\n<p>度不为0的结点称为非终端结点或分支结点</p>\n<p>树的度是树内各结点的度的最大值</p>\n<h3 id=\"1-2结点间的关系\"><a href=\"#1-2结点间的关系\" class=\"headerlink\" title=\"1.2结点间的关系\"></a>1.2结点间的关系</h3><p>结点的子树的根称为该结点的<strong>孩子(Child)<strong>，相应的，该结点称为孩子的</strong>双亲(Parent)</strong></p>\n<p>同一个双亲的孩子之间互称<strong>兄弟(Sibling)</strong></p>\n<p>结点的祖先是从根到该结点所经分支上的所有结点</p>\n<p>以某结点为根的子树中的任一结点都称为该节点的子孙</p>\n<h3 id=\"1-3其他相关概念\"><a href=\"#1-3其他相关概念\" class=\"headerlink\" title=\"1.3其他相关概念\"></a>1.3其他相关概念</h3><p>**层次(Level)**：从根开始定义起，根为第一层，根的孩子为第二层</p>\n<p>双亲在同一层的结点互为<strong>堂兄弟</strong></p>\n<p>树中结点最大层次称为树的<strong>深度(Depth)</strong></p>\n<p>如果将树中结点的各子树看成是从左到右有次序的，不能互换的则称为<strong>有序树</strong>，否则称为<strong>无序树</strong></p>\n<h3 id=\"1-4线性表与树\"><a href=\"#1-4线性表与树\" class=\"headerlink\" title=\"1.4线性表与树\"></a>1.4线性表与树</h3><table>\n<thead>\n<tr>\n<th align=\"center\">线性结构</th>\n<th align=\"center\">树结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">第一个数据元素：无前驱<br />最后一个数据元素：无后继<br />中间元素：一个前驱，一个后继</td>\n<td align=\"center\">根结点：无双亲，唯一<br />叶结点：无孩子，可以多个<br />中间结点：一个双亲，多个孩子</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-树的存储结构\"><a href=\"#2-树的存储结构\" class=\"headerlink\" title=\"2.树的存储结构\"></a>2.树的存储结构</h2><h3 id=\"2-1双亲表示法\"><a href=\"#2-1双亲表示法\" class=\"headerlink\" title=\"2.1双亲表示法\"></a>2.1双亲表示法</h3><p>在每个结点中，附设一个指示器指示其双亲结点在数组中的位置</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">parent</th>\n</tr>\n</thead>\n</table>\n<p>其中，data为数据域，parent为指针域，存储该结点的双亲在数组中的下标</p>\n<p>代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结点结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PTNode</span>&#123;</span>\t</span><br><span class=\"line\">    TElemType data;\t\t\t<span class=\"comment\">/*结点数据*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> parent;\t\t\t\t<span class=\"comment\">/*双亲位置*/</span></span><br><span class=\"line\">&#125;PTNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    PTNode nodes[MAX_TREE_SIZE];\t<span class=\"comment\">/*结点数组*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> r,n;\t\t\t\t\t\t<span class=\"comment\">/*根的位置和结点数*/</span></span><br><span class=\"line\">&#125;PTREE;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这样的存储结构可以很快找到他的双亲结点，所用时间复杂度为O(1)</p>\n<p>但若要知道结点的孩子是什么，就只能遍历整个结构</p>\n<p>所以可以增加一个长子域</p>\n<p>我们又关注结点的孩子、有关注结点的兄弟、对时间遍历的要求比较高，那么我们可以把此结构扩展为双亲域、长子域、右兄弟域</p>\n<p><strong>存储结构设计是一个非常灵活的过程</strong></p>\n<p><strong>一个存储结构设计的是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等</strong></p>\n<h3 id=\"2-2孩子表示法\"><a href=\"#2-2孩子表示法\" class=\"headerlink\" title=\"2.2孩子表示法\"></a>2.2孩子表示法</h3><hr>\n<p><strong>每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法</strong></p>\n<ol>\n<li><p>方案1</p>\n<p>指针域的个数等于树的度</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">child1</th>\n<th align=\"center\">child2</th>\n<th align=\"center\">……</th>\n<th align=\"center\">childd</th>\n</tr>\n</thead>\n</table>\n<p>若树中各结点的度相差很大时，浪费空间</p>\n<p>若相差较小，开辟的空间被充分利用了，则缺点变优点</p>\n</li>\n<li><p>方案2</p>\n<p>指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">degree</th>\n<th align=\"center\">child1</th>\n<th align=\"center\">child2</th>\n<th align=\"center\">……</th>\n<th align=\"center\">childd</th>\n</tr>\n</thead>\n</table>\n<p>克服了浪费空间的缺点，提高了空间利用率</p>\n<p>但由于各结点的链表结构不同，加上要维护结点的度和数值，在运算上就会带来时间上的损耗</p>\n</li>\n</ol>\n<p>所以采用孩子表示法</p>\n<p>具体办法是：</p>\n<p><strong>把每个结点的孩子排列起来，以单链表作为存储结构，则n个节点有n个孩子链表</strong></p>\n<p><strong>如果是叶子结点则此单链表为空。</strong></p>\n<p><strong>然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一堆数组中</strong></p>\n<p>为此，设计了两种结点结构</p>\n<p>1.孩子链表的孩子结点</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">child</th>\n<th align=\"center\">next</th>\n</tr>\n</thead>\n</table>\n<p>其中，child是数据域，用来存储某个结点在表头数组中的下标；next是指针域，用来存储指向某结点的下一个孩子结点的指针</p>\n<p>2.表头数组的表头结点</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">firstchild</th>\n</tr>\n</thead>\n</table>\n<p>其中，data是数据域，存储某结点的数据信息；firstchild是头指针域，存储该结点的孩子链表的头指针</p>\n<p>代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//孩子结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CTNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> child;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CTNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;*ChildPtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//表头结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    TElemType data;</span><br><span class=\"line\">    ChildPtr firstchild;</span><br><span class=\"line\">&#125;CTBox;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    CTBOX nodes[MAX_TREE_SIZE]; \t<span class=\"comment\">/*结点数组*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> r,nl\t\t\t\t\t\t<span class=\"comment\">/*根的位置和结点数*/</span></span><br><span class=\"line\">&#125;CTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3孩子兄弟表示法\"><a href=\"#2-3孩子兄弟表示法\" class=\"headerlink\" title=\"2.3孩子兄弟表示法\"></a>2.3孩子兄弟表示法</h3><p>任何一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。</p>\n<p>因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">firstchild</th>\n<th align=\"center\">rightsib</th>\n</tr>\n</thead>\n</table>\n<p>data为数据域；firstchild为指针域，存储长子结点的存储地址；rightsib是指针域，存储该结点的右兄弟结点的存储地址；</p>\n<p><strong>将复杂的树变为二叉树</strong></p>\n<h2 id=\"3-二叉树\"><a href=\"#3-二叉树\" class=\"headerlink\" title=\"3.二叉树\"></a>3.二叉树</h2><p>二叉树(Binary Tree)是n(n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集(称为空二叉树),或者由一个根节点和两棵互不相交、分别称为根结点的左子树和右子树的二叉树组成</p>\n<h3 id=\"3-1二叉树特点\"><a href=\"#3-1二叉树特点\" class=\"headerlink\" title=\"3.1二叉树特点\"></a>3.1二叉树特点</h3><ol>\n<li>每个结点最多有两棵子树</li>\n<li>左子树和右子树是有顺序的</li>\n<li>即使树中某结点只有一颗子树，也要区分它是左子树还是右子树</li>\n</ol>\n<h3 id=\"3-2特殊二叉树\"><a href=\"#3-2特殊二叉树\" class=\"headerlink\" title=\"3.2特殊二叉树\"></a>3.2特殊二叉树</h3><ol>\n<li><p>斜树</p>\n<p>所有结点都只有左子树的二叉树叫左斜树，所有结点都只有右子树的二叉树叫右斜树</p>\n</li>\n<li><p>满二叉树</p>\n<p>所有分支点都存在左子树和右子树，且所有叶子结点都在同一层</p>\n</li>\n<li><p>完全二叉树</p>\n<p>对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置相同，称为完全二叉树</p>\n</li>\n</ol>\n<h3 id=\"3-3二叉树性质\"><a href=\"#3-3二叉树性质\" class=\"headerlink\" title=\"3.3二叉树性质\"></a>3.3二叉树性质</h3><p>性质1：在二叉树的第i层最多有2<sup>i-1</sup>个结点(i&gt;&#x3D;1)</p>\n<p>性质2：深度为k的二叉树至多有2<sup>k</sup>-1个结点(k&gt;&#x3D;1)</p>\n<p>性质3：对任何一棵二叉树T，如果其终端节点为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub> &#x3D; n<sub>2</sub> +1</p>\n<p>性质4：具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1</p>\n<p>性质5：如果一棵有n个结点的完全二叉树的结点按层序编号(从第1层到第[log<sub>2</sub>n]+1层，每层从左到右)，对任一结点i(1&lt;&#x3D;i&lt;&#x3D;n)有：</p>\n<ol>\n<li>如果i&#x3D;1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i&#x2F;2]</li>\n<li>如果2i&gt;n，则结点无左孩子(结点i为叶子结点);否则其左孩子为结点2i</li>\n<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子为结点2i+1</li>\n</ol>\n<h2 id=\"4-二叉树的存储结构\"><a href=\"#4-二叉树的存储结构\" class=\"headerlink\" title=\"4.二叉树的存储结构\"></a>4.二叉树的存储结构</h2><h3 id=\"4-1顺序存储结构\"><a href=\"#4-1顺序存储结构\" class=\"headerlink\" title=\"4.1顺序存储结构\"></a>4.1顺序存储结构</h3><p>一般只用于完全二叉树</p>\n<h3 id=\"4-2二叉链表\"><a href=\"#4-2二叉链表\" class=\"headerlink\" title=\"4.2二叉链表\"></a>4.2二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">lchild</th>\n<th align=\"center\">data</th>\n<th align=\"center\">rchild</th>\n</tr>\n</thead>\n</table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二叉树的二叉链表结点结构定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    TElemType data;\t\t\t<span class=\"comment\">/*结点结构*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span>\t<span class=\"comment\">/*左右孩子指针*/</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"5-遍历二叉树\"><a href=\"#5-遍历二叉树\" class=\"headerlink\" title=\"5.遍历二叉树\"></a>5.遍历二叉树</h2><p><strong>二叉树的遍历时指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次</strong></p>\n<p>两个关键词：<strong>访问</strong>和<strong>次序</strong></p>\n<h3 id=\"5-1前序遍历\"><a href=\"#5-1前序遍历\" class=\"headerlink\" title=\"5.1前序遍历\"></a>5.1前序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树</p>\n<p>算法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PreOrderTraverse</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, T-&gt;data);\t\t\t<span class=\"comment\">/*显示结点数据，可改为其他操作*/</span></span><br><span class=\"line\">    PreOrderTraverse(T -&gt; lchild);\t<span class=\"comment\">/*先序遍历左子树*/</span></span><br><span class=\"line\">    PreOrderTraverse(T -&gt; rchild);\t<span class=\"comment\">/*先序遍历右子树*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"5-2中序遍历\"><a href=\"#5-2中序遍历\" class=\"headerlink\" title=\"5.2中序遍历\"></a>5.2中序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则从根结点开始(注意不是先访问根结点)，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树</p>\n<p>算法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InOrderTraverse</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    InOrderTraverse(T -&gt; lchild);\t<span class=\"comment\">/*中序遍历左子树*/</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, T-&gt;data);\t\t\t<span class=\"comment\">/*显示结点数据，可改为其他操作*/</span></span><br><span class=\"line\">    InOrderTraverse(T -&gt; rchild);\t<span class=\"comment\">/*中序遍历右子树*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-3后序遍历\"><a href=\"#5-3后序遍历\" class=\"headerlink\" title=\"5.3后序遍历\"></a>5.3后序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点</p>\n<p>算法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PostOrderTraverse</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    PostOrderTraverse(T -&gt; lchild);\t<span class=\"comment\">/*后序遍历左子树*/</span></span><br><span class=\"line\">    PostOrderTraverse(T -&gt; rchild);\t<span class=\"comment\">/*后序遍历右子树*/</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, T-&gt;data);\t\t\t<span class=\"comment\">/*显示结点数据，可改为其他操作*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-4层次遍历\"><a href=\"#5-4层次遍历\" class=\"headerlink\" title=\"5.4层次遍历\"></a>5.4层次遍历</h3><p>规则是若二叉树为空，则空操作返回，否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</p>\n<h2 id=\"6-二叉树的建立\"><a href=\"#6-二叉树的建立\" class=\"headerlink\" title=\"6.二叉树的建立\"></a>6.二叉树的建立</h2><p>普通二叉树</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\tA((A)) --- B((B)) &amp; C((C))\n    B ---X(( )) &amp; D((D))\n    style X fill:#f100,stroke-width:0px\n    linkStyle 2 stroke:#off, stroke-width:0px;\n  </pre></div>\n\n<p>扩展二叉树</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\tA((A)) --- B((B)) &amp; C((C))\n    B ---X1((#)) &amp; D((D))\n    D ---X2((#)) &amp; X3((#))\n    C ---X4((#)) &amp; X5((#))\n    classDef X fill:#4169E1\n    class X1,X2,X3,X4,X5 X;\n  </pre></div>\n\n\n\n<p>代码实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//按前序输入二叉树中结点值（一个字符）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CreatBiTree</span><span class=\"params\">(BiTree *T)</span></span>&#123;</span><br><span class=\"line\">    TElemType ch;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cin &gt;&gt; ch;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ch == <span class=\"string\">&quot;#&quot;</span>) T = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!T = <span class=\"keyword\">new</span> BiTNode) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">       \t</span><br><span class=\"line\">        T-&gt;data = ch;\t\t\t<span class=\"comment\">/*生成结点*/</span></span><br><span class=\"line\">        <span class=\"built_in\">CreatBiTree</span>(T-&gt;lchild); <span class=\"comment\">/*构造左子树*/</span></span><br><span class=\"line\">        <span class=\"built_in\">CreatBiTree</span>(T-&gt;rchild); <span class=\"comment\">/*构造右子树*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"7-线索二叉树\"><a href=\"#7-线索二叉树\" class=\"headerlink\" title=\"7.线索二叉树\"></a>7.线索二叉树</h2><p>指针域未充分利用</p>\n<p>将指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">lchild</th>\n<th align=\"center\">ltag</th>\n<th align=\"center\">data</th>\n<th align=\"center\">rtag</th>\n<th align=\"center\">rchild</th>\n</tr>\n</thead>\n</table>\n<p>其中</p>\n<ul>\n<li>ltag为0时指向该结点的左孩子，为1时指向该结点的前驱</li>\n<li>rtag为0时指向该结点的右孩子，为1时指向该结点的后继</li>\n</ul>\n<p>代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span>Link, Thread&#125; PointTag; \t<span class=\"comment\">/*Link==0表示指向左右孩子指针*/</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*Thread==1表示指向前驱或后继的线索*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiThrNode</span>&#123;</span></span><br><span class=\"line\">    TElemType data;\t\t\t\t\t\t<span class=\"comment\">/*结点数据*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiThrNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span>\t<span class=\"comment\">/*左右孩子指针*/</span></span><br><span class=\"line\">    PointerTag LTag,RTagj;\t\t\t\t<span class=\"comment\">/*左右标志*/</span></span><br><span class=\"line\">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>\n\n<p>线索化的过程就是在遍历的过程中修改空指针的过程</p>\n<p>中序遍历线索化的递归函数如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BiThrTree pre;\t\t\t\t\t<span class=\"comment\">/*全局变量，始终指向刚刚访问过的结点*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InThreading</span><span class=\"params\">(BiThrTree p)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p)&#123;</span><br><span class=\"line\">        InThreading(p-&gt;lchild);</span><br><span class=\"line\">        <span class=\"comment\">///////////////////////</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!p-&gt;lchild)&#123;\t\t\t<span class=\"comment\">/*没有左孩子*/</span></span><br><span class=\"line\">            p—&gt;LTag = Thread;\t<span class=\"comment\">/*前驱线索*/</span></span><br><span class=\"line\">            p-&gt;lchild = pre;\t<span class=\"comment\">/*左孩子指针指向前驱*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!pre-&gt;rchild)&#123;\t\t<span class=\"comment\">/*前驱没有右孩子*/</span></span><br><span class=\"line\">            pre-&gt;RTag = Thread; <span class=\"comment\">/*后继线索*/</span></span><br><span class=\"line\">            pre-&gt;rchild = p;\t<span class=\"comment\">/*前驱右孩子指针指向后继(当前结点p)*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;\t\t\t\t<span class=\"comment\">/*保持pre指向p的前驱*/</span></span><br><span class=\"line\">        <span class=\"comment\">///////////////////////</span></span><br><span class=\"line\">        InThreading(p-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点</span></span><br><span class=\"line\">Status <span class=\"title function_\">InOrderTraverse_Thr</span><span class=\"params\">(BiThrTree T)</span>&#123;</span><br><span class=\"line\">    BiThrTree p;</span><br><span class=\"line\">    p = T-&gt;lchild;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=T)&#123;\t\t\t\t\t<span class=\"comment\">/*空树或者遍历结束时，p == T*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;LTag == Link)\tp = p-&gt;lchild;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;data;\t\t\t<span class=\"comment\">/*显示结点数据或其他操作*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)&#123;</span><br><span class=\"line\">            p = p-&gt;rchild;\t\t\t<span class=\"comment\">/*访问后继结点*/</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = p-&gt;rchild;\t\t\t\t<span class=\"comment\">/*p进至其右子树根*/</span></span><br><span class=\"line\">    &#125;\t\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉树链表的存储结构就是非常不错的选择</strong></p>\n<h2 id=\"8-树、森林、二叉树的转换\"><a href=\"#8-树、森林、二叉树的转换\" class=\"headerlink\" title=\"8.树、森林、二叉树的转换\"></a>8.树、森林、二叉树的转换</h2><p><strong>树 –&gt; 二叉树</strong>：</p>\n<p>1.将所有兄弟结点间增加连线</p>\n<p>2.只保留和第一个孩子结点的连线，删除与其他孩子结点连线</p>\n<p>3.本身孩子结点为左孩子结点，兄弟结点为右孩子结点</p>\n<p><strong>森林 –&gt; 二叉树</strong></p>\n<p>1.把每棵树转化为二叉树</p>\n<p>2.第一棵二叉树不懂，从第二棵二叉树开始依次将后一棵二叉树的根节点作为前一棵的根节点的右孩子</p>\n<h2 id=\"9-哈夫曼树及其应用\"><a href=\"#9-哈夫曼树及其应用\" class=\"headerlink\" title=\"9.哈夫曼树及其应用\"></a>9.哈夫曼树及其应用</h2><h3 id=\"9-1哈夫曼树的定义及原理\"><a href=\"#9-1哈夫曼树的定义及原理\" class=\"headerlink\" title=\"9.1哈夫曼树的定义及原理\"></a>9.1哈夫曼树的定义及原理</h3><p>最基本的压缩编码方法——-哈夫曼编码</p>\n<p>带权路径长度WPL最小的二叉树称作哈夫曼树</p>\n<ol>\n<li>先把有权值的叶子结点按照从小到大的顺序排列成有序序列，即A5,E10, B15, D30, C40</li>\n<li>取头两个最小权值结点形成新结点N<sub>1</sub>，相对较小的为左孩子</li>\n<li>N<sub>1</sub>替换A、E，插入有序序列中重复2</li>\n</ol>\n<h3 id=\"9-2哈夫曼编码\"><a href=\"#9-2哈夫曼编码\" class=\"headerlink\" title=\"9.2哈夫曼编码\"></a>9.2哈夫曼编码</h3><h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><h2 id=\"1-图的定义及术语\"><a href=\"#1-图的定义及术语\" class=\"headerlink\" title=\"1.图的定义及术语\"></a>1.图的定义及术语</h2><h2 id=\"2-图的存储结构\"><a href=\"#2-图的存储结构\" class=\"headerlink\" title=\"2.图的存储结构\"></a>2.图的存储结构</h2><h3 id=\"2-1邻接矩阵\"><a href=\"#2-1邻接矩阵\" class=\"headerlink\" title=\"2.1邻接矩阵\"></a>2.1邻接矩阵</h3><p>图的邻接矩阵存储方式是用两个数组来表示图。</p>\n<p>一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边的信息</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\nV0 --- V1 &amp; V2 &amp; V3\nV2 --- V1 &amp;  V3\n  </pre></div>\n\n<p>顶点数组： </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">V0</th>\n<th align=\"center\">V1</th>\n<th align=\"center\">V2</th>\n<th align=\"center\">V3</th>\n</tr>\n</thead>\n</table>\n<p>邻接矩阵：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">0</th>\n<th align=\"center\">1</th>\n<th align=\"center\">1</th>\n<th align=\"center\">1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n<p><strong>邻接矩阵存储结构</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    VertexType vexs[MAXVEX];\t\t<span class=\"comment\">/*顶点表*/</span></span><br><span class=\"line\">    EdgeType arc[MAXVEX][MAXVEX];\t<span class=\"comment\">/*邻接矩阵，可看作边表*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> numNodes, numEdges;\t\t\t<span class=\"comment\">/*图中的定点数和边数*/</span></span><br><span class=\"line\">&#125;MGraph;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>无向网图创建代码</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">CreatMGraph</span><span class=\"params\">(MGraph *G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, k, w;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;请输入顶点数和边数&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; G-&gt;numNodes &gt;&gt; G-&gt;numEdges;\t\t\t\t\t\t<span class=\"comment\">/*输入顶点数和边数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G-&gt;numNodes; i++)\t<span class=\"built_in\">cin</span> &gt;&gt; G-&gt;vexs[i];\t<span class=\"comment\">/*读入顶点信息，建立顶点表*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G-&gt;numNodes; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; G-&gt;numNodes; j++)</span><br><span class=\"line\">            G-&gt;arc[i][j] = INFINITY;\t\t\t\t\t\t<span class=\"comment\">/*初始化邻接矩阵*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; G-&gt;numEdges; k++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;输入边(vi,vj)的下标i,j和权w：\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i &gt;&gt; j &gt;&gt; w;</span><br><span class=\"line\">        G-&gt;arc[i][j] = w;</span><br><span class=\"line\">        G-&gt;arc[j][i] = G-&gt;arc[i][j];\t\t\t\t\t\t<span class=\"comment\">/*无向图，所以矩阵对称*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"2-2邻接表\"><a href=\"#2-2邻接表\" class=\"headerlink\" title=\"2.2邻接表\"></a>2.2邻接表</h3><p>数组与链表相结合的存储方式称为邻接表</p>\n<p>1.用数组存储顶点</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">firstedge</th>\n</tr>\n</thead>\n</table>\n<p>2.用链表存储临界点</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">adjvex</th>\n<th align=\"center\">next</th>\n</tr>\n</thead>\n</table>\n<p>有向图中，邻接表可以算出度</p>\n<p>逆邻接表可以算入度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span>&#123;</span>\t\t\t\t\t<span class=\"comment\">/*边表结点*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> adjvex;\t\t\t\t\t\t\t\t<span class=\"comment\">/*邻接点域，存储该顶点对应下标*/</span></span><br><span class=\"line\">    EdgeType info;\t\t\t\t\t\t\t<span class=\"comment\">/*用于存储权值，对非网图可以不要*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> *<span class=\"title\">next</span>;</span>\t\t\t\t\t<span class=\"comment\">/*链域，指向下一个邻接点*/</span></span><br><span class=\"line\">&#125;EdgeNode；</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VertexNode</span>&#123;</span>\t\t\t\t\t<span class=\"comment\">/*顶点表结点*/</span></span><br><span class=\"line\">    VertexType data;\t\t\t\t\t\t<span class=\"comment\">/*顶点域，存储顶点信息*/</span></span><br><span class=\"line\">    EdgeNode *firstedge;\t\t\t\t\t<span class=\"comment\">/*边表头指针*/</span></span><br><span class=\"line\">&#125;VertexNode,AdjList[MAXVEX];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    AdjList adjlist;</span><br><span class=\"line\">    <span class=\"type\">int</span> numNodes, numEdges;\t\t\t\t\t<span class=\"comment\">/*图中当前顶点数和边数*/</span></span><br><span class=\"line\">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure>\n\n<p><strong>邻接表的创建</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//建立图的邻接表结构</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">CreatALGraph</span><span class=\"params\">(GraphAdjList *G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">    EdgeNode *e;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;请输入顶点数和边数&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; G-&gt;numNodes &gt;&gt; G-&gt;numEdges;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G-&gt;numNodes; i++)&#123;\t\t<span class=\"comment\">/*读入顶点信息，建立顶点表*/</span></span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; G-&gt;adjList[i].data;\t\t\t<span class=\"comment\">/*输入顶点信息*/</span></span><br><span class=\"line\">        G-&gt;adjList[i].firstedge = <span class=\"literal\">NULL</span>;\t\t<span class=\"comment\">/*边表置为空表*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; G-&gt;numEdges; k++)&#123;\t\t<span class=\"comment\">/*读入顶点信息，建立边表*/</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;输入边(vi,vj)上的顶点序号:&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i &gt;&gt; j;</span><br><span class=\"line\">        <span class=\"comment\">////////////////////////////////////////////////////////////</span></span><br><span class=\"line\">        e = new EdgeNode;</span><br><span class=\"line\">        e-&gt;adjvex = j;</span><br><span class=\"line\">        e-&gt;next = G-&gt;adjList[i].firstedge;</span><br><span class=\"line\">        G-&gt;adjList[i].firstedge = e;\t\t<span class=\"comment\">/////头插法</span></span><br><span class=\"line\">        e = new EdgeNode;</span><br><span class=\"line\">        e-&gt;adjvex = i;</span><br><span class=\"line\">        e-&gt;next = G-&gt;adjList[j].firstedge;</span><br><span class=\"line\">        G-&gt;adjList[j].firstedge = e;</span><br><span class=\"line\">        <span class=\"comment\">////////////////////////////////////////////////////////////</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3十字链表\"><a href=\"#2-3十字链表\" class=\"headerlink\" title=\"2.3十字链表\"></a>2.3十字链表</h3><p>将邻接表与逆邻接表结合起来</p>\n<p>顶点表结点结构如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">firstin</th>\n<th align=\"center\">firstout</th>\n</tr>\n</thead>\n</table>\n<p>边表结点如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">tailvex</th>\n<th align=\"center\">headvex</th>\n<th align=\"center\">headlink</th>\n<th align=\"center\">taillink</th>\n</tr>\n</thead>\n</table>\n<p>tailvex：边起点在顶点表中下标</p>\n<p>headvex：边终点在定点表中下标</p>\n<p>headlink：入边表指针域，指向终点相同的下一条边</p>\n<p>taillink：出边表指针域，指向起点相同的下一条边</p>\n<h3 id=\"2-4邻接多重表\"><a href=\"#2-4邻接多重表\" class=\"headerlink\" title=\"2.4邻接多重表\"></a>2.4邻接多重表</h3><h3 id=\"2-5边集数组\"><a href=\"#2-5边集数组\" class=\"headerlink\" title=\"2.5边集数组\"></a>2.5边集数组</h3><p>边集数组是由两个一维数组构成。</p>\n<p>一个存储顶点信息，一个存储边的信息</p>\n<p>顶点数组</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">V0</th>\n<th align=\"center\">V1</th>\n<th align=\"center\">V2</th>\n<th align=\"center\">V3</th>\n<th align=\"center\">V4</th>\n</tr>\n</thead>\n</table>\n<p>边数组</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">begin</th>\n<th align=\"center\">end</th>\n<th align=\"center\">weight</th>\n</tr>\n</thead>\n</table>\n<h2 id=\"3-图的遍历\"><a href=\"#3-图的遍历\" class=\"headerlink\" title=\"3.图的遍历\"></a>3.图的遍历</h2><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历</p>\n<p><strong>遍历实质</strong>：图的邻接点</p>\n<h3 id=\"3-1深度优先遍历\"><a href=\"#3-1深度优先遍历\" class=\"headerlink\" title=\"3.1深度优先遍历\"></a>3.1深度优先遍历</h3><p>深度优先遍历(Depth First Search) <strong>DFS</strong></p>\n<p><strong>类似树的前序遍历</strong></p>\n<p>从图中某个顶点V出发，访问此顶点，然后从V的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到</p>\n<p>若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//邻接矩阵的深度优先递归算法</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j;</span><br><span class=\"line\">    visitet[i] = TRUE;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; G.vexs[i];\t\t\t\t\t\t\t<span class=\"comment\">/*访问顶点，也可做其他操作*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; G.numVertexes; j++)\t\t\t</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G.arc[i][j] == <span class=\"number\">1</span> &amp;&amp; !visited[j])\t\t<span class=\"comment\">/*G.arc[i][j]为1代表邻接，visited[i] = 0代表未被访问*/</span></span><br><span class=\"line\">            DFS(G, j);\t\t\t\t\t\t\t<span class=\"comment\">/*对未访问的顶点做递归调用*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<strong>邻接矩阵</strong>表示图，遍历图中每个顶点都要从头扫描该顶点所在行，时间复杂度O(n<sup>2</sup>)</p>\n<hr>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//邻接表的深度优先递归算法</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DFS</span><span class=\"params\">(GraphAdjList GL, <span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    EdgeNode *p;</span><br><span class=\"line\">    visit[i] = TRUE;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; GL.adjList[i].data;\t\t\t\t\t<span class=\"comment\">/*打印顶点，也可做其他操作*/</span></span><br><span class=\"line\">    p = GL-&gt;adjList[i].firstedge;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[p-&gt;adjvex])</span><br><span class=\"line\">            DFS(GL, p-&gt;adjvex);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<strong>邻接表</strong>来表示图，有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点，时间复杂度为O(n+e)</p>\n<h3 id=\"3-2广度优先遍历\"><a href=\"#3-2广度优先遍历\" class=\"headerlink\" title=\"3.2广度优先遍历\"></a>3.2广度优先遍历</h3><p>广度优先遍历(Breadth First Search) <strong>BFS</strong></p>\n<p><strong>类似树的层序遍历</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//邻接矩阵的广度遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BFS</span><span class=\"params\">(Graph G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">    InitQueue(Q);\t\t\t\t\t\t\t\t<span class=\"comment\">/*辅助队列初始化,置空*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G.numVertexes; i++)&#123;\t\t\t<span class=\"comment\">/*对每个顶点做循环*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[i])&#123;\t\t\t\t\t\t<span class=\"comment\">/*若是未被访问过就处理*/</span></span><br><span class=\"line\">            visited[i] = TRUE;\t\t\t\t\t<span class=\"comment\">/*标记为已访问*/</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; G.vexs[i];\t\t\t\t\t<span class=\"comment\">/*访问顶点*/</span></span><br><span class=\"line\">            EnQueue(Q,i);\t\t\t\t\t\t<span class=\"comment\">/*当前顶点入队*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!QueueEmpty(Q))&#123;\t\t\t\t<span class=\"comment\">/*若当前队列不为空*/</span></span><br><span class=\"line\">                DeQueue(Q,i);\t\t\t\t\t<span class=\"comment\">/*将队首元素出队列，赋值给i*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; G.numVertexes; j++)&#123;\t\t\t\t</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(G.arc[i][j] == <span class=\"number\">1</span> &amp;&amp; !visited[j])&#123;\t\t<span class=\"comment\">/*判断其他顶点，若与当前顶点存在边且未访问过*/</span></span><br><span class=\"line\">                        visited[j] == TRUE;\t\t\t\t\t\t</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; G.vexs[j];\t\t\t\t\t\t<span class=\"comment\">/*访问顶点*/</span></span><br><span class=\"line\">                        EnQueue(Q,j);\t\t\t\t\t\t\t<span class=\"comment\">/*将找到的顶点入队列*/</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//邻接表的广度遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BFS</span><span class=\"params\">(GraphAdjList GL)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    EdgeNode *p;</span><br><span class=\"line\">    Queue Q;</span><br><span class=\"line\">    InitQueue(Q);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; GL-&gt;numVertexes; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[i])&#123;</span><br><span class=\"line\">            visit[i] = TRUE;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; G.vexs[i];\t\t\t\t\t<span class=\"comment\">/*访问顶点*/</span></span><br><span class=\"line\">            EnQueue(Q,i);\t\t\t\t\t\t<span class=\"comment\">/*当前顶点入队*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!QueueEmpty(Q))&#123;</span><br><span class=\"line\">                DeQueue(Q,i);</span><br><span class=\"line\">                p = GL-&gt;adjustList[i].firstedge;<span class=\"comment\">/*找到当前顶点的边表链的表头指针*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!visited[p-&gt;adjvex])&#123;\t<span class=\"comment\">/*若顶点未被访问*/</span></span><br><span class=\"line\">                        visited[p-&gt;adjvex] = TRUE;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; GL-&gt;adjList[p-&gt;adjvex].data;<span class=\"comment\">/*访问顶点*/</span></span><br><span class=\"line\">                        EnQueue(Q,p-&gt;adjvex);   <span class=\"comment\">/*将此顶点入队列*/</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = p-&gt;next;\t\t\t\t<span class=\"comment\">/*指针指向下一个邻接点*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"4-最小生成树\"><a href=\"#4-最小生成树\" class=\"headerlink\" title=\"4.最小生成树\"></a>4.最小生成树</h2><p>构造连通网的最小代价生成树称为最小生成树</p>\n<h3 id=\"4-1Prim算法\"><a href=\"#4-1Prim算法\" class=\"headerlink\" title=\"4.1Prim算法\"></a>4.1Prim算法</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Prim算法生成最小生成树</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MiniSpanTress_Prim</span><span class=\"params\">(MGraph G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> min, i, j, k;</span><br><span class=\"line\">    <span class=\"type\">int</span> adjvex[MAXVEX];\t\t\t\t\t\t<span class=\"comment\">/*邻接点下标*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> lowcost[MAXVEX];\t\t\t\t\t<span class=\"comment\">/*保存权值*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class=\"line\">        lowcost[i] = G.arc[<span class=\"number\">0</span>][i];\t\t\t<span class=\"comment\">/*将V0顶点与其他所有点连接的权值存入数组*/</span></span><br><span class=\"line\">        adjvex[i] = <span class=\"number\">0</span>;\t\t\t\t\t\t<span class=\"comment\">/*初始化为V0下标*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class=\"line\">     \tmin = INFINITY;\t\t\t\t\t\t<span class=\"comment\">/*初始化最小权值为∞,可设为较大数字*/</span></span><br><span class=\"line\">        j = <span class=\"number\">1</span>; k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//找到最小权值边，并将最小权值边的邻接点存入k</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &lt; G.numVertexes)&#123;\t\t\t\t</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lowcost[j] != <span class=\"number\">0</span> &amp;&amp; lowcost[j] &lt; min)&#123;</span><br><span class=\"line\">                min = lowcost[j];</span><br><span class=\"line\">                k = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;(&quot;</span> + adjvex[k] + <span class=\"string\">&quot;,&quot;</span> + k + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">        lowcost[k] = <span class=\"number\">0</span>;\t\t\t\t\t\t<span class=\"comment\">/*当前点已完成任务*/</span></span><br><span class=\"line\">        <span class=\"comment\">//将与k相接的边的权值更新至lowcost数组，并将其邻接点adjvex更新为k</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">1</span>; j &lt; G.numVertexes; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lowcost[j] != <span class=\"number\">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j])&#123;</span><br><span class=\"line\">                lowcost[j] = G.arc[k][j];</span><br><span class=\"line\">                adjvex[j] = k;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-2Kruskal算法\"><a href=\"#4-2Kruskal算法\" class=\"headerlink\" title=\"4.2Kruskal算法\"></a>4.2Kruskal算法</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义边集数组</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> begin;</span><br><span class=\"line\">    <span class=\"type\">int</span> end;</span><br><span class=\"line\">    <span class=\"type\">int</span> weight;</span><br><span class=\"line\">&#125;Edge;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Kruskal算法生成最小生成树</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MiniSpanTree_Kruskal</span><span class=\"params\">(MGraph G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, n, m;</span><br><span class=\"line\">    Edge edges[MAXEDGE];</span><br><span class=\"line\">    <span class=\"type\">int</span> parent[MAXEDGE];\t\t\t\t\t<span class=\"comment\">/*判断边是否形成回路*/</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*省略按权值排序*/</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class=\"line\">        parent[i] = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G.numEdges; i++)&#123;</span><br><span class=\"line\">        n = Find(parent, edges[i].begin);</span><br><span class=\"line\">        m = Find(parent, edges[i].end);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n != m)&#123;\t\t\t\t\t\t\t<span class=\"comment\">/*m若与n不相等，即未形成环路*/</span></span><br><span class=\"line\">            parent[n] = m;\t\t\t\t\t<span class=\"comment\">/*将此边的结尾顶点放入下标为起点的parent中，表示此顶点已在生成树集合中*/</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;(%d, %d) %d&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//查找连接顶点的尾部下标</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">Find</span><span class=\"params\">(<span class=\"type\">int</span> *parent, <span class=\"type\">int</span> f)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(parent[f] &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            f = parent[f];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-3比较\"><a href=\"#4-3比较\" class=\"headerlink\" title=\"4.3比较\"></a>4.3比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">算法名</th>\n<th align=\"center\">Prim算法</th>\n<th align=\"center\">Kruskal算法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">算法思想</td>\n<td align=\"center\">选择点</td>\n<td align=\"center\">选择边</td>\n</tr>\n<tr>\n<td align=\"center\">时间复杂度</td>\n<td align=\"center\">O(n<sup>2</sup>)     n为顶点数</td>\n<td align=\"center\">O(eloge)   e为边数</td>\n</tr>\n<tr>\n<td align=\"center\">适应范围</td>\n<td align=\"center\">稠密图</td>\n<td align=\"center\">稀疏图</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-最短路径\"><a href=\"#5-最短路径\" class=\"headerlink\" title=\"5.最短路径\"></a>5.最短路径</h2><h3 id=\"5-1Dijkstra算法\"><a href=\"#5-1Dijkstra算法\" class=\"headerlink\" title=\"5.1Dijkstra算法\"></a>5.1Dijkstra算法</h3><p>数据结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> vexs[MAXVEX];</span><br><span class=\"line\">    <span class=\"type\">int</span> arc[MAXVEX][MAXVEX];</span><br><span class=\"line\">    <span class=\"type\">int</span> numVertexes, numEdges;</span><br><span class=\"line\">&#125;MGraph;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> Patharc[MAXVEX];\t\t\t<span class=\"comment\">/*用于存储最短路径下标的数组*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> ShortPathTable[MAXVEX];\t\t<span class=\"comment\">/*用于存储到各点最短路径的权值和*/</span></span><br></pre></td></tr></table></figure>\n\n<p>算法代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Dijkstra算法 求V0到其余顶点的最短路径P[v]及带权长度D[v]</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ShorttestPath_Dijkstra</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> v0, Pathace *P, ShortPathTable *D)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> v, w, k, min;</span><br><span class=\"line\">    <span class=\"type\">int</span> final[MAXVEX];\t\t\t\t\t\t<span class=\"comment\">/*final[k] = 1 表示已求得*/</span></span><br><span class=\"line\">    <span class=\"comment\">//初始化数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(v = <span class=\"number\">0</span>; v &lt; G.arc[v0][v]; v++)&#123;</span><br><span class=\"line\">        final[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        *D[v] = G.arc[v0][v];</span><br><span class=\"line\">        *P[v] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *D[v0] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    final[v0] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//开始主循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(v = <span class=\"number\">1</span>; v &lt; G.numVertexes; v++)&#123;</span><br><span class=\"line\">        min = INFINITY;</span><br><span class=\"line\">        <span class=\"comment\">//寻找距离v0最近的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(w = <span class=\"number\">0</span>; w &lt; G.numVertexes; w++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!final[w] &amp;&amp; *D[w] &lt; min)&#123;</span><br><span class=\"line\">                k = w;</span><br><span class=\"line\">                min = *D[w];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        final[k] = <span class=\"number\">1</span>;\t\t\t\t\t\t<span class=\"comment\">/*将目前找到的顶点置1*/</span></span><br><span class=\"line\">        <span class=\"comment\">//修正当前最短路径及距离</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(w = <span class=\"number\">0</span>; w &lt; G.numVertexes; w++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果经过v顶点的路径比现在该路径长度短</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!final[w] &amp;&amp; (min + arc[k][w] &lt; *G[w]))&#123;</span><br><span class=\"line\">                *D[w] = min + arc[k][w];\t<span class=\"comment\">/*更新最小值*/</span></span><br><span class=\"line\">                *P[w] = k;\t\t\t\t\t<span class=\"comment\">/*更新路径*/</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2Floyd算法\"><a href=\"#5-2Floyd算法\" class=\"headerlink\" title=\"5.2Floyd算法\"></a>5.2Floyd算法</h3><p>算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Patharc[MAXVEX][MAXVEX];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Floyd算法，求G中各顶点V到其余顶点w的最短路径P[v][w]及带权长度D[v][w]</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ShortestPath_Floyd</span><span class=\"params\">(MGraph G, Patharc *P, ShortPathTable *D)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> v, w, k;</span><br><span class=\"line\">    <span class=\"comment\">//初始化D与P</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(v = <span class=\"number\">0</span>; v &lt; G.numVertexes; ++v)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(w = <span class=\"number\">0</span>; w &lt; G.numVertexes; ++w)&#123;</span><br><span class=\"line\">            *D[v][w] = G.arc[v][w];</span><br><span class=\"line\">            *P[v][w] = w;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; G.numVertexes; ++k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(v = <span class=\"number\">0</span>; v &lt; G.numVertexes; ++v)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(w = <span class=\"number\">0</span>; w &lt; G.numVertexes; ++w)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果经过k顶点的路径比原两点路径短</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(*D[v][w] &gt; *D[v][k] + *D[k][w])&#123;</span><br><span class=\"line\">                    *D[v][w] = *D[v][k] + *D[k][w];</span><br><span class=\"line\">                    *P[v][w] = *P[v][k];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-拓扑排序\"><a href=\"#6-拓扑排序\" class=\"headerlink\" title=\"6.拓扑排序\"></a>6.拓扑排序</h2><p>有向无环图</p>\n<p><strong>AOV网</strong></p>\n<p>以顶点表示活动，弧表示活动间优先制约关系</p>\n<p><strong>拓扑有序序列</strong></p>\n<p>在AOV网没有回路的前提下，将全部活动排列成一个线性序列，若从顶点V<sub>i</sub>到V<sub>j</sub>有一条路径，那么V<sub>i</sub>必在V<sub>j</sub>之前</p>\n<p>我们称这样的线性序列为<strong>拓扑有序序列</strong></p>\n<p><strong>检测AOV中是否存在环</strong></p>\n<p>对有向图构造拓扑有序序列，若所有点都在拓扑有序序列中，则AOV网必不存在环</p>\n<h2 id=\"7-关键路径\"><a href=\"#7-关键路径\" class=\"headerlink\" title=\"7.关键路径\"></a>7.关键路径</h2><p><strong>AOE网</strong></p>\n<p>以弧表示活动，以顶点表示活动的开始或者结束事件</p>\n<p><strong>关键路径</strong></p>\n<p>路径长度最长的路径</p>\n<h3 id=\"7-1定义参数\"><a href=\"#7-1定义参数\" class=\"headerlink\" title=\"7.1定义参数\"></a>7.1定义参数</h3><table>\n<thead>\n<tr>\n<th align=\"center\">定义参数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ve(V<sub>j</sub>)</td>\n<td align=\"center\">表示事件V<sub>j</sub>最早发生时间</td>\n</tr>\n<tr>\n<td align=\"center\">vl(V<sub>j</sub>)</td>\n<td align=\"center\">表示事件V<sub>j</sub>最迟发生时间</td>\n</tr>\n<tr>\n<td align=\"center\">e(i)</td>\n<td align=\"center\">表示活动i最早开始时间</td>\n</tr>\n<tr>\n<td align=\"center\">l(i)</td>\n<td align=\"center\">表示活动i最晚开始时间</td>\n</tr>\n</tbody></table>\n<p>l(i) - e(i) —–表示完成活动i的时间余量</p>\n<p><strong>关键活动</strong> —–l(i) &#x3D;&#x3D; e(i)</p>\n<p><strong>求关键路径步骤</strong></p>\n<ol>\n<li>求ve(V<sub>j</sub>)、vl(V<sub>j</sub>)</li>\n<li>求e(i)、l(i)</li>\n<li>计算l(i) - e(i)</li>\n</ol>\n<h1 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h1><h2 id=\"1-查找概论\"><a href=\"#1-查找概论\" class=\"headerlink\" title=\"1.查找概论\"></a>1.查找概论</h2><p>**查找表(Search Table)**是由同一类型的数据元素构成的集合</p>\n<p>**关键字(Key)**是数据元素中的某个数据项的值</p>\n<p>若此关键字可以唯一地标记一个记录，则称此关键字为<strong>主关键字(Primary Key)</strong></p>\n<p>对于可以识别多个数据元素的关键词，称为<strong>次关键字(Secondary Key)</strong></p>\n<p><strong>查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素</strong></p>\n<p><strong>静态查找表</strong>：只做查找操作的查找表</p>\n<ol>\n<li>查询特定的数据元素是否在查找表中</li>\n<li>检索特定的数据元素和各种属性</li>\n</ol>\n<p><strong>动态查找表</strong>：在查找过程中同时插入表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</p>\n<ol>\n<li>查找时插入数据元素</li>\n<li>查找时删除数据元素</li>\n</ol>\n<h2 id=\"2-顺序表查找\"><a href=\"#2-顺序表查找\" class=\"headerlink\" title=\"2.顺序表查找\"></a>2.顺序表查找</h2><p>针对线性表进行查找操作，所以为静态查找表</p>\n<p>**顺序查找(Sequential Search)**又叫线性查找，是最基本的查找技术，查找过程如下：</p>\n<p>从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较</p>\n<p>若某个记录的关键字和给定值相等，则查找成功</p>\n<p>若直到最后一个（或者第一个）记录的关键字和给定值比较都不等时，查找失败</p>\n<p>实现算法如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Sequential_Search</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> n, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] == ket)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有哨兵顺序查找</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Sequential_Search2</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> n, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = key;\t\t\t\t\t<span class=\"comment\">/*设置a[0]为关键字值，称之为“哨兵”*/</span></span><br><span class=\"line\">    i = n;\t\t\t\t\t\t<span class=\"comment\">/*循环从数组尾部开始*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a[i] != key)&#123;</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-有序表查找\"><a href=\"#3-有序表查找\" class=\"headerlink\" title=\"3.有序表查找\"></a>3.有序表查找</h2><h3 id=\"3-1二分查找\"><a href=\"#3-1二分查找\" class=\"headerlink\" title=\"3.1二分查找\"></a>3.1二分查找</h3><p>**折半查找(Binary Search)**又称二分查找</p>\n<p>前提是线性表中记录必须是<strong>关键码有序</strong>（通常从小到大有序），线性表必须采用顺序存储</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Binary_Search</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> n, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> low, high, mid;</span><br><span class=\"line\">    low = <span class=\"number\">1</span>;</span><br><span class=\"line\">    high = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high)&#123;</span><br><span class=\"line\">        mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; a[mid])</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &gt; a[mid])</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>时间复杂度O(logn)</strong></p>\n<h3 id=\"3-2插值查找\"><a href=\"#3-2插值查找\" class=\"headerlink\" title=\"3.2插值查找\"></a>3.2插值查找</h3><p>将二分查找的代码做略微变换</p>\n<p>$$mid &#x3D; \\frac{low + high}{2}$ &#x3D;$low + \\frac{1}{2}(high - low)$$</p>\n<p>改为以下计算方案</p>\n<p>$$mid &#x3D; low + \\frac{key - a[low]}{a[high] - a[low]}(high - low)$$</p>\n<h3 id=\"3-3斐波那契查找\"><a href=\"#3-3斐波那契查找\" class=\"headerlink\" title=\"3.3斐波那契查找\"></a>3.3斐波那契查找</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Fibonacci_Search</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> n, <span class=\"type\">int</span> ket)</span>&#123;\t\t<span class=\"comment\">/*F[n]为已经计算好的斐波那契数列*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> low, high, mid, i, k;</span><br><span class=\"line\">    low = <span class=\"number\">1</span>;</span><br><span class=\"line\">    high = n;</span><br><span class=\"line\">    k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; F[k] - <span class=\"number\">1</span>)\t\t\t\t\t\t\t<span class=\"comment\">/*计算n位斐波那契数列的位置*/</span></span><br><span class=\"line\">        k++;\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = n; i &lt; F[K] - <span class=\"number\">1</span>; i++)\t\t\t\t\t<span class=\"comment\">/*将数值补全*/</span></span><br><span class=\"line\">        a[i] = a[n];</span><br><span class=\"line\">    <span class=\"comment\">//查找开始</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high)&#123;\t\t\t\t\t\t\t</span><br><span class=\"line\">        mid = low + F[K - <span class=\"number\">1</span>] - <span class=\"number\">1</span>;\t\t\t\t\t<span class=\"comment\">/*计算当前分隔下标*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; a[mid])&#123;</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            k = k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; a[mid])&#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            k = k - <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mid &lt;= n)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度O(logn)</strong></p>\n<h3 id=\"3-4对比\"><a href=\"#3-4对比\" class=\"headerlink\" title=\"3.4对比\"></a>3.4对比</h3><p>时间复杂度相同</p>\n<p>斐波那契查找只进行简单加减法运算$mid&#x3D;low+F[k-1]-1$</p>\n<p>折半查找进行加法与除法运算$mid&#x3D;\\frac{low+high}{2}$</p>\n<p>插值查找进行复杂四则运算$$mid &#x3D; low + \\frac{key - a[low]}{a[high] - a[low]}(high - low)$$</p>\n<p>三种有序表的查找法本质上是分隔点选择不同，各有优劣</p>\n<h2 id=\"4-线性索引查找\"><a href=\"#4-线性索引查找\" class=\"headerlink\" title=\"4.线性索引查找\"></a>4.线性索引查找</h2><p>索引就是把一个关键字与它对应的记录相关联的过程</p>\n<p>线性索引就是将索引项集合组织为线性结构，也称为<strong>索引表</strong></p>\n<h3 id=\"4-1稠密索引\"><a href=\"#4-1稠密索引\" class=\"headerlink\" title=\"4.1稠密索引\"></a>4.1稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</p>\n<p>对于稠密索引来说，<strong>索引项一定是按照关键码有序排列的</strong></p>\n<p>意味着可以用到折半、插值、斐波那契等有序查找法</p>\n<h3 id=\"4-2分块索引\"><a href=\"#4-2分块索引\" class=\"headerlink\" title=\"4.2分块索引\"></a>4.2分块索引</h3><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足一下两个条件</p>\n<ol>\n<li>块内无序</li>\n<li>块间有序</li>\n</ol>\n<p>我们定义的分块索引项结构分三个部分</p>\n<ul>\n<li>最大关键码</li>\n<li>存储块中记录个数</li>\n<li>用于指向块首数据元素的指针</li>\n</ul>\n<p>在分块索引表中查找就是进行以下两步</p>\n<ol>\n<li>在分块索引表中查找要查关键字所在的块</li>\n<li>根据块首指针找到相应的块，并在块中顺序查找关键码</li>\n</ol>\n<p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中</p>\n<h3 id=\"4-3倒排索引\"><a href=\"#4-3倒排索引\" class=\"headerlink\" title=\"4.3倒排索引\"></a>4.3倒排索引</h3><p>索引项的通用结构是</p>\n<ul>\n<li>次关键码</li>\n<li>记录号表</li>\n</ul>\n<p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）</p>\n<h2 id=\"5-二叉排序树\"><a href=\"#5-二叉排序树\" class=\"headerlink\" title=\"5.二叉排序树\"></a>5.二叉排序树</h2><p>**二叉排序树(Binary Sort Tree)**，又称为二叉查找树。它或者是一棵空树，或者是具有以下性质的二叉树</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>\n<li>它的左、右子树也分别为二叉排列树</li>\n</ul>\n<p>构造一棵二叉排序树的目的，不是为了排序，而是为了提高查找和插入删除关键字的速度</p>\n<h3 id=\"5-1查找操作\"><a href=\"#5-1查找操作\" class=\"headerlink\" title=\"5.1查找操作\"></a>5.1查找操作</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二叉树的二叉链表的结点结构定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>二叉排序树的查找</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">SearchBST</span><span class=\"params\">(BiTree T, <span class=\"type\">int</span> key, BiTree f, BiTree *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//递归查找二叉排序树T中是否存在key</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!T)&#123;\t\t\t\t\t\t\t\t<span class=\"comment\">/*若查找不成功，指针p指向查找路径上访问的最后一个结点并返回FALSE*/</span></span><br><span class=\"line\">        *p = f;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key == T-&gt;data)&#123;\t\t\t\t<span class=\"comment\">/*若查找成功，则指针p指向该数据元素结点，并返回TRUE*/</span></span><br><span class=\"line\">        *p = T;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; T-&gt;data)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SearchBST(T-&gt;lchild, key, T, p); <span class=\"comment\">/*在左子树中继续查找*/</span></span><br><span class=\"line\">   \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; T-&gt;data)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SearchBST(T-&gt;rchild, key, T, p); <span class=\"comment\">/*在右子树中继续查找*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-2插入操作\"><a href=\"#5-2插入操作\" class=\"headerlink\" title=\"5.2插入操作\"></a>5.2插入操作</h3><p>将关键字放到树中合适的位置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InsertBST</span><span class=\"params\">(BiTree *T, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    BiTree p, s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!SearchBST(*T, key, <span class=\"literal\">NULL</span>, &amp;p))&#123;\t\t\t<span class=\"comment\">/*查找不成功*/</span></span><br><span class=\"line\">        s = new BiTNode;</span><br><span class=\"line\">        s-&gt;data = key;</span><br><span class=\"line\">        s-&gt;lchild = s-&gt;rchild = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!p)</span><br><span class=\"line\">            *T = s;\t\t\t\t\t\t\t\t<span class=\"comment\">/*插入s为新的根结点*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; p-&gt;data;)\t\t\t\t</span><br><span class=\"line\">            p-&gt;lchild = s;\t\t\t\t\t\t<span class=\"comment\">/*插入s为左孩子*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            p-&gt;rchild = s;\t\t\t\t\t\t<span class=\"comment\">/*插入s为右孩子*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;\t\t\t\t\t\t\t<span class=\"comment\">/*树中已有与关键字相同结点，不再插入*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-3删除操作\"><a href=\"#5-3删除操作\" class=\"headerlink\" title=\"5.3删除操作\"></a>5.3删除操作</h3><p>删除结点三种情况</p>\n<ul>\n<li>叶子结点</li>\n<li>仅有左子树或右子树结点</li>\n<li>左右子树都有的结点</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查找关键字等于key的结点，找到则删除数据结点</span></span><br><span class=\"line\">Status <span class=\"title function_\">DeleteBST</span><span class=\"params\">(BiTree *T, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!T)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FLASE;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == T-&gt;data)\t\t\t\t\t\t<span class=\"comment\">/*找到关键字key的数据元素*/</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Delete(T);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; T-&gt;data)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DeleteBST(T-&gt;lchild, key);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"keyword\">return</span> DeleteBST(T-&gt;rchild, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码与二叉排序树查找几乎完全相同，区别在于找到后执行的是删除操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">Delete</span><span class=\"params\">(BiTree *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//从二叉排序树中删除结点p，并重接他的左右子树</span></span><br><span class=\"line\">    BiTree *q, *s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;rchild == <span class=\"literal\">NULL</span>)&#123;\t\t\t\t\t\t<span class=\"comment\">/*右子树空则重接左子树(叶子也走此分支)*/</span></span><br><span class=\"line\">        q = p;</span><br><span class=\"line\">        p = p-&gt;lchild;</span><br><span class=\"line\">        delete(q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p-&gt;lchild == <span class=\"literal\">NULL</span>)&#123;\t\t\t\t<span class=\"comment\">/*左子树空则重接右子树*/</span></span><br><span class=\"line\">        q = p;</span><br><span class=\"line\">        p = p-&gt;rchild;</span><br><span class=\"line\">        delete q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*左右均不空*/</span></span><br><span class=\"line\">        q = p;</span><br><span class=\"line\">        s = p-&gt;lchild;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s-&gt;rchild)&#123;\t\t\t\t\t\t<span class=\"comment\">/*找到左子树的右结点（找到待删结点的前驱）*/</span></span><br><span class=\"line\">            q = s;</span><br><span class=\"line\">            s = s-&gt;rchild;</span><br><span class=\"line\">        &#125;\t\t\t\t\t</span><br><span class=\"line\">        p-&gt;data = s-&gt;data;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q != p)</span><br><span class=\"line\">            q-&gt;rchild = s-&gt;lchild;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            q-&gt;lchild = s-&gt;lchild;</span><br><span class=\"line\">        delete s;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-平衡二叉树\"><a href=\"#6-平衡二叉树\" class=\"headerlink\" title=\"6.平衡二叉树\"></a>6.平衡二叉树</h2><p>平衡二叉树是一种二叉排序树，其中每个结点的左子树和右子树高度差至多为1</p>\n<p>是一种高度平衡的二叉排序树，二叉树上节点的左子树高度减去右子树高度的值称为<strong>平衡因子BF(Balance Factor)</strong></p>\n<p>那么平衡二叉树上所有结点的平衡因子只可能是1、0、-1</p>\n<p>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为<strong>最小不平衡树</strong></p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\n\tA1((A)) --- B1((B)) &amp; D1(( ))\n\tB1 --- C1((C)) &amp; E1(( ))\n\t%%style D fill:#f100,stroke-width:0px\n    %%style E fill:#f100,stroke-width:0px%% 设置F属性为填充为白色，边框宽度为0\n    linkStyle 1 stroke:#off, stroke-width:0px;\n    linkStyle 3 stroke:#off, stroke-width:0px;\n    \n    \n\tA2((A)) --- B2((B)) &amp; D2(( ))\n\tB2 --- C2(( )) &amp; E2((C))\n    linkStyle 5 stroke:#off, stroke-width:0px;\n    linkStyle 6 stroke:#off, stroke-width:0px;\n    \n    A3((A)) --- B3(( )) &amp; D3((B))\n\tD3 --- C3((C)) &amp; E3(( ))\n    linkStyle 8 stroke:#off, stroke-width:0px;\n    linkStyle 11 stroke:#off, stroke-width:0px;\n    \n    A4((A)) --- B4(( )) &amp; D4((B))\n\tD4 --- C4(( )) &amp; E4((C))\n    linkStyle 12 stroke:#off, stroke-width:0px;\n    linkStyle 14 stroke:#off, stroke-width:0px;\n    \n    class D1,E1,D2,C2,B3,E3,B4,C4 X;\n\tclassDef X fill:#f100, stroke-width:0px;\n  </pre></div>\n\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\tA1((B)) --- B1((C)) &amp; D1((A))\n\tA2((C)) --- B2((B)) &amp; D2((A))\n\tA3((C)) --- B3((A)) &amp; D3((B))\n\tA4((B)) --- B4((A)) &amp; D4((C))\n  </pre></div>\n\n<h3 id=\"6-1代码实现\"><a href=\"#6-1代码实现\" class=\"headerlink\" title=\"6.1代码实现\"></a>6.1代码实现</h3><p><strong>结点结构</strong></p>\n<p>增加一个变量<code>bf</code>用来存储平衡因子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>;</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    <span class=\"type\">int</span> bf;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>\n\n<p><strong>右旋操作</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对P为根的二叉排序树作右旋处理</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">R_Rotate</span><span class=\"params\">(BiTree *p)</span>&#123;</span><br><span class=\"line\">    BiTree *L;</span><br><span class=\"line\">    L = p-&gt;lchild;</span><br><span class=\"line\">    p-&gt;lchild = L-&gt;lchild;</span><br><span class=\"line\">    L-&gt;rchild = p;</span><br><span class=\"line\">    p = L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>左旋操作</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对P为根的二叉排序树作左旋处理</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">L_Rotate</span><span class=\"params\">(BiTree *p)</span>&#123;</span><br><span class=\"line\">    BiTree *R;</span><br><span class=\"line\">\tR = p-&gt;rchild;</span><br><span class=\"line\">    p-&gt;rchild = R-&gt;lchild;</span><br><span class=\"line\">    R-&gt;lchild = p;</span><br><span class=\"line\">    p = L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>左平衡旋转</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LH +1\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*左高*/</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EH 0\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*等高*/</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RH -1\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*右高*/</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LeftBalance</span><span class=\"params\">(BiTree *T)</span>&#123;</span><br><span class=\"line\">    BiTree *L, *Lr;</span><br><span class=\"line\">    L = T-&gt;lchild;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (L-&gt;bf)&#123;\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*检查T的左子树平衡度，并做相应处理*/</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> LH:\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*（LL）新结点插入在T的左孩子的左子树上，要作单右旋处理*/</span></span><br><span class=\"line\">            T-&gt;bf = L-&gt;bf =EH;</span><br><span class=\"line\">            R_Rotate(T);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RH:\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*新结点插入在T的左孩子的右子树上，要做双旋处理*/</span></span><br><span class=\"line\">            Lr =L-&gt;rchild;\t\t\t\t\t\t\t<span class=\"comment\">/*Lr指向T的左孩子的右子树根*/</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (Lr-&gt;bf)&#123;\t\t\t\t\t\t<span class=\"comment\">/*修改T及其左孩子的平衡因子*/</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> LH:</span><br><span class=\"line\">                    T-&gt;bf = RH;</span><br><span class=\"line\">                    L-&gt;bf = EH;</span><br><span class=\"line\">                 \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> EH:</span><br><span class=\"line\">                    T-&gt;bf = L-&gt;bf =EH;</span><br><span class=\"line\">                \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> RH:</span><br><span class=\"line\">                    T-&gt;bf = EH;</span><br><span class=\"line\">                    L-&gt;bf = LH;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Lr-&gt;bf =EH;</span><br><span class=\"line\">            L_Rotate(T-&gt;lchild);</span><br><span class=\"line\">            R_Rotate(T);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>右平衡旋转</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">RightBalance</span><span class=\"params\">(BiTree *T)</span>&#123;</span><br><span class=\"line\">    BiTree *R, *Rl;</span><br><span class=\"line\">    R = T-&gt;lchild;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (R-&gt;bf)&#123;\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*检查T的右子树平衡度，并做相应处理*/</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> RH:\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*（RR）新结点插入在T的右孩子的右子树上，要作单左旋处理*/</span></span><br><span class=\"line\">            T-&gt;bf = R-&gt;bf =EH;</span><br><span class=\"line\">            L_Rotate(T);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> LH:\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*新结点插入在T的右孩子的左子树上，要做双旋处理*/</span></span><br><span class=\"line\">            Rl =R-&gt;lchild;\t\t\t\t\t\t\t<span class=\"comment\">/*Rl指向T的右孩子的左子树根*/</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (Rl-&gt;bf)&#123;\t\t\t\t\t\t<span class=\"comment\">/*修改T及其右孩子的平衡因子*/</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> RH:</span><br><span class=\"line\">                    T-&gt;bf = LH;</span><br><span class=\"line\">                    R-&gt;bf = EH;</span><br><span class=\"line\">                 \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> EH:</span><br><span class=\"line\">                    T-&gt;bf = R&gt;bf =EH;</span><br><span class=\"line\">                \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> LH:</span><br><span class=\"line\">                    T-&gt;bf = EH;</span><br><span class=\"line\">                    R-&gt;bf = RH;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Rl-&gt;bf =EH;</span><br><span class=\"line\">            R_Rotate(T-&gt;rchild);</span><br><span class=\"line\">            L_Rotate(T);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"7-多路查找树（B树）\"><a href=\"#7-多路查找树（B树）\" class=\"headerlink\" title=\"7.多路查找树（B树）\"></a>7.多路查找树（B树）</h2><p><strong>多路查找树（Muiltl-Way Search Tree）</strong>，其每个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</p>\n<p>设置一个结点数据元素上限set a cap on the num of items</p>\n<p>如果超出上限，就将其中一个元素给双亲结点if more than cap, give an item to parent</p>\n<p><strong>left-middle</strong></p>\n<p>再将超出上限的结点分成左右两个结点</p>\n<h3 id=\"7-1-2-3树\"><a href=\"#7-1-2-3树\" class=\"headerlink\" title=\"7.1 2-3树\"></a>7.1 2-3树</h3><p>每个结点都有两个孩子或三个孩子</p>\n<p>一个2结点包含一个元素和两个孩子（或没有孩子）</p>\n<p>一个3结点包含一小一大两个元素和三个孩子（或没有孩子）</p>\n<h3 id=\"7-2-2-3-4树\"><a href=\"#7-2-2-3-4树\" class=\"headerlink\" title=\"7.2 2-3-4树\"></a>7.2 2-3-4树</h3><p>一个4结点包含小中大3个元素和4个孩子（或没有孩子）</p>\n<h3 id=\"7-3-B树\"><a href=\"#7-3-B树\" class=\"headerlink\" title=\"7.3 B树\"></a>7.3 B树</h3><p>**B树(B-tree)**是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例</p>\n<p>结点最大的孩子数目称为B树的阶</p>\n<h3 id=\"7-4-B-树\"><a href=\"#7-4-B-树\" class=\"headerlink\" title=\"7.4 B+树\"></a>7.4 B+树</h3><h2 id=\"8-散列表（哈希表）\"><a href=\"#8-散列表（哈希表）\" class=\"headerlink\" title=\"8.散列表（哈希表）\"></a>8.散列表（哈希表）</h2><h3 id=\"8-1定义\"><a href=\"#8-1定义\" class=\"headerlink\" title=\"8.1定义\"></a>8.1定义</h3><p>$存储位置 &#x3D; f (关键字)$</p>\n<p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系$f$,使得每个关键字key对应一个存储位置$f(key)$</p>\n<p>对应关系$f$称为<strong>散列函数</strong>，又称<strong>哈希(Hash)函数</strong></p>\n<p>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为<strong>散列表</strong>或<strong>哈希表(Hash Table)</strong></p>\n<p>散列技术既是一种存储方法，也是一种查找方法</p>\n<p>散列技术最适合的求解问题是查找与给定值相等的记录</p>\n<p>两个关键字$key_1 \\neq key_2$，但是却有$f(key_1) &#x3D; f(key)_2$，这种现象我们称为**冲突(collision)**，并把$key_1$和$key_2$称为这个函数的同义词(synonym)</p>\n<h3 id=\"8-2构造方法\"><a href=\"#8-2构造方法\" class=\"headerlink\" title=\"8.2构造方法\"></a>8.2构造方法</h3><p> 原则</p>\n<ol>\n<li>计算简单</li>\n<li>散列地址分布均匀</li>\n</ol>\n<p><strong>1.直接定址法</strong></p>\n<p>去关键字的某个线性函数值为散列地址</p>\n<p>$f(key) &#x3D; a * key + b$</p>\n<p><strong>2.数字分析法</strong></p>\n<p><strong>3.平方取中法</strong></p>\n<p><strong>4.折叠法</strong></p>\n<p><strong>5.除留余数法</strong></p>\n<p>f(key) &#x3D; key  mod  p</p>\n<p><strong>6.随机数法</strong></p>\n<h3 id=\"8-3处理散列冲突\"><a href=\"#8-3处理散列冲突\" class=\"headerlink\" title=\"8.3处理散列冲突\"></a>8.3处理散列冲突</h3><p><strong>1.开放定址法</strong></p>\n<p>开放定址法是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p>\n<p>公式是</p>\n<p>$f_i(key) &#x3D; (f(key)+d_i) MOD m$  $d_i &#x3D; 1, 2, 3, …, m-1$</p>\n<p><strong>线性探测法</strong></p>\n<p>本来就不为同义词却争夺同一地址的情况，称为<strong>堆积</strong></p>\n<p>$f_i(key) &#x3D; (f(key)+d_i) MOD m$  $d_i &#x3D; 1^2, -1^, 2^2, -2^2,…,q^2, -q^2, q\\leq m&#x2F;2$</p>\n<p>增加平方运算的目的是为了不让关键字都聚集在某一块区域，这种方法称为<strong>二次探测法</strong></p>\n<p><strong>2.再散列函数法</strong></p>\n<p>对于散列表，实现准备多个散列函数</p>\n<p>$f_i(key) &#x3D; RH_i(key)$</p>\n<p>这种方法可以使得关键字不产生聚集，相应增加了计算时间</p>\n<p><strong>3.链地址法</strong></p>\n<p>将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表</p>\n<p>在散列表中只存储所有同义词子表头指针，无论有多少冲突，都只是在当前位置给单链表增加节点的问题</p>\n<p>提供了不会出现找不到地址的保障，但查找时需要遍历单链表造成性能损耗</p>\n<p><strong>4.公共溢出区法</strong></p>\n<p>为所有冲突关键字建立一个公共溢出区来存放</p>\n<p>查找时，对给定值通过散列表计算出散列地址后，先于基本表的相应位置进行对比，相等则查找成功</p>\n<p>不相等，则到溢出表进行顺序查找</p>\n<p>相对于基本表而言，冲突数据较少的情况下，公共溢出区的结构对查找性能来说还是非常高的</p>\n<h3 id=\"8-4散列表查找的实现\"><a href=\"#8-4散列表查找的实现\" class=\"headerlink\" title=\"8.4散列表查找的实现\"></a>8.4散列表查找的实现</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SUCCESS 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UNSUCCESS 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HASHSIZE 12</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NULLKEY -32768</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *elem;\t\t\t\t<span class=\"comment\">/*数据元素存储基址，动态分配数组*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count;\t\t\t\t<span class=\"comment\">/*当前数据元素个数*/</span></span><br><span class=\"line\">&#125;HashTable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m = <span class=\"number\">0</span>;\t\t\t\t\t<span class=\"comment\">/*散列表表长，全局变量*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化散列表</span></span><br><span class=\"line\">Status <span class=\"title function_\">InitHashTable</span><span class=\"params\">(HashTable *H)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    m = HASHSIZE;</span><br><span class=\"line\">    H-&gt;count = m;</span><br><span class=\"line\">    H-&gt;elem = new <span class=\"type\">int</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        H-&gt;elem[i] = NULLKEY；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//散列函数</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Hash</span><span class=\"params\">(<span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key % m;        <span class=\"comment\">/*除留余数法*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入关键字进散列表</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InsertHash</span><span class=\"params\">(HashTable *H, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> addr = Hash(key);\t\t\t\t<span class=\"comment\">/*求散列地址*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (H-&gt;elem[addr] != NULLKEY)&#123;\t<span class=\"comment\">/*若不为空，则冲突*/</span></span><br><span class=\"line\">        addr = (addr + <span class=\"number\">1</span>) % m;\t\t\t<span class=\"comment\">/*开放定址法的线性探测*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    H-&gt;elem[addr] = key;\t\t\t\t<span class=\"comment\">/*直到有空位后插入关键字*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//散列表查找关键字</span></span><br><span class=\"line\">Status <span class=\"title function_\">SearchHash</span><span class=\"params\">(HashTable H, <span class=\"type\">int</span> key, <span class=\"type\">int</span> *addr)</span>&#123;</span><br><span class=\"line\">    *addr = Hash(key);\t\t\t\t\t<span class=\"comment\">/*求散列地址*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (H.elem[*addr] != key)&#123;\t\t</span><br><span class=\"line\">        *addr = (*addr + <span class=\"number\">1</span>) % m;\t\t<span class=\"comment\">/*开放定址法的线性探测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key))\t\t<span class=\"comment\">/*若循环回到原点*/</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> UNSUCCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><p>优秀排序算法的首要条件就是<strong>速度</strong></p>\n<h2 id=\"1-基本概念与分类\"><a href=\"#1-基本概念与分类\" class=\"headerlink\" title=\"1.基本概念与分类\"></a>1.基本概念与分类</h2><p><strong>1.排序的稳定性</strong></p>\n<p>假设$k_i &#x3D; k_j$，且在排序前的序列中$r_i$领先与$r_j$即（$i &lt; j$）</p>\n<p>如果排序后$r_i$仍领先与$r_j$，则称所用的排序方法是稳定的；</p>\n<p>反之，若可能使得排序后的序列中$r_j$领先与$r_i$，则称所用的排序的方法是不稳定的</p>\n<p><strong>2.内排序与外排序</strong></p>\n<p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中</p>\n<p>外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行</p>\n<h2 id=\"2-结构与函数\"><a href=\"#2-结构与函数\" class=\"headerlink\" title=\"2.结构与函数\"></a>2.结构与函数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 1000</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> r[MAXSIZE + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//交换L中数组r的下标为i和j的值</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> temp = L-&gt;r[i];</span><br><span class=\"line\">    L-&gt;r[i] = L-&gt;r[j];</span><br><span class=\"line\">    L-&gt;r[j]\t= temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-冒泡排序\"><a href=\"#3-冒泡排序\" class=\"headerlink\" title=\"3.冒泡排序\"></a>3.冒泡排序</h2><p>冒泡排序是一种交换排序，最基本的思想是两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表进行冒泡排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BubbleSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; L-&gt;length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = L-&gt;length - <span class=\"number\">1</span>; j &gt;= i; j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (L-&gt;r[j - <span class=\"number\">1</span>] &gt; L-&gt;r[j])</span><br><span class=\"line\">                swap(L, j<span class=\"number\">-1</span>, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>冒泡排序优化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//改进</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BubbleSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"comment\">/////////</span></span><br><span class=\"line\">    Status flag = TRUE;</span><br><span class=\"line\">    <span class=\"comment\">/////////</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; L-&gt;length &amp;&amp; flag; i++)&#123;</span><br><span class=\"line\">        flag = FALSE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = L-&gt;length - <span class=\"number\">1</span>; j &gt;= i; j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (L-&gt;r[j - <span class=\"number\">1</span>] &gt; L-&gt;r[j])&#123;</span><br><span class=\"line\">                swap(L, j<span class=\"number\">-1</span>, j);</span><br><span class=\"line\">                flag = TRUE;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总的时间复杂度为O($n^2$)</strong></p>\n<h2 id=\"4-简单选择排序\"><a href=\"#4-简单选择排序\" class=\"headerlink\" title=\"4.简单选择排序\"></a>4.简单选择排序</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L作简单选择排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SelectSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, min;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; L-&gt;length; i++)&#123;</span><br><span class=\"line\">        min = i;\t\t\t\t\t\t\t\t<span class=\"comment\">/*当前下标定义为最小值*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt;= L-&gt;length; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (L-&gt;r[min] &gt; L-&gt;r[j])\t\t\t<span class=\"comment\">/*如果有小于当前最小值的关键字，将此关键字下标赋值给min*/</span></span><br><span class=\"line\">                min = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != min)\t\t\t\t\t\t\t<span class=\"comment\">/*若min不等于i，说明找到最小值，交换*/</span></span><br><span class=\"line\">            swap(L, i, min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度为O($n^2$)</strong></p>\n<p>性能上略优于冒泡排序</p>\n<h2 id=\"5-直接插入排序\"><a href=\"#5-直接插入排序\" class=\"headerlink\" title=\"5.直接插入排序\"></a>5.直接插入排序</h2><p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L作直接插入排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InsertSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= L-&gt;length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class=\"number\">1</span>])&#123;\t\t\t\t<span class=\"comment\">/*将L-&gt;r[i]插入有序子表*/</span></span><br><span class=\"line\">            L-&gt;r[<span class=\"number\">0</span>] = L-&gt;r[i];\t\t\t\t\t<span class=\"comment\">/*设置哨兵*/</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i - <span class=\"number\">1</span>; L-&gt;r[j] &gt; L-&gt;r[<span class=\"number\">0</span>]; j--)</span><br><span class=\"line\">                L-&gt;r[j + <span class=\"number\">1</span>] = L-&gt;r[j];\t\t\t<span class=\"comment\">/*记录后移*/</span></span><br><span class=\"line\">            L-&gt;r[j + <span class=\"number\">1</span>] = L-&gt;r[<span class=\"number\">0</span>];\t\t\t\t<span class=\"comment\">/*插入到正确位置*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度为O($n^2$)</strong></p>\n<p>性能上略优于冒泡排序和简单选择排序</p>\n<h2 id=\"6-希尔排序\"><a href=\"#6-希尔排序\" class=\"headerlink\" title=\"6.希尔排序\"></a>6.希尔排序</h2><p>(shell Sort)</p>\n<p><strong>基本有序</strong>：小的关键字基本在前面，大的基本在后面，不大不小的基本在中间</p>\n<p>将相距某个”增量“的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//希尔排序算法</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ShellSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> increment = L-&gt;length;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        increment = increment/<span class=\"number\">3</span> + <span class=\"number\">1</span>;\t\t\t\t\t<span class=\"comment\">/*增量序列*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = increment + <span class=\"number\">1</span>; i &lt;= L-&gt;length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - increment])&#123;\t\t\t<span class=\"comment\">/*需将L-&gt;[i]插入有序增量子表*/</span></span><br><span class=\"line\">                L-&gt;r[<span class=\"number\">0</span>] = L-&gt;r[i];\t\t\t\t\t\t<span class=\"comment\">/*暂存在L-&gt;r[0]*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (j = i - increment; j &gt; <span class=\"number\">0</span> &amp;&amp; L-&gt;r[<span class=\"number\">0</span>] &lt; L-&gt;r[j]; j -= increment)</span><br><span class=\"line\">                    L-&gt;r[j + increment] = L-&gt;r[j];\t\t<span class=\"comment\">/*记录后移，查找插入位置*/</span></span><br><span class=\"line\">                L-&gt;r[j + increment] = L-&gt;r[<span class=\"number\">0</span>];\t\t\t<span class=\"comment\">/*插入*/</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span> (increment &gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>增量序列最后一个增量值必须等于1</strong></p>\n<p>时间复杂度O($n^\\frac{3}{2}$)</p>\n<h2 id=\"7-堆排序\"><a href=\"#7-堆排序\" class=\"headerlink\" title=\"7.堆排序\"></a>7.堆排序</h2><p>堆是具有下列性质的二叉树：</p>\n<ul>\n<li>每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong></li>\n<li>或者每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L进行堆排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HeapSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = L-&gt;length/<span class=\"number\">2</span>; i &gt; <span class=\"number\">0</span>; i--)\t\t\t\t\t<span class=\"comment\">/*构造大顶堆*/</span></span><br><span class=\"line\">        HeapAdjust(L, i, L-&gt;length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = L-&gt;length; i &gt; <span class=\"number\">1</span>; i--)&#123;\t\t\t\t\t</span><br><span class=\"line\">        swap(L, <span class=\"number\">1</span>, i);\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*将堆顶记录和当前未经排序子序列最后一记录交换*/</span></span><br><span class=\"line\">        HeapAdjust(L, <span class=\"number\">1</span>, i - <span class=\"number\">1</span>);\t\t\t\t\t\t<span class=\"comment\">/*将L-&gt;r[1..i - 1]重新调整为大顶堆*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//堆调整</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HeapAdjust</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> s, <span class=\"type\">int</span> m)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> temp, j;</span><br><span class=\"line\">    temp = L-&gt;r[s];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">2</span> * s; j &lt;= m; j *= <span class=\"number\">2</span>)&#123;\t\t\t\t\t<span class=\"comment\">/*沿关键字较大的孩子结点向下筛选*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">            ++j;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*j为关键字中较大的记录的下标*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp &gt;= L-&gt;r[j])</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*rc应插入在位置s上*/</span></span><br><span class=\"line\">        L-&gt;r[s] = L-&gt;r[j];</span><br><span class=\"line\">        s = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;r[s] = temp;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*插入*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排序</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = L-&gt;lenth; i &gt; <span class=\"number\">1</span>; i--)&#123;</span><br><span class=\"line\">    swap(L, <span class=\"number\">1</span>, i);</span><br><span class=\"line\">    HeapAdjust(L, <span class=\"number\">1</span>, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>时间复杂度O(nlogn)</strong></p>\n<p>记录的比较是跳跃式进行，所以堆排序是一种不稳定的排序方法</p>\n<p>初始构建堆所需要的次数较多，不适合待排序序列个数较少情况</p>\n<h2 id=\"8-归并排序\"><a href=\"#8-归并排序\" class=\"headerlink\" title=\"8.归并排序\"></a>8.归并排序</h2><p><strong>归并排序（Merging Sort）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L作归并排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MergeSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    Msort(L-&gt;r, L-&gt;r, <span class=\"number\">1</span>, L-&gt;length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MSort</span><span class=\"params\">(<span class=\"type\">int</span> SR[], <span class=\"type\">int</span> TR1[], <span class=\"type\">int</span> s, <span class=\"type\">int</span> t)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m;</span><br><span class=\"line\">    <span class=\"type\">int</span> TR2[MAXSIZE + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == t)&#123;</span><br><span class=\"line\">        TR1[s] = SR[s];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;\t</span><br><span class=\"line\">        m = (s + t) / <span class=\"number\">2</span>;\t\t\t\t\t<span class=\"comment\">/*将SR[s..t]平分为SR[s..m]和s[m+1..t]*/</span></span><br><span class=\"line\">        MSort(SR, TR2, s, m);\t\t\t\t<span class=\"comment\">/*将SR[s..m]归并为有序序列TR2[s..m]*/</span></span><br><span class=\"line\">        MSort(SR, TR2, m + <span class=\"number\">1</span>, t);\t\t\t<span class=\"comment\">/*将SR[m+1..t]归并为有序序列TR2[m+1..t]*/</span></span><br><span class=\"line\">        Merge(SR, TR2, s, m, t);\t\t\t<span class=\"comment\">/*将TR2[s..m]和TR2[m+1..t]归并到TR1[s..m]*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将SR[s..m]和SR[m+1..t]归并到TR[s..m]</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Merge</span><span class=\"params\">(<span class=\"type\">int</span> SR[], <span class=\"type\">int</span> TR[], <span class=\"type\">int</span> i, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j, k, l;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = m + <span class=\"number\">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)&#123;\t\t\t<span class=\"comment\">/*将SR中记录由小到大并入TR*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SR[i] &lt; SR[J])</span><br><span class=\"line\">            TR[k] = SR[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            TR[k] = SR[j++];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= m)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (l = <span class=\"number\">0</span>; l &lt;= m - i; l++)</span><br><span class=\"line\">                TR[k + l] = SR[i + l];\t\t\t\t\t\t<span class=\"comment\">/*将剩余SR[i..m]复制到TR*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt;= n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (l = <span class=\"number\">0</span>; l &lt;= n - j; l++)</span><br><span class=\"line\">                TR[k + l] = SR[j + l];\t\t\t\t\t\t<span class=\"comment\">/*将剩余SR[j..n]复制到TR*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度O(nlogn)</strong></p>\n<p>归并排序是一种稳定的排序算法，比较占用内存，但效率高且稳定</p>\n<h2 id=\"9-快速排序\"><a href=\"#9-快速排序\" class=\"headerlink\" title=\"9.快速排序\"></a>9.快速排序</h2><p><strong>快速排序（Quick Sort）</strong>的基本思想是：通过一趟排序将待排记录分割成独立的两部分</p>\n<p>其中一部分记录的关键字比另一部分小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L作快速排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">QuickSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    QSort(L, <span class=\"number\">1</span>, L-&gt;length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L中子序列L-&gt;r[low..high]作快速排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">QSort</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivot;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将L-&gt;r[low..high]一分为二，算出枢轴值pivot</span></span><br><span class=\"line\">        pivot = Partition(L, low, high);</span><br><span class=\"line\">        QSort(L, low, pivot - <span class=\"number\">1</span>);\t\t\t<span class=\"comment\">/*对低子表递归排序*/</span></span><br><span class=\"line\">        QSort(L, pivot + <span class=\"number\">1</span>, high);\t\t\t<span class=\"comment\">/*对高子表递归排序*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Patition（）要做的，就是选取当中一个关键字，想尽办法将它放到一个位置</p>\n<p>使得它左边的值都比它小，右边的值都比它大，这样的关键词称为枢轴(Pivot)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Patition</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivotkey;</span><br><span class=\"line\">    pivotkey = L-&gt;r[low];\t\t\t\t<span class=\"comment\">/*用子表的第一个记录作枢轴记录*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high)&#123;\t\t\t\t\t<span class=\"comment\">/*从表的两端交替地向中间扫描*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &gt;= pivotkey)</span><br><span class=\"line\">            high--;</span><br><span class=\"line\">        swap(L, low, high);\t\t\t\t<span class=\"comment\">/*将比枢轴记录小的记录交换到低端*/</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class=\"line\">            low++;</span><br><span class=\"line\">        swap(L, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;\t\t\t\t\t\t\t<span class=\"comment\">/*返回枢轴所在位置*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度O($n^2$)</strong></p>\n<p>由于关键字比较和交换是跳跃进行，因此快速排序是一种不稳定排序</p>\n<h4 id=\"快速排序优化\"><a href=\"#快速排序优化\" class=\"headerlink\" title=\"快速排序优化\"></a><strong>快速排序优化</strong></h4><h5 id=\"1-优化选取枢轴\"><a href=\"#1-优化选取枢轴\" class=\"headerlink\" title=\"1.优化选取枢轴\"></a>1.优化选取枢轴</h5><ul>\n<li>固定选取（原）</li>\n<li>随机选取</li>\n<li>三数取中</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> pivotkey;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (L-&gt;r[low] &gt; L -&gt;r[high])</span><br><span class=\"line\">    swap(L, low, high);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (L-&gt;r[m] &gt; L -&gt;r[high])</span><br><span class=\"line\">    swap(L, m, high);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (L-&gt;r[low] &gt; L -&gt;r[m])</span><br><span class=\"line\">    swap(L, low, high);</span><br><span class=\"line\"><span class=\"comment\">//此时，r[low]已经为整个序列左、中、右三个关键字的中间值</span></span><br><span class=\"line\"></span><br><span class=\"line\">pivokey = L-&gt;r[low];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>九数取中</li>\n</ul>\n<h5 id=\"2-优化不必要的交换\"><a href=\"#2-优化不必要的交换\" class=\"headerlink\" title=\"2.优化不必要的交换\"></a>2.优化不必要的交换</h5><p>&#x3D;&#x3D;<code>L-&gt;r[0] = pivotkey</code>&#x3D;&#x3D;</p>\n<p>采用替换而不是交换的方式进行操作</p>\n<p>L-&gt;r[low] &#x3D; L-&gt;r[high]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Patition</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivotkey;</span><br><span class=\"line\">    pivotkey = L-&gt;r[low];\t\t\t\t<span class=\"comment\">/*用子表的第一个记录作枢轴记录*/</span></span><br><span class=\"line\">    L-&gt;r[<span class=\"number\">0</span>] = pivotkey</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high)&#123;\t\t\t\t\t<span class=\"comment\">/*从表的两端交替地向中间扫描*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &gt;= pivotkey)</span><br><span class=\"line\">            high--;</span><br><span class=\"line\">        L-&gt;r[low] = L-&gt;r[high]\t\t\t<span class=\"comment\">/*采用替换而不是交换的方式进行操作*/</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class=\"line\">            low++;</span><br><span class=\"line\">        L-&gt;r[high] = L-&gt;r[low]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;r[low] = L-&gt;r[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;\t\t\t\t\t\t\t<span class=\"comment\">/*返回枢轴所在位置*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-优化小数组时的排序方案\"><a href=\"#3-优化小数组时的排序方案\" class=\"headerlink\" title=\"3.优化小数组时的排序方案\"></a>3.优化小数组时的排序方案</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_LENGTH_INSERT_SORT 7</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">QSort</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivot;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)&#123;</span><br><span class=\"line\">        ......\t\t\t\t\t\t\t<span class=\"comment\">/*采用快速排序*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        InsertSort(L);\t\t\t\t\t<span class=\"comment\">/*直接用插入排序*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"4-优化递归操作\"><a href=\"#4-优化递归操作\" class=\"headerlink\" title=\"4.优化递归操作\"></a>4.优化递归操作</h5><h2 id=\"10-总结对比\"><a href=\"#10-总结对比\" class=\"headerlink\" title=\"10.总结对比\"></a>10.总结对比</h2><table>\n<thead>\n<tr>\n<th align=\"center\">排序方法</th>\n<th align=\"center\">平均情况</th>\n<th align=\"center\">最好情况</th>\n<th align=\"center\">最坏情况</th>\n<th align=\"center\">辅助空间</th>\n<th align=\"center\">稳定性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">冒泡排序</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($n$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">简单选择排序</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">直接插入排序</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($n)$</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">希尔排序</td>\n<td align=\"center\">O($n\\log{n}$)~O($n^2$)</td>\n<td align=\"center\">O($n^\\frac{3}{2}$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">堆排序</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">归并排序</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">快速排序</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($\\log{n}$)~O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n</tbody></table>\n<ul>\n<li>简单算法：冒泡、简单选择、直接插入</li>\n<li>改进算法：希尔、堆、归并、快速</li>\n</ul>\n<p>从<strong>平均情况</strong>看，最后三种改进算法胜过希尔排序，并远胜于3钟简单算法</p>\n<p>从<strong>最好情况</strong>看，冒泡和直接插入排序更胜一筹。如果待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法</p>\n<p>从<strong>最坏情况</strong>看，堆排序与归并排序强于快速排序及其他简单排序</p>\n<p>从<strong>稳定性</strong>看，归并排序独占鳌头，对非常在乎排序稳定性的应用中，归并排序是个好算法</p>\n<p>从<strong>待排序记录的个数</strong>上看，待排序的个数越小，采用简单排序方法就越合适</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h1><h2 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h2><h3 id=\"1-数据\"><a href=\"#1-数据\" class=\"headerlink\" title=\"1.数据\"></a>1.数据</h3><p>能输入计算机且能被计算机处理的各种符号的集合</p>\n<p>1）数值型数据：整数、实数等</p>\n<p>2）非数值型数据：文字、图像、声音等</p>\n<h3 id=\"2-数据元素\"><a href=\"#2-数据元素\" class=\"headerlink\" title=\"2.数据元素\"></a>2.数据元素</h3><p>数据的基本单位</p>\n<p>也称为元素、记录或结点</p>\n<p>例：  学号    姓名     专业      性别</p>\n<p>​           123    张三     电子      男</p>\n<h3 id=\"3-数据项\"><a href=\"#3-数据项\" class=\"headerlink\" title=\"3.数据项\"></a>3.数据项</h3><p>构成数据元素的不可分割的最小单位</p>\n<p>例：学号</p>\n<h3 id=\"三者关系\"><a href=\"#三者关系\" class=\"headerlink\" title=\"三者关系\"></a>三者关系</h3><p>数据&gt;数据元素&gt;数据项</p>\n<h3 id=\"4-数据对象\"><a href=\"#4-数据对象\" class=\"headerlink\" title=\"4.数据对象\"></a>4.数据对象</h3><p>性质相同的数据元素的集合，是数据的一个子集</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"**数据结构\"></a>**数据结构</h2><p>数据元素相互之间的关系称为结构</p>\n<h3 id=\"1-逻辑结构\"><a href=\"#1-逻辑结构\" class=\"headerlink\" title=\"1.逻辑结构\"></a>1.逻辑结构</h3><h4 id=\"1-集合结构\"><a href=\"#1-集合结构\" class=\"headerlink\" title=\"1.集合结构\"></a>1.集合结构</h4><h4 id=\"2-线性结构\"><a href=\"#2-线性结构\" class=\"headerlink\" title=\"2.线性结构\"></a>2.线性结构</h4><h4 id=\"3-树形结构\"><a href=\"#3-树形结构\" class=\"headerlink\" title=\"3.树形结构\"></a>3.树形结构</h4><h4 id=\"4-图形结构\"><a href=\"#4-图形结构\" class=\"headerlink\" title=\"4.图形结构\"></a>4.图形结构</h4><h3 id=\"2-物理结构或存储结构\"><a href=\"#2-物理结构或存储结构\" class=\"headerlink\" title=\"2.物理结构或存储结构\"></a>2.物理结构或存储结构</h3><p>数据元素及其关系在计算机内存中的表示</p>\n<h4 id=\"1-顺序存储结构\"><a href=\"#1-顺序存储结构\" class=\"headerlink\" title=\"1.顺序存储结构\"></a>1.顺序存储结构</h4><h4 id=\"2-链式存储结构\"><a href=\"#2-链式存储结构\" class=\"headerlink\" title=\"2.链式存储结构\"></a>2.链式存储结构</h4><hr>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"1-时间复杂度\"><a href=\"#1-时间复杂度\" class=\"headerlink\" title=\"1.时间复杂度\"></a>1.时间复杂度</h3><p>&#x3D;&#x3D;O(1) &lt; O(log n) &lt; O(n) &lt; O(n*log n) &lt; O(n²) &lt; O(n³) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)&#x3D;&#x3D;</p>\n<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><p>零个或者多个数据元素的有限序列</p>\n<p>线性表中，一个数据元素可以由若干个数据项组成</p>\n<h2 id=\"1-顺序存储结构-1\"><a href=\"#1-顺序存储结构-1\" class=\"headerlink\" title=\"1.顺序存储结构\"></a>1.顺序存储结构</h2><h3 id=\"1-顺序存储定义\"><a href=\"#1-顺序存储定义\" class=\"headerlink\" title=\"1.顺序存储定义\"></a>1.顺序存储定义</h3><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表数据的元素。</p>\n<h3 id=\"2-顺序存储方式\"><a href=\"#2-顺序存储方式\" class=\"headerlink\" title=\"2.顺序存储方式\"></a>2.顺序存储方式</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType data[MAXSIZE];</span><br><span class=\"line\">\t<span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;Sqlist;</span><br></pre></td></tr></table></figure>\n\n<p>需要三个属性：  1.存储空间的起始位置 ： 数据data ,他的存储位置就是存储空间的存储位置</p>\n<p>​\t\t\t\t\t\t\t 2.线性表的最大存储容量：数组长度MAXSIZE</p>\n<p>​\t\t\t\t\t\t\t 3.线性表的当前长度：length</p>\n<h3 id=\"3-线性表顺序存储结构的优缺点\"><a href=\"#3-线性表顺序存储结构的优缺点\" class=\"headerlink\" title=\"3.线性表顺序存储结构的优缺点\"></a>3.线性表顺序存储结构的优缺点</h3><p>优点：无需为表中元素之间的逻辑关系而增加额外的存储空间</p>\n<p>​\t\t\t可以快速地存取表中的任一位置的元素</p>\n<p>缺点：插入和删除操作需要移动大量元素</p>\n<p>​\t\t    当线性表长度变化较大时，难以确定存储空间的容量</p>\n<p>​\t\t\t造成存储空间的“碎片”</p>\n<h2 id=\"2-链式存储结构-1\"><a href=\"#2-链式存储结构-1\" class=\"headerlink\" title=\"2.链式存储结构\"></a>2.链式存储结构</h2><h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h3><p>n个结点（a<sub>i</sub>的存储映像）链结成一个链表，即为线性表（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>）的链式存储结构</p>\n<p><strong>a<sub>i</sub>的存储映像</strong>：1.数据域 </p>\n<p>​\t\t\t\t\t\t   2.指针域</p>\n<p><strong>头指针</strong>：链表中第一个结点的存储位置</p>\n<p><del>最后一个结点指向空结点NULL</del></p>\n<h3 id=\"2-头指针、头结点的异同\"><a href=\"#2-头指针、头结点的异同\" class=\"headerlink\" title=\"2.头指针、头结点的异同\"></a>2.头指针、头结点的异同</h3><p><strong>头指针</strong>：1.头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</p>\n<p>​\t\t\t\t2.头指针具有标志作用，所以常用头指针冠以链表的名字</p>\n<p>​\t\t\t\t3.无论链表是否为空，头指针均不为空。头指针是链表的必要元素</p>\n<p><strong>头结点</strong>：1.头结点是为了操作的统一和方标而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</p>\n<p>​\t\t\t\t2.有了头结点，对在第一元素结点之前插入结点和删除第一节点，其操作与其他结点的操作就统一了</p>\n<p>​\t\t\t\t3.头节点不一定就是链表的必需要素</p>\n<h3 id=\"3-链表存储方式\"><a href=\"#3-链表存储方式\" class=\"headerlink\" title=\"3.链表存储方式\"></a>3.链表存储方式</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*线性表的单链表存储结构*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Node;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">LinkList</span>;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p> 对于插入或者删除数据越频繁的操作，单链表的效率优势就越明显 </p>\n<h3 id=\"4-单链表结构与顺序存储结构的优缺点\"><a href=\"#4-单链表结构与顺序存储结构的优缺点\" class=\"headerlink\" title=\"4.单链表结构与顺序存储结构的优缺点\"></a>4.单链表结构与顺序存储结构的优缺点</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>顺序存储方式</th>\n<th>单链表结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储分配方式</td>\n<td>用一段连续存储单元依次存储线性表的数据元素</td>\n<td>采用链式存储结构，用一组任意的存储单元存放线性表的元素</td>\n</tr>\n<tr>\n<td>时间性能</td>\n<td>查找：O（1）</td>\n<td>查找：O（n）</td>\n</tr>\n<tr>\n<td></td>\n<td>插入和删除：O（n）</td>\n<td>插入和删除：O（1）</td>\n</tr>\n<tr>\n<td>空间性能</td>\n<td>需要预分配存储空间</td>\n<td>不需要分配存储空间</td>\n</tr>\n</tbody></table>\n<p><strong>线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构</strong></p>\n<p><strong>线性表中的元素个数变化较大或者不知道有多大时，最好用单链表结构</strong></p>\n<h3 id=\"5-循环链表\"><a href=\"#5-循环链表\" class=\"headerlink\" title=\"5.循环链表\"></a>5.循环链表</h3><h3 id=\"6-双向链表\"><a href=\"#6-双向链表\" class=\"headerlink\" title=\"6.双向链表\"></a>6.双向链表</h3><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱节点的指针域</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n A((线性表)) --- B1 &amp; C1\n B1(顺序存储结构)\n C1(链式存储结构) --- D1(单链表) &amp; D2(静态链表) &amp; D3(循环链表) &amp; D4(双向链表)\n  </pre></div>\n\n\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h4 id=\"1-栈的定义\"><a href=\"#1-栈的定义\" class=\"headerlink\" title=\"1.栈的定义\"></a>1.栈的定义</h4><p><strong>栈(stack)是限定仅在表尾进行插入和删除操作的线性表</strong></p>\n<p>允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。</p>\n<p>栈又称为后进后出(Last In First Out)的线性表，简称LIFO结构</p>\n<h4 id=\"2-栈的顺序存储结构及实现\"><a href=\"#2-栈的顺序存储结构及实现\" class=\"headerlink\" title=\"2.栈的顺序存储结构及实现\"></a>2.栈的顺序存储结构及实现</h4><p>顺序栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType data[MAXSIZE]；</span><br><span class=\"line\">\t<span class=\"type\">int</span> top;   <span class=\"comment\">/* 用于栈顶指针*/</span></span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-两栈共享空间\"><a href=\"#3-两栈共享空间\" class=\"headerlink\" title=\"3.两栈共享空间\"></a>3.两栈共享空间</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tElemType data[MAXSIZE]；</span><br><span class=\"line\">\t<span class=\"type\">int</span> top1;   <span class=\"comment\">/* 用于栈1栈顶指针*/</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> top2;   <span class=\"comment\">/* 用于栈2栈顶指针*/</span></span><br><span class=\"line\">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用这样的数据结构通常是两个栈的空间需求有相反关系，比如股票，买入时，一定是有人在卖出</p>\n<p>如果是不相同数据类型的栈，这种方法不但不能更好的处理问题，反而会使问题变得更复杂。</p>\n<h4 id=\"4-栈的链式存储结构及实现\"><a href=\"#4-栈的链式存储结构及实现\" class=\"headerlink\" title=\"4.栈的链式存储结构及实现\"></a>4.栈的链式存储结构及实现</h4><p>链栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span>&#123;</span></span><br><span class=\"line\">\tSElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;StackNode, *LinkStackPtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\tLinkStackPtr top;</span><br><span class=\"line\">\t<span class=\"type\">int</span> count;</span><br><span class=\"line\">&#125;LinkStack;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-栈的应用\"><a href=\"#5-栈的应用\" class=\"headerlink\" title=\"5.栈的应用\"></a>5.栈的应用</h4><h5 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1.递归\"></a>1.递归</h5><h6 id=\"1-递归的定义\"><a href=\"#1-递归的定义\" class=\"headerlink\" title=\"1.递归的定义\"></a>1.递归的定义</h6><p>一个直接调用自己或者通过一系列的调用语句间接调用自己的函数</p>\n<p>每个递归定义必须至少又一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>\n<p>简单地说，在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。</p>\n<p>在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是回复了调用的状态</p>\n<h5 id=\"2-四则运算\"><a href=\"#2-四则运算\" class=\"headerlink\" title=\"2.四则运算\"></a>2.四则运算</h5><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"1-队列的定义\"><a href=\"#1-队列的定义\" class=\"headerlink\" title=\"1.队列的定义\"></a>1.队列的定义</h3><p>队列(queue)是只允许在一段进行插入操作，而在另一端进行删除操作的线性表</p>\n<p>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一段为队尾，允许删除的一端称为队头</p>\n<h3 id=\"2-队列顺序存储\"><a href=\"#2-队列顺序存储\" class=\"headerlink\" title=\"2.队列顺序存储\"></a>2.队列顺序存储</h3><p>问题：“假溢出”</p>\n<p>解决办法：循环队列</p>\n<p><strong>队列头尾相连的顺序存储结构称为循环队列</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tQElemType data[MAXSIZE];</span><br><span class=\"line\">\t<span class=\"type\">int</span> front;\t\t\t\t<span class=\"comment\">/*头指针*/</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> rear;\t\t\t\t<span class=\"comment\">/*尾指针，若队列不空，指向队列尾元素的下一个位置*/</span></span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-队列链式存储\"><a href=\"#3-队列链式存储\" class=\"headerlink\" title=\"3.队列链式存储\"></a>3.队列链式存储</h3><p>队列的链式存储，就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span>&#123;</span>     <span class=\"comment\">/*结点结构*/</span></span><br><span class=\"line\">    QElemtype data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>           <span class=\"comment\">/*队列链表结构*/</span></span><br><span class=\"line\">    QueuePtr front, rear; <span class=\"comment\">/*队头、队尾指针*/</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h1><h2 id=\"1-串的定义\"><a href=\"#1-串的定义\" class=\"headerlink\" title=\"1.串的定义\"></a>1.串的定义</h2><p>串(string)是由零个或多个字符组成的有限序列，又叫字符串</p>\n<h2 id=\"2-串的存储结构\"><a href=\"#2-串的存储结构\" class=\"headerlink\" title=\"2.串的存储结构\"></a>2.串的存储结构</h2><h3 id=\"2-1顺序存储结构\"><a href=\"#2-1顺序存储结构\" class=\"headerlink\" title=\"2.1顺序存储结构\"></a>2.1顺序存储结构</h3><h3 id=\"2-2链式存储结构\"><a href=\"#2-2链式存储结构\" class=\"headerlink\" title=\"2.2链式存储结构\"></a>2.2链式存储结构</h3><p>总的来说不如顺序存储灵活，也不如顺序存储结构好</p>\n<h2 id=\"3-模式匹配算法\"><a href=\"#3-模式匹配算法\" class=\"headerlink\" title=\"3.模式匹配算法\"></a>3.模式匹配算法</h2><p><strong>字串的定位操作通常称做串的模式匹配</strong></p>\n<p>n为主串长度、m为要匹配的子串长度</p>\n<p>最好情况：一开始就匹配成功，比如”googlegood”中找”google”，时间复杂度为O(m)</p>\n<p>稍差一些：每次首字母不匹配，比如”abcdefgoogle”中找”google”，时间复杂度为O(n+m)</p>\n<p>最坏情况：每次匹配不成功都发生在最后一个位置，比如”0000000000000000000000000001”中找”0000001”，时间复杂度为O((n-m+1)*m)</p>\n<p><strong>低效</strong></p>\n<h4 id=\"3-1-KMP模式匹配算法\"><a href=\"#3-1-KMP模式匹配算法\" class=\"headerlink\" title=\"3.1 KMP模式匹配算法\"></a>3.1 KMP模式匹配算法</h4><p>思想：</p>\n<p>代码实现：1.初始化</p>\n<p>​\t\t\t\t\t2.前后缀相同情况</p>\n<p>​\t\t\t\t\t3.前后缀不同情况</p>\n<p>​\t\t\t\t\t4.更新next值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">get_Next</span><span class=\"params\">(*next, s)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*i 后缀末尾 、 j 前缀末尾【也指i之前（包括i）最长相等前后缀长度】*/</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    j = <span class=\"number\">0</span>;\t\t<span class=\"comment\">/*前缀从最开始的位置开始*/</span></span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; s.size(); i++)&#123;\t<span class=\"comment\">/*i要从位置1开始*/</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//前后缀不同情况</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; s[i] != s[j])  <span class=\"comment\">/*不能写成if*/</span></span><br><span class=\"line\">            j = next[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//前后缀相同情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i] == s[j])</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//更新next值</span></span><br><span class=\"line\">        next[i] = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-改进的KMP算法\"><a href=\"#3-2-改进的KMP算法\" class=\"headerlink\" title=\"3.2 改进的KMP算法\"></a>3.2 改进的KMP算法</h4><p>代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">get_nextval</span><span class=\"params\">(*nextval, s)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; T[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || T[i] = T[k])&#123;</span><br><span class=\"line\">             ++i;</span><br><span class=\"line\">             ++j;</span><br><span class=\"line\">            <span class=\"comment\">//区别如下</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (T[i] != T[k])   nextval[i] = j;\t\t<span class=\"comment\">/*若当前字符与前缀字符不同，则nextval与next无异*/</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>   nextval[i] = nextval[j];\t\t\t<span class=\"comment\">/*若相同，则将nextval值赋值给nextval在i的位置的值*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> k = nextval[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h2 id=\"1-树的定义\"><a href=\"#1-树的定义\" class=\"headerlink\" title=\"1.树的定义\"></a>1.树的定义</h2><p>树(Tree)是n(n&gt;&#x3D;0)个结点的有限集。n&#x3D;0时称为空树。</p>\n<p>任意一颗非空树中：1）有且仅有一个特定的根(Root)结点</p>\n<p>​\t\t\t\t\t\t\t\t   2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每个集合本身又是一棵树，并且称为根的子树(Sub Tree)</p>\n<h3 id=\"1-1结点的分类\"><a href=\"#1-1结点的分类\" class=\"headerlink\" title=\"1.1结点的分类\"></a>1.1结点的分类</h3><p>结点拥有的子树数称为结点的<strong>度(Degree)</strong></p>\n<p>度为0的结点称为**叶结点(Leaf)**或终端结点</p>\n<p>度不为0的结点称为非终端结点或分支结点</p>\n<p>树的度是树内各结点的度的最大值</p>\n<h3 id=\"1-2结点间的关系\"><a href=\"#1-2结点间的关系\" class=\"headerlink\" title=\"1.2结点间的关系\"></a>1.2结点间的关系</h3><p>结点的子树的根称为该结点的<strong>孩子(Child)<strong>，相应的，该结点称为孩子的</strong>双亲(Parent)</strong></p>\n<p>同一个双亲的孩子之间互称<strong>兄弟(Sibling)</strong></p>\n<p>结点的祖先是从根到该结点所经分支上的所有结点</p>\n<p>以某结点为根的子树中的任一结点都称为该节点的子孙</p>\n<h3 id=\"1-3其他相关概念\"><a href=\"#1-3其他相关概念\" class=\"headerlink\" title=\"1.3其他相关概念\"></a>1.3其他相关概念</h3><p>**层次(Level)**：从根开始定义起，根为第一层，根的孩子为第二层</p>\n<p>双亲在同一层的结点互为<strong>堂兄弟</strong></p>\n<p>树中结点最大层次称为树的<strong>深度(Depth)</strong></p>\n<p>如果将树中结点的各子树看成是从左到右有次序的，不能互换的则称为<strong>有序树</strong>，否则称为<strong>无序树</strong></p>\n<h3 id=\"1-4线性表与树\"><a href=\"#1-4线性表与树\" class=\"headerlink\" title=\"1.4线性表与树\"></a>1.4线性表与树</h3><table>\n<thead>\n<tr>\n<th align=\"center\">线性结构</th>\n<th align=\"center\">树结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">第一个数据元素：无前驱<br />最后一个数据元素：无后继<br />中间元素：一个前驱，一个后继</td>\n<td align=\"center\">根结点：无双亲，唯一<br />叶结点：无孩子，可以多个<br />中间结点：一个双亲，多个孩子</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-树的存储结构\"><a href=\"#2-树的存储结构\" class=\"headerlink\" title=\"2.树的存储结构\"></a>2.树的存储结构</h2><h3 id=\"2-1双亲表示法\"><a href=\"#2-1双亲表示法\" class=\"headerlink\" title=\"2.1双亲表示法\"></a>2.1双亲表示法</h3><p>在每个结点中，附设一个指示器指示其双亲结点在数组中的位置</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">parent</th>\n</tr>\n</thead>\n</table>\n<p>其中，data为数据域，parent为指针域，存储该结点的双亲在数组中的下标</p>\n<p>代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结点结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PTNode</span>&#123;</span>\t</span><br><span class=\"line\">    TElemType data;\t\t\t<span class=\"comment\">/*结点数据*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> parent;\t\t\t\t<span class=\"comment\">/*双亲位置*/</span></span><br><span class=\"line\">&#125;PTNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    PTNode nodes[MAX_TREE_SIZE];\t<span class=\"comment\">/*结点数组*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> r,n;\t\t\t\t\t\t<span class=\"comment\">/*根的位置和结点数*/</span></span><br><span class=\"line\">&#125;PTREE;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这样的存储结构可以很快找到他的双亲结点，所用时间复杂度为O(1)</p>\n<p>但若要知道结点的孩子是什么，就只能遍历整个结构</p>\n<p>所以可以增加一个长子域</p>\n<p>我们又关注结点的孩子、有关注结点的兄弟、对时间遍历的要求比较高，那么我们可以把此结构扩展为双亲域、长子域、右兄弟域</p>\n<p><strong>存储结构设计是一个非常灵活的过程</strong></p>\n<p><strong>一个存储结构设计的是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等</strong></p>\n<h3 id=\"2-2孩子表示法\"><a href=\"#2-2孩子表示法\" class=\"headerlink\" title=\"2.2孩子表示法\"></a>2.2孩子表示法</h3><hr>\n<p><strong>每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法</strong></p>\n<ol>\n<li><p>方案1</p>\n<p>指针域的个数等于树的度</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">child1</th>\n<th align=\"center\">child2</th>\n<th align=\"center\">……</th>\n<th align=\"center\">childd</th>\n</tr>\n</thead>\n</table>\n<p>若树中各结点的度相差很大时，浪费空间</p>\n<p>若相差较小，开辟的空间被充分利用了，则缺点变优点</p>\n</li>\n<li><p>方案2</p>\n<p>指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">degree</th>\n<th align=\"center\">child1</th>\n<th align=\"center\">child2</th>\n<th align=\"center\">……</th>\n<th align=\"center\">childd</th>\n</tr>\n</thead>\n</table>\n<p>克服了浪费空间的缺点，提高了空间利用率</p>\n<p>但由于各结点的链表结构不同，加上要维护结点的度和数值，在运算上就会带来时间上的损耗</p>\n</li>\n</ol>\n<p>所以采用孩子表示法</p>\n<p>具体办法是：</p>\n<p><strong>把每个结点的孩子排列起来，以单链表作为存储结构，则n个节点有n个孩子链表</strong></p>\n<p><strong>如果是叶子结点则此单链表为空。</strong></p>\n<p><strong>然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一堆数组中</strong></p>\n<p>为此，设计了两种结点结构</p>\n<p>1.孩子链表的孩子结点</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">child</th>\n<th align=\"center\">next</th>\n</tr>\n</thead>\n</table>\n<p>其中，child是数据域，用来存储某个结点在表头数组中的下标；next是指针域，用来存储指向某结点的下一个孩子结点的指针</p>\n<p>2.表头数组的表头结点</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">firstchild</th>\n</tr>\n</thead>\n</table>\n<p>其中，data是数据域，存储某结点的数据信息；firstchild是头指针域，存储该结点的孩子链表的头指针</p>\n<p>代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//孩子结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CTNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> child;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CTNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;*ChildPtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//表头结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    TElemType data;</span><br><span class=\"line\">    ChildPtr firstchild;</span><br><span class=\"line\">&#125;CTBox;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    CTBOX nodes[MAX_TREE_SIZE]; \t<span class=\"comment\">/*结点数组*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> r,nl\t\t\t\t\t\t<span class=\"comment\">/*根的位置和结点数*/</span></span><br><span class=\"line\">&#125;CTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3孩子兄弟表示法\"><a href=\"#2-3孩子兄弟表示法\" class=\"headerlink\" title=\"2.3孩子兄弟表示法\"></a>2.3孩子兄弟表示法</h3><p>任何一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。</p>\n<p>因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">firstchild</th>\n<th align=\"center\">rightsib</th>\n</tr>\n</thead>\n</table>\n<p>data为数据域；firstchild为指针域，存储长子结点的存储地址；rightsib是指针域，存储该结点的右兄弟结点的存储地址；</p>\n<p><strong>将复杂的树变为二叉树</strong></p>\n<h2 id=\"3-二叉树\"><a href=\"#3-二叉树\" class=\"headerlink\" title=\"3.二叉树\"></a>3.二叉树</h2><p>二叉树(Binary Tree)是n(n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集(称为空二叉树),或者由一个根节点和两棵互不相交、分别称为根结点的左子树和右子树的二叉树组成</p>\n<h3 id=\"3-1二叉树特点\"><a href=\"#3-1二叉树特点\" class=\"headerlink\" title=\"3.1二叉树特点\"></a>3.1二叉树特点</h3><ol>\n<li>每个结点最多有两棵子树</li>\n<li>左子树和右子树是有顺序的</li>\n<li>即使树中某结点只有一颗子树，也要区分它是左子树还是右子树</li>\n</ol>\n<h3 id=\"3-2特殊二叉树\"><a href=\"#3-2特殊二叉树\" class=\"headerlink\" title=\"3.2特殊二叉树\"></a>3.2特殊二叉树</h3><ol>\n<li><p>斜树</p>\n<p>所有结点都只有左子树的二叉树叫左斜树，所有结点都只有右子树的二叉树叫右斜树</p>\n</li>\n<li><p>满二叉树</p>\n<p>所有分支点都存在左子树和右子树，且所有叶子结点都在同一层</p>\n</li>\n<li><p>完全二叉树</p>\n<p>对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置相同，称为完全二叉树</p>\n</li>\n</ol>\n<h3 id=\"3-3二叉树性质\"><a href=\"#3-3二叉树性质\" class=\"headerlink\" title=\"3.3二叉树性质\"></a>3.3二叉树性质</h3><p>性质1：在二叉树的第i层最多有2<sup>i-1</sup>个结点(i&gt;&#x3D;1)</p>\n<p>性质2：深度为k的二叉树至多有2<sup>k</sup>-1个结点(k&gt;&#x3D;1)</p>\n<p>性质3：对任何一棵二叉树T，如果其终端节点为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub> &#x3D; n<sub>2</sub> +1</p>\n<p>性质4：具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1</p>\n<p>性质5：如果一棵有n个结点的完全二叉树的结点按层序编号(从第1层到第[log<sub>2</sub>n]+1层，每层从左到右)，对任一结点i(1&lt;&#x3D;i&lt;&#x3D;n)有：</p>\n<ol>\n<li>如果i&#x3D;1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i&#x2F;2]</li>\n<li>如果2i&gt;n，则结点无左孩子(结点i为叶子结点);否则其左孩子为结点2i</li>\n<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子为结点2i+1</li>\n</ol>\n<h2 id=\"4-二叉树的存储结构\"><a href=\"#4-二叉树的存储结构\" class=\"headerlink\" title=\"4.二叉树的存储结构\"></a>4.二叉树的存储结构</h2><h3 id=\"4-1顺序存储结构\"><a href=\"#4-1顺序存储结构\" class=\"headerlink\" title=\"4.1顺序存储结构\"></a>4.1顺序存储结构</h3><p>一般只用于完全二叉树</p>\n<h3 id=\"4-2二叉链表\"><a href=\"#4-2二叉链表\" class=\"headerlink\" title=\"4.2二叉链表\"></a>4.2二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">lchild</th>\n<th align=\"center\">data</th>\n<th align=\"center\">rchild</th>\n</tr>\n</thead>\n</table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二叉树的二叉链表结点结构定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    TElemType data;\t\t\t<span class=\"comment\">/*结点结构*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span>\t<span class=\"comment\">/*左右孩子指针*/</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"5-遍历二叉树\"><a href=\"#5-遍历二叉树\" class=\"headerlink\" title=\"5.遍历二叉树\"></a>5.遍历二叉树</h2><p><strong>二叉树的遍历时指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次</strong></p>\n<p>两个关键词：<strong>访问</strong>和<strong>次序</strong></p>\n<h3 id=\"5-1前序遍历\"><a href=\"#5-1前序遍历\" class=\"headerlink\" title=\"5.1前序遍历\"></a>5.1前序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树</p>\n<p>算法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PreOrderTraverse</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, T-&gt;data);\t\t\t<span class=\"comment\">/*显示结点数据，可改为其他操作*/</span></span><br><span class=\"line\">    PreOrderTraverse(T -&gt; lchild);\t<span class=\"comment\">/*先序遍历左子树*/</span></span><br><span class=\"line\">    PreOrderTraverse(T -&gt; rchild);\t<span class=\"comment\">/*先序遍历右子树*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"5-2中序遍历\"><a href=\"#5-2中序遍历\" class=\"headerlink\" title=\"5.2中序遍历\"></a>5.2中序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则从根结点开始(注意不是先访问根结点)，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树</p>\n<p>算法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InOrderTraverse</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    InOrderTraverse(T -&gt; lchild);\t<span class=\"comment\">/*中序遍历左子树*/</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, T-&gt;data);\t\t\t<span class=\"comment\">/*显示结点数据，可改为其他操作*/</span></span><br><span class=\"line\">    InOrderTraverse(T -&gt; rchild);\t<span class=\"comment\">/*中序遍历右子树*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-3后序遍历\"><a href=\"#5-3后序遍历\" class=\"headerlink\" title=\"5.3后序遍历\"></a>5.3后序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点</p>\n<p>算法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PostOrderTraverse</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    PostOrderTraverse(T -&gt; lchild);\t<span class=\"comment\">/*后序遍历左子树*/</span></span><br><span class=\"line\">    PostOrderTraverse(T -&gt; rchild);\t<span class=\"comment\">/*后序遍历右子树*/</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, T-&gt;data);\t\t\t<span class=\"comment\">/*显示结点数据，可改为其他操作*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-4层次遍历\"><a href=\"#5-4层次遍历\" class=\"headerlink\" title=\"5.4层次遍历\"></a>5.4层次遍历</h3><p>规则是若二叉树为空，则空操作返回，否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</p>\n<h2 id=\"6-二叉树的建立\"><a href=\"#6-二叉树的建立\" class=\"headerlink\" title=\"6.二叉树的建立\"></a>6.二叉树的建立</h2><p>普通二叉树</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\tA((A)) --- B((B)) &amp; C((C))\n    B ---X(( )) &amp; D((D))\n    style X fill:#f100,stroke-width:0px\n    linkStyle 2 stroke:#off, stroke-width:0px;\n  </pre></div>\n\n<p>扩展二叉树</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\tA((A)) --- B((B)) &amp; C((C))\n    B ---X1((#)) &amp; D((D))\n    D ---X2((#)) &amp; X3((#))\n    C ---X4((#)) &amp; X5((#))\n    classDef X fill:#4169E1\n    class X1,X2,X3,X4,X5 X;\n  </pre></div>\n\n\n\n<p>代码实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//按前序输入二叉树中结点值（一个字符）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CreatBiTree</span><span class=\"params\">(BiTree *T)</span></span>&#123;</span><br><span class=\"line\">    TElemType ch;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cin &gt;&gt; ch;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ch == <span class=\"string\">&quot;#&quot;</span>) T = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!T = <span class=\"keyword\">new</span> BiTNode) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">       \t</span><br><span class=\"line\">        T-&gt;data = ch;\t\t\t<span class=\"comment\">/*生成结点*/</span></span><br><span class=\"line\">        <span class=\"built_in\">CreatBiTree</span>(T-&gt;lchild); <span class=\"comment\">/*构造左子树*/</span></span><br><span class=\"line\">        <span class=\"built_in\">CreatBiTree</span>(T-&gt;rchild); <span class=\"comment\">/*构造右子树*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"7-线索二叉树\"><a href=\"#7-线索二叉树\" class=\"headerlink\" title=\"7.线索二叉树\"></a>7.线索二叉树</h2><p>指针域未充分利用</p>\n<p>将指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">lchild</th>\n<th align=\"center\">ltag</th>\n<th align=\"center\">data</th>\n<th align=\"center\">rtag</th>\n<th align=\"center\">rchild</th>\n</tr>\n</thead>\n</table>\n<p>其中</p>\n<ul>\n<li>ltag为0时指向该结点的左孩子，为1时指向该结点的前驱</li>\n<li>rtag为0时指向该结点的右孩子，为1时指向该结点的后继</li>\n</ul>\n<p>代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span>Link, Thread&#125; PointTag; \t<span class=\"comment\">/*Link==0表示指向左右孩子指针*/</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*Thread==1表示指向前驱或后继的线索*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiThrNode</span>&#123;</span></span><br><span class=\"line\">    TElemType data;\t\t\t\t\t\t<span class=\"comment\">/*结点数据*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiThrNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span>\t<span class=\"comment\">/*左右孩子指针*/</span></span><br><span class=\"line\">    PointerTag LTag,RTagj;\t\t\t\t<span class=\"comment\">/*左右标志*/</span></span><br><span class=\"line\">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>\n\n<p>线索化的过程就是在遍历的过程中修改空指针的过程</p>\n<p>中序遍历线索化的递归函数如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BiThrTree pre;\t\t\t\t\t<span class=\"comment\">/*全局变量，始终指向刚刚访问过的结点*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InThreading</span><span class=\"params\">(BiThrTree p)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p)&#123;</span><br><span class=\"line\">        InThreading(p-&gt;lchild);</span><br><span class=\"line\">        <span class=\"comment\">///////////////////////</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!p-&gt;lchild)&#123;\t\t\t<span class=\"comment\">/*没有左孩子*/</span></span><br><span class=\"line\">            p—&gt;LTag = Thread;\t<span class=\"comment\">/*前驱线索*/</span></span><br><span class=\"line\">            p-&gt;lchild = pre;\t<span class=\"comment\">/*左孩子指针指向前驱*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!pre-&gt;rchild)&#123;\t\t<span class=\"comment\">/*前驱没有右孩子*/</span></span><br><span class=\"line\">            pre-&gt;RTag = Thread; <span class=\"comment\">/*后继线索*/</span></span><br><span class=\"line\">            pre-&gt;rchild = p;\t<span class=\"comment\">/*前驱右孩子指针指向后继(当前结点p)*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;\t\t\t\t<span class=\"comment\">/*保持pre指向p的前驱*/</span></span><br><span class=\"line\">        <span class=\"comment\">///////////////////////</span></span><br><span class=\"line\">        InThreading(p-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点</span></span><br><span class=\"line\">Status <span class=\"title function_\">InOrderTraverse_Thr</span><span class=\"params\">(BiThrTree T)</span>&#123;</span><br><span class=\"line\">    BiThrTree p;</span><br><span class=\"line\">    p = T-&gt;lchild;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=T)&#123;\t\t\t\t\t<span class=\"comment\">/*空树或者遍历结束时，p == T*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;LTag == Link)\tp = p-&gt;lchild;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;data;\t\t\t<span class=\"comment\">/*显示结点数据或其他操作*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)&#123;</span><br><span class=\"line\">            p = p-&gt;rchild;\t\t\t<span class=\"comment\">/*访问后继结点*/</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = p-&gt;rchild;\t\t\t\t<span class=\"comment\">/*p进至其右子树根*/</span></span><br><span class=\"line\">    &#125;\t\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉树链表的存储结构就是非常不错的选择</strong></p>\n<h2 id=\"8-树、森林、二叉树的转换\"><a href=\"#8-树、森林、二叉树的转换\" class=\"headerlink\" title=\"8.树、森林、二叉树的转换\"></a>8.树、森林、二叉树的转换</h2><p><strong>树 –&gt; 二叉树</strong>：</p>\n<p>1.将所有兄弟结点间增加连线</p>\n<p>2.只保留和第一个孩子结点的连线，删除与其他孩子结点连线</p>\n<p>3.本身孩子结点为左孩子结点，兄弟结点为右孩子结点</p>\n<p><strong>森林 –&gt; 二叉树</strong></p>\n<p>1.把每棵树转化为二叉树</p>\n<p>2.第一棵二叉树不懂，从第二棵二叉树开始依次将后一棵二叉树的根节点作为前一棵的根节点的右孩子</p>\n<h2 id=\"9-哈夫曼树及其应用\"><a href=\"#9-哈夫曼树及其应用\" class=\"headerlink\" title=\"9.哈夫曼树及其应用\"></a>9.哈夫曼树及其应用</h2><h3 id=\"9-1哈夫曼树的定义及原理\"><a href=\"#9-1哈夫曼树的定义及原理\" class=\"headerlink\" title=\"9.1哈夫曼树的定义及原理\"></a>9.1哈夫曼树的定义及原理</h3><p>最基本的压缩编码方法——-哈夫曼编码</p>\n<p>带权路径长度WPL最小的二叉树称作哈夫曼树</p>\n<ol>\n<li>先把有权值的叶子结点按照从小到大的顺序排列成有序序列，即A5,E10, B15, D30, C40</li>\n<li>取头两个最小权值结点形成新结点N<sub>1</sub>，相对较小的为左孩子</li>\n<li>N<sub>1</sub>替换A、E，插入有序序列中重复2</li>\n</ol>\n<h3 id=\"9-2哈夫曼编码\"><a href=\"#9-2哈夫曼编码\" class=\"headerlink\" title=\"9.2哈夫曼编码\"></a>9.2哈夫曼编码</h3><h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><h2 id=\"1-图的定义及术语\"><a href=\"#1-图的定义及术语\" class=\"headerlink\" title=\"1.图的定义及术语\"></a>1.图的定义及术语</h2><h2 id=\"2-图的存储结构\"><a href=\"#2-图的存储结构\" class=\"headerlink\" title=\"2.图的存储结构\"></a>2.图的存储结构</h2><h3 id=\"2-1邻接矩阵\"><a href=\"#2-1邻接矩阵\" class=\"headerlink\" title=\"2.1邻接矩阵\"></a>2.1邻接矩阵</h3><p>图的邻接矩阵存储方式是用两个数组来表示图。</p>\n<p>一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边的信息</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\nV0 --- V1 &amp; V2 &amp; V3\nV2 --- V1 &amp;  V3\n  </pre></div>\n\n<p>顶点数组： </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">V0</th>\n<th align=\"center\">V1</th>\n<th align=\"center\">V2</th>\n<th align=\"center\">V3</th>\n</tr>\n</thead>\n</table>\n<p>邻接矩阵：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">0</th>\n<th align=\"center\">1</th>\n<th align=\"center\">1</th>\n<th align=\"center\">1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n<p><strong>邻接矩阵存储结构</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    VertexType vexs[MAXVEX];\t\t<span class=\"comment\">/*顶点表*/</span></span><br><span class=\"line\">    EdgeType arc[MAXVEX][MAXVEX];\t<span class=\"comment\">/*邻接矩阵，可看作边表*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> numNodes, numEdges;\t\t\t<span class=\"comment\">/*图中的定点数和边数*/</span></span><br><span class=\"line\">&#125;MGraph;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>无向网图创建代码</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">CreatMGraph</span><span class=\"params\">(MGraph *G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, k, w;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;请输入顶点数和边数&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; G-&gt;numNodes &gt;&gt; G-&gt;numEdges;\t\t\t\t\t\t<span class=\"comment\">/*输入顶点数和边数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G-&gt;numNodes; i++)\t<span class=\"built_in\">cin</span> &gt;&gt; G-&gt;vexs[i];\t<span class=\"comment\">/*读入顶点信息，建立顶点表*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G-&gt;numNodes; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; G-&gt;numNodes; j++)</span><br><span class=\"line\">            G-&gt;arc[i][j] = INFINITY;\t\t\t\t\t\t<span class=\"comment\">/*初始化邻接矩阵*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; G-&gt;numEdges; k++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;输入边(vi,vj)的下标i,j和权w：\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i &gt;&gt; j &gt;&gt; w;</span><br><span class=\"line\">        G-&gt;arc[i][j] = w;</span><br><span class=\"line\">        G-&gt;arc[j][i] = G-&gt;arc[i][j];\t\t\t\t\t\t<span class=\"comment\">/*无向图，所以矩阵对称*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"2-2邻接表\"><a href=\"#2-2邻接表\" class=\"headerlink\" title=\"2.2邻接表\"></a>2.2邻接表</h3><p>数组与链表相结合的存储方式称为邻接表</p>\n<p>1.用数组存储顶点</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">firstedge</th>\n</tr>\n</thead>\n</table>\n<p>2.用链表存储临界点</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">adjvex</th>\n<th align=\"center\">next</th>\n</tr>\n</thead>\n</table>\n<p>有向图中，邻接表可以算出度</p>\n<p>逆邻接表可以算入度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span>&#123;</span>\t\t\t\t\t<span class=\"comment\">/*边表结点*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> adjvex;\t\t\t\t\t\t\t\t<span class=\"comment\">/*邻接点域，存储该顶点对应下标*/</span></span><br><span class=\"line\">    EdgeType info;\t\t\t\t\t\t\t<span class=\"comment\">/*用于存储权值，对非网图可以不要*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> *<span class=\"title\">next</span>;</span>\t\t\t\t\t<span class=\"comment\">/*链域，指向下一个邻接点*/</span></span><br><span class=\"line\">&#125;EdgeNode；</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VertexNode</span>&#123;</span>\t\t\t\t\t<span class=\"comment\">/*顶点表结点*/</span></span><br><span class=\"line\">    VertexType data;\t\t\t\t\t\t<span class=\"comment\">/*顶点域，存储顶点信息*/</span></span><br><span class=\"line\">    EdgeNode *firstedge;\t\t\t\t\t<span class=\"comment\">/*边表头指针*/</span></span><br><span class=\"line\">&#125;VertexNode,AdjList[MAXVEX];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    AdjList adjlist;</span><br><span class=\"line\">    <span class=\"type\">int</span> numNodes, numEdges;\t\t\t\t\t<span class=\"comment\">/*图中当前顶点数和边数*/</span></span><br><span class=\"line\">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure>\n\n<p><strong>邻接表的创建</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//建立图的邻接表结构</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">CreatALGraph</span><span class=\"params\">(GraphAdjList *G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">    EdgeNode *e;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;请输入顶点数和边数&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; G-&gt;numNodes &gt;&gt; G-&gt;numEdges;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G-&gt;numNodes; i++)&#123;\t\t<span class=\"comment\">/*读入顶点信息，建立顶点表*/</span></span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; G-&gt;adjList[i].data;\t\t\t<span class=\"comment\">/*输入顶点信息*/</span></span><br><span class=\"line\">        G-&gt;adjList[i].firstedge = <span class=\"literal\">NULL</span>;\t\t<span class=\"comment\">/*边表置为空表*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; G-&gt;numEdges; k++)&#123;\t\t<span class=\"comment\">/*读入顶点信息，建立边表*/</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;输入边(vi,vj)上的顶点序号:&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i &gt;&gt; j;</span><br><span class=\"line\">        <span class=\"comment\">////////////////////////////////////////////////////////////</span></span><br><span class=\"line\">        e = new EdgeNode;</span><br><span class=\"line\">        e-&gt;adjvex = j;</span><br><span class=\"line\">        e-&gt;next = G-&gt;adjList[i].firstedge;</span><br><span class=\"line\">        G-&gt;adjList[i].firstedge = e;\t\t<span class=\"comment\">/////头插法</span></span><br><span class=\"line\">        e = new EdgeNode;</span><br><span class=\"line\">        e-&gt;adjvex = i;</span><br><span class=\"line\">        e-&gt;next = G-&gt;adjList[j].firstedge;</span><br><span class=\"line\">        G-&gt;adjList[j].firstedge = e;</span><br><span class=\"line\">        <span class=\"comment\">////////////////////////////////////////////////////////////</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3十字链表\"><a href=\"#2-3十字链表\" class=\"headerlink\" title=\"2.3十字链表\"></a>2.3十字链表</h3><p>将邻接表与逆邻接表结合起来</p>\n<p>顶点表结点结构如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">data</th>\n<th align=\"center\">firstin</th>\n<th align=\"center\">firstout</th>\n</tr>\n</thead>\n</table>\n<p>边表结点如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">tailvex</th>\n<th align=\"center\">headvex</th>\n<th align=\"center\">headlink</th>\n<th align=\"center\">taillink</th>\n</tr>\n</thead>\n</table>\n<p>tailvex：边起点在顶点表中下标</p>\n<p>headvex：边终点在定点表中下标</p>\n<p>headlink：入边表指针域，指向终点相同的下一条边</p>\n<p>taillink：出边表指针域，指向起点相同的下一条边</p>\n<h3 id=\"2-4邻接多重表\"><a href=\"#2-4邻接多重表\" class=\"headerlink\" title=\"2.4邻接多重表\"></a>2.4邻接多重表</h3><h3 id=\"2-5边集数组\"><a href=\"#2-5边集数组\" class=\"headerlink\" title=\"2.5边集数组\"></a>2.5边集数组</h3><p>边集数组是由两个一维数组构成。</p>\n<p>一个存储顶点信息，一个存储边的信息</p>\n<p>顶点数组</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">V0</th>\n<th align=\"center\">V1</th>\n<th align=\"center\">V2</th>\n<th align=\"center\">V3</th>\n<th align=\"center\">V4</th>\n</tr>\n</thead>\n</table>\n<p>边数组</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">begin</th>\n<th align=\"center\">end</th>\n<th align=\"center\">weight</th>\n</tr>\n</thead>\n</table>\n<h2 id=\"3-图的遍历\"><a href=\"#3-图的遍历\" class=\"headerlink\" title=\"3.图的遍历\"></a>3.图的遍历</h2><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历</p>\n<p><strong>遍历实质</strong>：图的邻接点</p>\n<h3 id=\"3-1深度优先遍历\"><a href=\"#3-1深度优先遍历\" class=\"headerlink\" title=\"3.1深度优先遍历\"></a>3.1深度优先遍历</h3><p>深度优先遍历(Depth First Search) <strong>DFS</strong></p>\n<p><strong>类似树的前序遍历</strong></p>\n<p>从图中某个顶点V出发，访问此顶点，然后从V的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到</p>\n<p>若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//邻接矩阵的深度优先递归算法</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j;</span><br><span class=\"line\">    visitet[i] = TRUE;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; G.vexs[i];\t\t\t\t\t\t\t<span class=\"comment\">/*访问顶点，也可做其他操作*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; G.numVertexes; j++)\t\t\t</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G.arc[i][j] == <span class=\"number\">1</span> &amp;&amp; !visited[j])\t\t<span class=\"comment\">/*G.arc[i][j]为1代表邻接，visited[i] = 0代表未被访问*/</span></span><br><span class=\"line\">            DFS(G, j);\t\t\t\t\t\t\t<span class=\"comment\">/*对未访问的顶点做递归调用*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<strong>邻接矩阵</strong>表示图，遍历图中每个顶点都要从头扫描该顶点所在行，时间复杂度O(n<sup>2</sup>)</p>\n<hr>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//邻接表的深度优先递归算法</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DFS</span><span class=\"params\">(GraphAdjList GL, <span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    EdgeNode *p;</span><br><span class=\"line\">    visit[i] = TRUE;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; GL.adjList[i].data;\t\t\t\t\t<span class=\"comment\">/*打印顶点，也可做其他操作*/</span></span><br><span class=\"line\">    p = GL-&gt;adjList[i].firstedge;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[p-&gt;adjvex])</span><br><span class=\"line\">            DFS(GL, p-&gt;adjvex);</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<strong>邻接表</strong>来表示图，有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点，时间复杂度为O(n+e)</p>\n<h3 id=\"3-2广度优先遍历\"><a href=\"#3-2广度优先遍历\" class=\"headerlink\" title=\"3.2广度优先遍历\"></a>3.2广度优先遍历</h3><p>广度优先遍历(Breadth First Search) <strong>BFS</strong></p>\n<p><strong>类似树的层序遍历</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//邻接矩阵的广度遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BFS</span><span class=\"params\">(Graph G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">    InitQueue(Q);\t\t\t\t\t\t\t\t<span class=\"comment\">/*辅助队列初始化,置空*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G.numVertexes; i++)&#123;\t\t\t<span class=\"comment\">/*对每个顶点做循环*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[i])&#123;\t\t\t\t\t\t<span class=\"comment\">/*若是未被访问过就处理*/</span></span><br><span class=\"line\">            visited[i] = TRUE;\t\t\t\t\t<span class=\"comment\">/*标记为已访问*/</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; G.vexs[i];\t\t\t\t\t<span class=\"comment\">/*访问顶点*/</span></span><br><span class=\"line\">            EnQueue(Q,i);\t\t\t\t\t\t<span class=\"comment\">/*当前顶点入队*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!QueueEmpty(Q))&#123;\t\t\t\t<span class=\"comment\">/*若当前队列不为空*/</span></span><br><span class=\"line\">                DeQueue(Q,i);\t\t\t\t\t<span class=\"comment\">/*将队首元素出队列，赋值给i*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; G.numVertexes; j++)&#123;\t\t\t\t</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(G.arc[i][j] == <span class=\"number\">1</span> &amp;&amp; !visited[j])&#123;\t\t<span class=\"comment\">/*判断其他顶点，若与当前顶点存在边且未访问过*/</span></span><br><span class=\"line\">                        visited[j] == TRUE;\t\t\t\t\t\t</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; G.vexs[j];\t\t\t\t\t\t<span class=\"comment\">/*访问顶点*/</span></span><br><span class=\"line\">                        EnQueue(Q,j);\t\t\t\t\t\t\t<span class=\"comment\">/*将找到的顶点入队列*/</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//邻接表的广度遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BFS</span><span class=\"params\">(GraphAdjList GL)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    EdgeNode *p;</span><br><span class=\"line\">    Queue Q;</span><br><span class=\"line\">    InitQueue(Q);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; GL-&gt;numVertexes; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[i])&#123;</span><br><span class=\"line\">            visit[i] = TRUE;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; G.vexs[i];\t\t\t\t\t<span class=\"comment\">/*访问顶点*/</span></span><br><span class=\"line\">            EnQueue(Q,i);\t\t\t\t\t\t<span class=\"comment\">/*当前顶点入队*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!QueueEmpty(Q))&#123;</span><br><span class=\"line\">                DeQueue(Q,i);</span><br><span class=\"line\">                p = GL-&gt;adjustList[i].firstedge;<span class=\"comment\">/*找到当前顶点的边表链的表头指针*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!visited[p-&gt;adjvex])&#123;\t<span class=\"comment\">/*若顶点未被访问*/</span></span><br><span class=\"line\">                        visited[p-&gt;adjvex] = TRUE;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; GL-&gt;adjList[p-&gt;adjvex].data;<span class=\"comment\">/*访问顶点*/</span></span><br><span class=\"line\">                        EnQueue(Q,p-&gt;adjvex);   <span class=\"comment\">/*将此顶点入队列*/</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = p-&gt;next;\t\t\t\t<span class=\"comment\">/*指针指向下一个邻接点*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"4-最小生成树\"><a href=\"#4-最小生成树\" class=\"headerlink\" title=\"4.最小生成树\"></a>4.最小生成树</h2><p>构造连通网的最小代价生成树称为最小生成树</p>\n<h3 id=\"4-1Prim算法\"><a href=\"#4-1Prim算法\" class=\"headerlink\" title=\"4.1Prim算法\"></a>4.1Prim算法</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Prim算法生成最小生成树</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MiniSpanTress_Prim</span><span class=\"params\">(MGraph G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> min, i, j, k;</span><br><span class=\"line\">    <span class=\"type\">int</span> adjvex[MAXVEX];\t\t\t\t\t\t<span class=\"comment\">/*邻接点下标*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> lowcost[MAXVEX];\t\t\t\t\t<span class=\"comment\">/*保存权值*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class=\"line\">        lowcost[i] = G.arc[<span class=\"number\">0</span>][i];\t\t\t<span class=\"comment\">/*将V0顶点与其他所有点连接的权值存入数组*/</span></span><br><span class=\"line\">        adjvex[i] = <span class=\"number\">0</span>;\t\t\t\t\t\t<span class=\"comment\">/*初始化为V0下标*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class=\"line\">     \tmin = INFINITY;\t\t\t\t\t\t<span class=\"comment\">/*初始化最小权值为∞,可设为较大数字*/</span></span><br><span class=\"line\">        j = <span class=\"number\">1</span>; k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//找到最小权值边，并将最小权值边的邻接点存入k</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &lt; G.numVertexes)&#123;\t\t\t\t</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lowcost[j] != <span class=\"number\">0</span> &amp;&amp; lowcost[j] &lt; min)&#123;</span><br><span class=\"line\">                min = lowcost[j];</span><br><span class=\"line\">                k = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;(&quot;</span> + adjvex[k] + <span class=\"string\">&quot;,&quot;</span> + k + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">        lowcost[k] = <span class=\"number\">0</span>;\t\t\t\t\t\t<span class=\"comment\">/*当前点已完成任务*/</span></span><br><span class=\"line\">        <span class=\"comment\">//将与k相接的边的权值更新至lowcost数组，并将其邻接点adjvex更新为k</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">1</span>; j &lt; G.numVertexes; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lowcost[j] != <span class=\"number\">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j])&#123;</span><br><span class=\"line\">                lowcost[j] = G.arc[k][j];</span><br><span class=\"line\">                adjvex[j] = k;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-2Kruskal算法\"><a href=\"#4-2Kruskal算法\" class=\"headerlink\" title=\"4.2Kruskal算法\"></a>4.2Kruskal算法</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义边集数组</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> begin;</span><br><span class=\"line\">    <span class=\"type\">int</span> end;</span><br><span class=\"line\">    <span class=\"type\">int</span> weight;</span><br><span class=\"line\">&#125;Edge;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Kruskal算法生成最小生成树</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MiniSpanTree_Kruskal</span><span class=\"params\">(MGraph G)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, n, m;</span><br><span class=\"line\">    Edge edges[MAXEDGE];</span><br><span class=\"line\">    <span class=\"type\">int</span> parent[MAXEDGE];\t\t\t\t\t<span class=\"comment\">/*判断边是否形成回路*/</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*省略按权值排序*/</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G.numVertexes; i++)&#123;</span><br><span class=\"line\">        parent[i] = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G.numEdges; i++)&#123;</span><br><span class=\"line\">        n = Find(parent, edges[i].begin);</span><br><span class=\"line\">        m = Find(parent, edges[i].end);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n != m)&#123;\t\t\t\t\t\t\t<span class=\"comment\">/*m若与n不相等，即未形成环路*/</span></span><br><span class=\"line\">            parent[n] = m;\t\t\t\t\t<span class=\"comment\">/*将此边的结尾顶点放入下标为起点的parent中，表示此顶点已在生成树集合中*/</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;(%d, %d) %d&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//查找连接顶点的尾部下标</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">Find</span><span class=\"params\">(<span class=\"type\">int</span> *parent, <span class=\"type\">int</span> f)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(parent[f] &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            f = parent[f];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-3比较\"><a href=\"#4-3比较\" class=\"headerlink\" title=\"4.3比较\"></a>4.3比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">算法名</th>\n<th align=\"center\">Prim算法</th>\n<th align=\"center\">Kruskal算法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">算法思想</td>\n<td align=\"center\">选择点</td>\n<td align=\"center\">选择边</td>\n</tr>\n<tr>\n<td align=\"center\">时间复杂度</td>\n<td align=\"center\">O(n<sup>2</sup>)     n为顶点数</td>\n<td align=\"center\">O(eloge)   e为边数</td>\n</tr>\n<tr>\n<td align=\"center\">适应范围</td>\n<td align=\"center\">稠密图</td>\n<td align=\"center\">稀疏图</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-最短路径\"><a href=\"#5-最短路径\" class=\"headerlink\" title=\"5.最短路径\"></a>5.最短路径</h2><h3 id=\"5-1Dijkstra算法\"><a href=\"#5-1Dijkstra算法\" class=\"headerlink\" title=\"5.1Dijkstra算法\"></a>5.1Dijkstra算法</h3><p>数据结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> vexs[MAXVEX];</span><br><span class=\"line\">    <span class=\"type\">int</span> arc[MAXVEX][MAXVEX];</span><br><span class=\"line\">    <span class=\"type\">int</span> numVertexes, numEdges;</span><br><span class=\"line\">&#125;MGraph;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> Patharc[MAXVEX];\t\t\t<span class=\"comment\">/*用于存储最短路径下标的数组*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> ShortPathTable[MAXVEX];\t\t<span class=\"comment\">/*用于存储到各点最短路径的权值和*/</span></span><br></pre></td></tr></table></figure>\n\n<p>算法代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Dijkstra算法 求V0到其余顶点的最短路径P[v]及带权长度D[v]</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ShorttestPath_Dijkstra</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> v0, Pathace *P, ShortPathTable *D)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> v, w, k, min;</span><br><span class=\"line\">    <span class=\"type\">int</span> final[MAXVEX];\t\t\t\t\t\t<span class=\"comment\">/*final[k] = 1 表示已求得*/</span></span><br><span class=\"line\">    <span class=\"comment\">//初始化数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(v = <span class=\"number\">0</span>; v &lt; G.arc[v0][v]; v++)&#123;</span><br><span class=\"line\">        final[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        *D[v] = G.arc[v0][v];</span><br><span class=\"line\">        *P[v] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *D[v0] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    final[v0] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//开始主循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(v = <span class=\"number\">1</span>; v &lt; G.numVertexes; v++)&#123;</span><br><span class=\"line\">        min = INFINITY;</span><br><span class=\"line\">        <span class=\"comment\">//寻找距离v0最近的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(w = <span class=\"number\">0</span>; w &lt; G.numVertexes; w++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!final[w] &amp;&amp; *D[w] &lt; min)&#123;</span><br><span class=\"line\">                k = w;</span><br><span class=\"line\">                min = *D[w];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        final[k] = <span class=\"number\">1</span>;\t\t\t\t\t\t<span class=\"comment\">/*将目前找到的顶点置1*/</span></span><br><span class=\"line\">        <span class=\"comment\">//修正当前最短路径及距离</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(w = <span class=\"number\">0</span>; w &lt; G.numVertexes; w++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果经过v顶点的路径比现在该路径长度短</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!final[w] &amp;&amp; (min + arc[k][w] &lt; *G[w]))&#123;</span><br><span class=\"line\">                *D[w] = min + arc[k][w];\t<span class=\"comment\">/*更新最小值*/</span></span><br><span class=\"line\">                *P[w] = k;\t\t\t\t\t<span class=\"comment\">/*更新路径*/</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2Floyd算法\"><a href=\"#5-2Floyd算法\" class=\"headerlink\" title=\"5.2Floyd算法\"></a>5.2Floyd算法</h3><p>算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Patharc[MAXVEX][MAXVEX];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Floyd算法，求G中各顶点V到其余顶点w的最短路径P[v][w]及带权长度D[v][w]</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ShortestPath_Floyd</span><span class=\"params\">(MGraph G, Patharc *P, ShortPathTable *D)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> v, w, k;</span><br><span class=\"line\">    <span class=\"comment\">//初始化D与P</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(v = <span class=\"number\">0</span>; v &lt; G.numVertexes; ++v)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(w = <span class=\"number\">0</span>; w &lt; G.numVertexes; ++w)&#123;</span><br><span class=\"line\">            *D[v][w] = G.arc[v][w];</span><br><span class=\"line\">            *P[v][w] = w;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; G.numVertexes; ++k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(v = <span class=\"number\">0</span>; v &lt; G.numVertexes; ++v)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(w = <span class=\"number\">0</span>; w &lt; G.numVertexes; ++w)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果经过k顶点的路径比原两点路径短</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(*D[v][w] &gt; *D[v][k] + *D[k][w])&#123;</span><br><span class=\"line\">                    *D[v][w] = *D[v][k] + *D[k][w];</span><br><span class=\"line\">                    *P[v][w] = *P[v][k];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-拓扑排序\"><a href=\"#6-拓扑排序\" class=\"headerlink\" title=\"6.拓扑排序\"></a>6.拓扑排序</h2><p>有向无环图</p>\n<p><strong>AOV网</strong></p>\n<p>以顶点表示活动，弧表示活动间优先制约关系</p>\n<p><strong>拓扑有序序列</strong></p>\n<p>在AOV网没有回路的前提下，将全部活动排列成一个线性序列，若从顶点V<sub>i</sub>到V<sub>j</sub>有一条路径，那么V<sub>i</sub>必在V<sub>j</sub>之前</p>\n<p>我们称这样的线性序列为<strong>拓扑有序序列</strong></p>\n<p><strong>检测AOV中是否存在环</strong></p>\n<p>对有向图构造拓扑有序序列，若所有点都在拓扑有序序列中，则AOV网必不存在环</p>\n<h2 id=\"7-关键路径\"><a href=\"#7-关键路径\" class=\"headerlink\" title=\"7.关键路径\"></a>7.关键路径</h2><p><strong>AOE网</strong></p>\n<p>以弧表示活动，以顶点表示活动的开始或者结束事件</p>\n<p><strong>关键路径</strong></p>\n<p>路径长度最长的路径</p>\n<h3 id=\"7-1定义参数\"><a href=\"#7-1定义参数\" class=\"headerlink\" title=\"7.1定义参数\"></a>7.1定义参数</h3><table>\n<thead>\n<tr>\n<th align=\"center\">定义参数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ve(V<sub>j</sub>)</td>\n<td align=\"center\">表示事件V<sub>j</sub>最早发生时间</td>\n</tr>\n<tr>\n<td align=\"center\">vl(V<sub>j</sub>)</td>\n<td align=\"center\">表示事件V<sub>j</sub>最迟发生时间</td>\n</tr>\n<tr>\n<td align=\"center\">e(i)</td>\n<td align=\"center\">表示活动i最早开始时间</td>\n</tr>\n<tr>\n<td align=\"center\">l(i)</td>\n<td align=\"center\">表示活动i最晚开始时间</td>\n</tr>\n</tbody></table>\n<p>l(i) - e(i) —–表示完成活动i的时间余量</p>\n<p><strong>关键活动</strong> —–l(i) &#x3D;&#x3D; e(i)</p>\n<p><strong>求关键路径步骤</strong></p>\n<ol>\n<li>求ve(V<sub>j</sub>)、vl(V<sub>j</sub>)</li>\n<li>求e(i)、l(i)</li>\n<li>计算l(i) - e(i)</li>\n</ol>\n<h1 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h1><h2 id=\"1-查找概论\"><a href=\"#1-查找概论\" class=\"headerlink\" title=\"1.查找概论\"></a>1.查找概论</h2><p>**查找表(Search Table)**是由同一类型的数据元素构成的集合</p>\n<p>**关键字(Key)**是数据元素中的某个数据项的值</p>\n<p>若此关键字可以唯一地标记一个记录，则称此关键字为<strong>主关键字(Primary Key)</strong></p>\n<p>对于可以识别多个数据元素的关键词，称为<strong>次关键字(Secondary Key)</strong></p>\n<p><strong>查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素</strong></p>\n<p><strong>静态查找表</strong>：只做查找操作的查找表</p>\n<ol>\n<li>查询特定的数据元素是否在查找表中</li>\n<li>检索特定的数据元素和各种属性</li>\n</ol>\n<p><strong>动态查找表</strong>：在查找过程中同时插入表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</p>\n<ol>\n<li>查找时插入数据元素</li>\n<li>查找时删除数据元素</li>\n</ol>\n<h2 id=\"2-顺序表查找\"><a href=\"#2-顺序表查找\" class=\"headerlink\" title=\"2.顺序表查找\"></a>2.顺序表查找</h2><p>针对线性表进行查找操作，所以为静态查找表</p>\n<p>**顺序查找(Sequential Search)**又叫线性查找，是最基本的查找技术，查找过程如下：</p>\n<p>从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较</p>\n<p>若某个记录的关键字和给定值相等，则查找成功</p>\n<p>若直到最后一个（或者第一个）记录的关键字和给定值比较都不等时，查找失败</p>\n<p>实现算法如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Sequential_Search</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> n, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] == ket)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有哨兵顺序查找</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Sequential_Search2</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> n, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = key;\t\t\t\t\t<span class=\"comment\">/*设置a[0]为关键字值，称之为“哨兵”*/</span></span><br><span class=\"line\">    i = n;\t\t\t\t\t\t<span class=\"comment\">/*循环从数组尾部开始*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a[i] != key)&#123;</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-有序表查找\"><a href=\"#3-有序表查找\" class=\"headerlink\" title=\"3.有序表查找\"></a>3.有序表查找</h2><h3 id=\"3-1二分查找\"><a href=\"#3-1二分查找\" class=\"headerlink\" title=\"3.1二分查找\"></a>3.1二分查找</h3><p>**折半查找(Binary Search)**又称二分查找</p>\n<p>前提是线性表中记录必须是<strong>关键码有序</strong>（通常从小到大有序），线性表必须采用顺序存储</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Binary_Search</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> n, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> low, high, mid;</span><br><span class=\"line\">    low = <span class=\"number\">1</span>;</span><br><span class=\"line\">    high = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high)&#123;</span><br><span class=\"line\">        mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; a[mid])</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key &gt; a[mid])</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>时间复杂度O(logn)</strong></p>\n<h3 id=\"3-2插值查找\"><a href=\"#3-2插值查找\" class=\"headerlink\" title=\"3.2插值查找\"></a>3.2插值查找</h3><p>将二分查找的代码做略微变换</p>\n<p>$$mid &#x3D; \\frac{low + high}{2}$ &#x3D;$low + \\frac{1}{2}(high - low)$$</p>\n<p>改为以下计算方案</p>\n<p>$$mid &#x3D; low + \\frac{key - a[low]}{a[high] - a[low]}(high - low)$$</p>\n<h3 id=\"3-3斐波那契查找\"><a href=\"#3-3斐波那契查找\" class=\"headerlink\" title=\"3.3斐波那契查找\"></a>3.3斐波那契查找</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Fibonacci_Search</span><span class=\"params\">(<span class=\"type\">int</span> *a, <span class=\"type\">int</span> n, <span class=\"type\">int</span> ket)</span>&#123;\t\t<span class=\"comment\">/*F[n]为已经计算好的斐波那契数列*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> low, high, mid, i, k;</span><br><span class=\"line\">    low = <span class=\"number\">1</span>;</span><br><span class=\"line\">    high = n;</span><br><span class=\"line\">    k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; F[k] - <span class=\"number\">1</span>)\t\t\t\t\t\t\t<span class=\"comment\">/*计算n位斐波那契数列的位置*/</span></span><br><span class=\"line\">        k++;\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = n; i &lt; F[K] - <span class=\"number\">1</span>; i++)\t\t\t\t\t<span class=\"comment\">/*将数值补全*/</span></span><br><span class=\"line\">        a[i] = a[n];</span><br><span class=\"line\">    <span class=\"comment\">//查找开始</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high)&#123;\t\t\t\t\t\t\t</span><br><span class=\"line\">        mid = low + F[K - <span class=\"number\">1</span>] - <span class=\"number\">1</span>;\t\t\t\t\t<span class=\"comment\">/*计算当前分隔下标*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; a[mid])&#123;</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            k = k - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; a[mid])&#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            k = k - <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mid &lt;= n)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度O(logn)</strong></p>\n<h3 id=\"3-4对比\"><a href=\"#3-4对比\" class=\"headerlink\" title=\"3.4对比\"></a>3.4对比</h3><p>时间复杂度相同</p>\n<p>斐波那契查找只进行简单加减法运算$mid&#x3D;low+F[k-1]-1$</p>\n<p>折半查找进行加法与除法运算$mid&#x3D;\\frac{low+high}{2}$</p>\n<p>插值查找进行复杂四则运算$$mid &#x3D; low + \\frac{key - a[low]}{a[high] - a[low]}(high - low)$$</p>\n<p>三种有序表的查找法本质上是分隔点选择不同，各有优劣</p>\n<h2 id=\"4-线性索引查找\"><a href=\"#4-线性索引查找\" class=\"headerlink\" title=\"4.线性索引查找\"></a>4.线性索引查找</h2><p>索引就是把一个关键字与它对应的记录相关联的过程</p>\n<p>线性索引就是将索引项集合组织为线性结构，也称为<strong>索引表</strong></p>\n<h3 id=\"4-1稠密索引\"><a href=\"#4-1稠密索引\" class=\"headerlink\" title=\"4.1稠密索引\"></a>4.1稠密索引</h3><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</p>\n<p>对于稠密索引来说，<strong>索引项一定是按照关键码有序排列的</strong></p>\n<p>意味着可以用到折半、插值、斐波那契等有序查找法</p>\n<h3 id=\"4-2分块索引\"><a href=\"#4-2分块索引\" class=\"headerlink\" title=\"4.2分块索引\"></a>4.2分块索引</h3><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足一下两个条件</p>\n<ol>\n<li>块内无序</li>\n<li>块间有序</li>\n</ol>\n<p>我们定义的分块索引项结构分三个部分</p>\n<ul>\n<li>最大关键码</li>\n<li>存储块中记录个数</li>\n<li>用于指向块首数据元素的指针</li>\n</ul>\n<p>在分块索引表中查找就是进行以下两步</p>\n<ol>\n<li>在分块索引表中查找要查关键字所在的块</li>\n<li>根据块首指针找到相应的块，并在块中顺序查找关键码</li>\n</ol>\n<p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中</p>\n<h3 id=\"4-3倒排索引\"><a href=\"#4-3倒排索引\" class=\"headerlink\" title=\"4.3倒排索引\"></a>4.3倒排索引</h3><p>索引项的通用结构是</p>\n<ul>\n<li>次关键码</li>\n<li>记录号表</li>\n</ul>\n<p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）</p>\n<h2 id=\"5-二叉排序树\"><a href=\"#5-二叉排序树\" class=\"headerlink\" title=\"5.二叉排序树\"></a>5.二叉排序树</h2><p>**二叉排序树(Binary Sort Tree)**，又称为二叉查找树。它或者是一棵空树，或者是具有以下性质的二叉树</p>\n<ul>\n<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>\n<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>\n<li>它的左、右子树也分别为二叉排列树</li>\n</ul>\n<p>构造一棵二叉排序树的目的，不是为了排序，而是为了提高查找和插入删除关键字的速度</p>\n<h3 id=\"5-1查找操作\"><a href=\"#5-1查找操作\" class=\"headerlink\" title=\"5.1查找操作\"></a>5.1查找操作</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//二叉树的二叉链表的结点结构定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>二叉排序树的查找</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">SearchBST</span><span class=\"params\">(BiTree T, <span class=\"type\">int</span> key, BiTree f, BiTree *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//递归查找二叉排序树T中是否存在key</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!T)&#123;\t\t\t\t\t\t\t\t<span class=\"comment\">/*若查找不成功，指针p指向查找路径上访问的最后一个结点并返回FALSE*/</span></span><br><span class=\"line\">        *p = f;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key == T-&gt;data)&#123;\t\t\t\t<span class=\"comment\">/*若查找成功，则指针p指向该数据元素结点，并返回TRUE*/</span></span><br><span class=\"line\">        *p = T;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; T-&gt;data)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SearchBST(T-&gt;lchild, key, T, p); <span class=\"comment\">/*在左子树中继续查找*/</span></span><br><span class=\"line\">   \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; T-&gt;data)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SearchBST(T-&gt;rchild, key, T, p); <span class=\"comment\">/*在右子树中继续查找*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-2插入操作\"><a href=\"#5-2插入操作\" class=\"headerlink\" title=\"5.2插入操作\"></a>5.2插入操作</h3><p>将关键字放到树中合适的位置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InsertBST</span><span class=\"params\">(BiTree *T, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    BiTree p, s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!SearchBST(*T, key, <span class=\"literal\">NULL</span>, &amp;p))&#123;\t\t\t<span class=\"comment\">/*查找不成功*/</span></span><br><span class=\"line\">        s = new BiTNode;</span><br><span class=\"line\">        s-&gt;data = key;</span><br><span class=\"line\">        s-&gt;lchild = s-&gt;rchild = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!p)</span><br><span class=\"line\">            *T = s;\t\t\t\t\t\t\t\t<span class=\"comment\">/*插入s为新的根结点*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; p-&gt;data;)\t\t\t\t</span><br><span class=\"line\">            p-&gt;lchild = s;\t\t\t\t\t\t<span class=\"comment\">/*插入s为左孩子*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            p-&gt;rchild = s;\t\t\t\t\t\t<span class=\"comment\">/*插入s为右孩子*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;\t\t\t\t\t\t\t<span class=\"comment\">/*树中已有与关键字相同结点，不再插入*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-3删除操作\"><a href=\"#5-3删除操作\" class=\"headerlink\" title=\"5.3删除操作\"></a>5.3删除操作</h3><p>删除结点三种情况</p>\n<ul>\n<li>叶子结点</li>\n<li>仅有左子树或右子树结点</li>\n<li>左右子树都有的结点</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查找关键字等于key的结点，找到则删除数据结点</span></span><br><span class=\"line\">Status <span class=\"title function_\">DeleteBST</span><span class=\"params\">(BiTree *T, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!T)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FLASE;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == T-&gt;data)\t\t\t\t\t\t<span class=\"comment\">/*找到关键字key的数据元素*/</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Delete(T);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; T-&gt;data)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DeleteBST(T-&gt;lchild, key);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"keyword\">return</span> DeleteBST(T-&gt;rchild, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码与二叉排序树查找几乎完全相同，区别在于找到后执行的是删除操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">Delete</span><span class=\"params\">(BiTree *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//从二叉排序树中删除结点p，并重接他的左右子树</span></span><br><span class=\"line\">    BiTree *q, *s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;rchild == <span class=\"literal\">NULL</span>)&#123;\t\t\t\t\t\t<span class=\"comment\">/*右子树空则重接左子树(叶子也走此分支)*/</span></span><br><span class=\"line\">        q = p;</span><br><span class=\"line\">        p = p-&gt;lchild;</span><br><span class=\"line\">        delete(q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p-&gt;lchild == <span class=\"literal\">NULL</span>)&#123;\t\t\t\t<span class=\"comment\">/*左子树空则重接右子树*/</span></span><br><span class=\"line\">        q = p;</span><br><span class=\"line\">        p = p-&gt;rchild;</span><br><span class=\"line\">        delete q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*左右均不空*/</span></span><br><span class=\"line\">        q = p;</span><br><span class=\"line\">        s = p-&gt;lchild;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s-&gt;rchild)&#123;\t\t\t\t\t\t<span class=\"comment\">/*找到左子树的右结点（找到待删结点的前驱）*/</span></span><br><span class=\"line\">            q = s;</span><br><span class=\"line\">            s = s-&gt;rchild;</span><br><span class=\"line\">        &#125;\t\t\t\t\t</span><br><span class=\"line\">        p-&gt;data = s-&gt;data;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q != p)</span><br><span class=\"line\">            q-&gt;rchild = s-&gt;lchild;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            q-&gt;lchild = s-&gt;lchild;</span><br><span class=\"line\">        delete s;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-平衡二叉树\"><a href=\"#6-平衡二叉树\" class=\"headerlink\" title=\"6.平衡二叉树\"></a>6.平衡二叉树</h2><p>平衡二叉树是一种二叉排序树，其中每个结点的左子树和右子树高度差至多为1</p>\n<p>是一种高度平衡的二叉排序树，二叉树上节点的左子树高度减去右子树高度的值称为<strong>平衡因子BF(Balance Factor)</strong></p>\n<p>那么平衡二叉树上所有结点的平衡因子只可能是1、0、-1</p>\n<p>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为<strong>最小不平衡树</strong></p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\n\tA1((A)) --- B1((B)) &amp; D1(( ))\n\tB1 --- C1((C)) &amp; E1(( ))\n\t%%style D fill:#f100,stroke-width:0px\n    %%style E fill:#f100,stroke-width:0px%% 设置F属性为填充为白色，边框宽度为0\n    linkStyle 1 stroke:#off, stroke-width:0px;\n    linkStyle 3 stroke:#off, stroke-width:0px;\n    \n    \n\tA2((A)) --- B2((B)) &amp; D2(( ))\n\tB2 --- C2(( )) &amp; E2((C))\n    linkStyle 5 stroke:#off, stroke-width:0px;\n    linkStyle 6 stroke:#off, stroke-width:0px;\n    \n    A3((A)) --- B3(( )) &amp; D3((B))\n\tD3 --- C3((C)) &amp; E3(( ))\n    linkStyle 8 stroke:#off, stroke-width:0px;\n    linkStyle 11 stroke:#off, stroke-width:0px;\n    \n    A4((A)) --- B4(( )) &amp; D4((B))\n\tD4 --- C4(( )) &amp; E4((C))\n    linkStyle 12 stroke:#off, stroke-width:0px;\n    linkStyle 14 stroke:#off, stroke-width:0px;\n    \n    class D1,E1,D2,C2,B3,E3,B4,C4 X;\n\tclassDef X fill:#f100, stroke-width:0px;\n  </pre></div>\n\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden>\n  graph TD\n\tA1((B)) --- B1((C)) &amp; D1((A))\n\tA2((C)) --- B2((B)) &amp; D2((A))\n\tA3((C)) --- B3((A)) &amp; D3((B))\n\tA4((B)) --- B4((A)) &amp; D4((C))\n  </pre></div>\n\n<h3 id=\"6-1代码实现\"><a href=\"#6-1代码实现\" class=\"headerlink\" title=\"6.1代码实现\"></a>6.1代码实现</h3><p><strong>结点结构</strong></p>\n<p>增加一个变量<code>bf</code>用来存储平衡因子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>;</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    <span class=\"type\">int</span> bf;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>\n\n<p><strong>右旋操作</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对P为根的二叉排序树作右旋处理</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">R_Rotate</span><span class=\"params\">(BiTree *p)</span>&#123;</span><br><span class=\"line\">    BiTree *L;</span><br><span class=\"line\">    L = p-&gt;lchild;</span><br><span class=\"line\">    p-&gt;lchild = L-&gt;lchild;</span><br><span class=\"line\">    L-&gt;rchild = p;</span><br><span class=\"line\">    p = L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>左旋操作</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对P为根的二叉排序树作左旋处理</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">L_Rotate</span><span class=\"params\">(BiTree *p)</span>&#123;</span><br><span class=\"line\">    BiTree *R;</span><br><span class=\"line\">\tR = p-&gt;rchild;</span><br><span class=\"line\">    p-&gt;rchild = R-&gt;lchild;</span><br><span class=\"line\">    R-&gt;lchild = p;</span><br><span class=\"line\">    p = L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>左平衡旋转</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LH +1\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*左高*/</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EH 0\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*等高*/</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RH -1\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*右高*/</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LeftBalance</span><span class=\"params\">(BiTree *T)</span>&#123;</span><br><span class=\"line\">    BiTree *L, *Lr;</span><br><span class=\"line\">    L = T-&gt;lchild;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (L-&gt;bf)&#123;\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*检查T的左子树平衡度，并做相应处理*/</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> LH:\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*（LL）新结点插入在T的左孩子的左子树上，要作单右旋处理*/</span></span><br><span class=\"line\">            T-&gt;bf = L-&gt;bf =EH;</span><br><span class=\"line\">            R_Rotate(T);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RH:\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*新结点插入在T的左孩子的右子树上，要做双旋处理*/</span></span><br><span class=\"line\">            Lr =L-&gt;rchild;\t\t\t\t\t\t\t<span class=\"comment\">/*Lr指向T的左孩子的右子树根*/</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (Lr-&gt;bf)&#123;\t\t\t\t\t\t<span class=\"comment\">/*修改T及其左孩子的平衡因子*/</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> LH:</span><br><span class=\"line\">                    T-&gt;bf = RH;</span><br><span class=\"line\">                    L-&gt;bf = EH;</span><br><span class=\"line\">                 \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> EH:</span><br><span class=\"line\">                    T-&gt;bf = L-&gt;bf =EH;</span><br><span class=\"line\">                \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> RH:</span><br><span class=\"line\">                    T-&gt;bf = EH;</span><br><span class=\"line\">                    L-&gt;bf = LH;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Lr-&gt;bf =EH;</span><br><span class=\"line\">            L_Rotate(T-&gt;lchild);</span><br><span class=\"line\">            R_Rotate(T);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>右平衡旋转</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">RightBalance</span><span class=\"params\">(BiTree *T)</span>&#123;</span><br><span class=\"line\">    BiTree *R, *Rl;</span><br><span class=\"line\">    R = T-&gt;lchild;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (R-&gt;bf)&#123;\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*检查T的右子树平衡度，并做相应处理*/</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> RH:\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*（RR）新结点插入在T的右孩子的右子树上，要作单左旋处理*/</span></span><br><span class=\"line\">            T-&gt;bf = R-&gt;bf =EH;</span><br><span class=\"line\">            L_Rotate(T);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> LH:\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*新结点插入在T的右孩子的左子树上，要做双旋处理*/</span></span><br><span class=\"line\">            Rl =R-&gt;lchild;\t\t\t\t\t\t\t<span class=\"comment\">/*Rl指向T的右孩子的左子树根*/</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (Rl-&gt;bf)&#123;\t\t\t\t\t\t<span class=\"comment\">/*修改T及其右孩子的平衡因子*/</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> RH:</span><br><span class=\"line\">                    T-&gt;bf = LH;</span><br><span class=\"line\">                    R-&gt;bf = EH;</span><br><span class=\"line\">                 \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> EH:</span><br><span class=\"line\">                    T-&gt;bf = R&gt;bf =EH;</span><br><span class=\"line\">                \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> LH:</span><br><span class=\"line\">                    T-&gt;bf = EH;</span><br><span class=\"line\">                    R-&gt;bf = RH;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Rl-&gt;bf =EH;</span><br><span class=\"line\">            R_Rotate(T-&gt;rchild);</span><br><span class=\"line\">            L_Rotate(T);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"7-多路查找树（B树）\"><a href=\"#7-多路查找树（B树）\" class=\"headerlink\" title=\"7.多路查找树（B树）\"></a>7.多路查找树（B树）</h2><p><strong>多路查找树（Muiltl-Way Search Tree）</strong>，其每个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</p>\n<p>设置一个结点数据元素上限set a cap on the num of items</p>\n<p>如果超出上限，就将其中一个元素给双亲结点if more than cap, give an item to parent</p>\n<p><strong>left-middle</strong></p>\n<p>再将超出上限的结点分成左右两个结点</p>\n<h3 id=\"7-1-2-3树\"><a href=\"#7-1-2-3树\" class=\"headerlink\" title=\"7.1 2-3树\"></a>7.1 2-3树</h3><p>每个结点都有两个孩子或三个孩子</p>\n<p>一个2结点包含一个元素和两个孩子（或没有孩子）</p>\n<p>一个3结点包含一小一大两个元素和三个孩子（或没有孩子）</p>\n<h3 id=\"7-2-2-3-4树\"><a href=\"#7-2-2-3-4树\" class=\"headerlink\" title=\"7.2 2-3-4树\"></a>7.2 2-3-4树</h3><p>一个4结点包含小中大3个元素和4个孩子（或没有孩子）</p>\n<h3 id=\"7-3-B树\"><a href=\"#7-3-B树\" class=\"headerlink\" title=\"7.3 B树\"></a>7.3 B树</h3><p>**B树(B-tree)**是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例</p>\n<p>结点最大的孩子数目称为B树的阶</p>\n<h3 id=\"7-4-B-树\"><a href=\"#7-4-B-树\" class=\"headerlink\" title=\"7.4 B+树\"></a>7.4 B+树</h3><h2 id=\"8-散列表（哈希表）\"><a href=\"#8-散列表（哈希表）\" class=\"headerlink\" title=\"8.散列表（哈希表）\"></a>8.散列表（哈希表）</h2><h3 id=\"8-1定义\"><a href=\"#8-1定义\" class=\"headerlink\" title=\"8.1定义\"></a>8.1定义</h3><p>$存储位置 &#x3D; f (关键字)$</p>\n<p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系$f$,使得每个关键字key对应一个存储位置$f(key)$</p>\n<p>对应关系$f$称为<strong>散列函数</strong>，又称<strong>哈希(Hash)函数</strong></p>\n<p>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为<strong>散列表</strong>或<strong>哈希表(Hash Table)</strong></p>\n<p>散列技术既是一种存储方法，也是一种查找方法</p>\n<p>散列技术最适合的求解问题是查找与给定值相等的记录</p>\n<p>两个关键字$key_1 \\neq key_2$，但是却有$f(key_1) &#x3D; f(key)_2$，这种现象我们称为**冲突(collision)**，并把$key_1$和$key_2$称为这个函数的同义词(synonym)</p>\n<h3 id=\"8-2构造方法\"><a href=\"#8-2构造方法\" class=\"headerlink\" title=\"8.2构造方法\"></a>8.2构造方法</h3><p> 原则</p>\n<ol>\n<li>计算简单</li>\n<li>散列地址分布均匀</li>\n</ol>\n<p><strong>1.直接定址法</strong></p>\n<p>去关键字的某个线性函数值为散列地址</p>\n<p>$f(key) &#x3D; a * key + b$</p>\n<p><strong>2.数字分析法</strong></p>\n<p><strong>3.平方取中法</strong></p>\n<p><strong>4.折叠法</strong></p>\n<p><strong>5.除留余数法</strong></p>\n<p>f(key) &#x3D; key  mod  p</p>\n<p><strong>6.随机数法</strong></p>\n<h3 id=\"8-3处理散列冲突\"><a href=\"#8-3处理散列冲突\" class=\"headerlink\" title=\"8.3处理散列冲突\"></a>8.3处理散列冲突</h3><p><strong>1.开放定址法</strong></p>\n<p>开放定址法是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p>\n<p>公式是</p>\n<p>$f_i(key) &#x3D; (f(key)+d_i) MOD m$  $d_i &#x3D; 1, 2, 3, …, m-1$</p>\n<p><strong>线性探测法</strong></p>\n<p>本来就不为同义词却争夺同一地址的情况，称为<strong>堆积</strong></p>\n<p>$f_i(key) &#x3D; (f(key)+d_i) MOD m$  $d_i &#x3D; 1^2, -1^, 2^2, -2^2,…,q^2, -q^2, q\\leq m&#x2F;2$</p>\n<p>增加平方运算的目的是为了不让关键字都聚集在某一块区域，这种方法称为<strong>二次探测法</strong></p>\n<p><strong>2.再散列函数法</strong></p>\n<p>对于散列表，实现准备多个散列函数</p>\n<p>$f_i(key) &#x3D; RH_i(key)$</p>\n<p>这种方法可以使得关键字不产生聚集，相应增加了计算时间</p>\n<p><strong>3.链地址法</strong></p>\n<p>将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表</p>\n<p>在散列表中只存储所有同义词子表头指针，无论有多少冲突，都只是在当前位置给单链表增加节点的问题</p>\n<p>提供了不会出现找不到地址的保障，但查找时需要遍历单链表造成性能损耗</p>\n<p><strong>4.公共溢出区法</strong></p>\n<p>为所有冲突关键字建立一个公共溢出区来存放</p>\n<p>查找时，对给定值通过散列表计算出散列地址后，先于基本表的相应位置进行对比，相等则查找成功</p>\n<p>不相等，则到溢出表进行顺序查找</p>\n<p>相对于基本表而言，冲突数据较少的情况下，公共溢出区的结构对查找性能来说还是非常高的</p>\n<h3 id=\"8-4散列表查找的实现\"><a href=\"#8-4散列表查找的实现\" class=\"headerlink\" title=\"8.4散列表查找的实现\"></a>8.4散列表查找的实现</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SUCCESS 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UNSUCCESS 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HASHSIZE 12</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NULLKEY -32768</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *elem;\t\t\t\t<span class=\"comment\">/*数据元素存储基址，动态分配数组*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count;\t\t\t\t<span class=\"comment\">/*当前数据元素个数*/</span></span><br><span class=\"line\">&#125;HashTable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m = <span class=\"number\">0</span>;\t\t\t\t\t<span class=\"comment\">/*散列表表长，全局变量*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化散列表</span></span><br><span class=\"line\">Status <span class=\"title function_\">InitHashTable</span><span class=\"params\">(HashTable *H)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    m = HASHSIZE;</span><br><span class=\"line\">    H-&gt;count = m;</span><br><span class=\"line\">    H-&gt;elem = new <span class=\"type\">int</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        H-&gt;elem[i] = NULLKEY；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//散列函数</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Hash</span><span class=\"params\">(<span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key % m;        <span class=\"comment\">/*除留余数法*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入关键字进散列表</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InsertHash</span><span class=\"params\">(HashTable *H, <span class=\"type\">int</span> key)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> addr = Hash(key);\t\t\t\t<span class=\"comment\">/*求散列地址*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (H-&gt;elem[addr] != NULLKEY)&#123;\t<span class=\"comment\">/*若不为空，则冲突*/</span></span><br><span class=\"line\">        addr = (addr + <span class=\"number\">1</span>) % m;\t\t\t<span class=\"comment\">/*开放定址法的线性探测*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    H-&gt;elem[addr] = key;\t\t\t\t<span class=\"comment\">/*直到有空位后插入关键字*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//散列表查找关键字</span></span><br><span class=\"line\">Status <span class=\"title function_\">SearchHash</span><span class=\"params\">(HashTable H, <span class=\"type\">int</span> key, <span class=\"type\">int</span> *addr)</span>&#123;</span><br><span class=\"line\">    *addr = Hash(key);\t\t\t\t\t<span class=\"comment\">/*求散列地址*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (H.elem[*addr] != key)&#123;\t\t</span><br><span class=\"line\">        *addr = (*addr + <span class=\"number\">1</span>) % m;\t\t<span class=\"comment\">/*开放定址法的线性探测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key))\t\t<span class=\"comment\">/*若循环回到原点*/</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> UNSUCCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><p>优秀排序算法的首要条件就是<strong>速度</strong></p>\n<h2 id=\"1-基本概念与分类\"><a href=\"#1-基本概念与分类\" class=\"headerlink\" title=\"1.基本概念与分类\"></a>1.基本概念与分类</h2><p><strong>1.排序的稳定性</strong></p>\n<p>假设$k_i &#x3D; k_j$，且在排序前的序列中$r_i$领先与$r_j$即（$i &lt; j$）</p>\n<p>如果排序后$r_i$仍领先与$r_j$，则称所用的排序方法是稳定的；</p>\n<p>反之，若可能使得排序后的序列中$r_j$领先与$r_i$，则称所用的排序的方法是不稳定的</p>\n<p><strong>2.内排序与外排序</strong></p>\n<p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中</p>\n<p>外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行</p>\n<h2 id=\"2-结构与函数\"><a href=\"#2-结构与函数\" class=\"headerlink\" title=\"2.结构与函数\"></a>2.结构与函数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 1000</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> r[MAXSIZE + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//交换L中数组r的下标为i和j的值</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> temp = L-&gt;r[i];</span><br><span class=\"line\">    L-&gt;r[i] = L-&gt;r[j];</span><br><span class=\"line\">    L-&gt;r[j]\t= temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-冒泡排序\"><a href=\"#3-冒泡排序\" class=\"headerlink\" title=\"3.冒泡排序\"></a>3.冒泡排序</h2><p>冒泡排序是一种交换排序，最基本的思想是两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表进行冒泡排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BubbleSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; L-&gt;length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = L-&gt;length - <span class=\"number\">1</span>; j &gt;= i; j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (L-&gt;r[j - <span class=\"number\">1</span>] &gt; L-&gt;r[j])</span><br><span class=\"line\">                swap(L, j<span class=\"number\">-1</span>, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>冒泡排序优化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//改进</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">BubbleSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"comment\">/////////</span></span><br><span class=\"line\">    Status flag = TRUE;</span><br><span class=\"line\">    <span class=\"comment\">/////////</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; L-&gt;length &amp;&amp; flag; i++)&#123;</span><br><span class=\"line\">        flag = FALSE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = L-&gt;length - <span class=\"number\">1</span>; j &gt;= i; j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (L-&gt;r[j - <span class=\"number\">1</span>] &gt; L-&gt;r[j])&#123;</span><br><span class=\"line\">                swap(L, j<span class=\"number\">-1</span>, j);</span><br><span class=\"line\">                flag = TRUE;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总的时间复杂度为O($n^2$)</strong></p>\n<h2 id=\"4-简单选择排序\"><a href=\"#4-简单选择排序\" class=\"headerlink\" title=\"4.简单选择排序\"></a>4.简单选择排序</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L作简单选择排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SelectSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, min;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; L-&gt;length; i++)&#123;</span><br><span class=\"line\">        min = i;\t\t\t\t\t\t\t\t<span class=\"comment\">/*当前下标定义为最小值*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt;= L-&gt;length; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (L-&gt;r[min] &gt; L-&gt;r[j])\t\t\t<span class=\"comment\">/*如果有小于当前最小值的关键字，将此关键字下标赋值给min*/</span></span><br><span class=\"line\">                min = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != min)\t\t\t\t\t\t\t<span class=\"comment\">/*若min不等于i，说明找到最小值，交换*/</span></span><br><span class=\"line\">            swap(L, i, min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度为O($n^2$)</strong></p>\n<p>性能上略优于冒泡排序</p>\n<h2 id=\"5-直接插入排序\"><a href=\"#5-直接插入排序\" class=\"headerlink\" title=\"5.直接插入排序\"></a>5.直接插入排序</h2><p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L作直接插入排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InsertSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= L-&gt;length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class=\"number\">1</span>])&#123;\t\t\t\t<span class=\"comment\">/*将L-&gt;r[i]插入有序子表*/</span></span><br><span class=\"line\">            L-&gt;r[<span class=\"number\">0</span>] = L-&gt;r[i];\t\t\t\t\t<span class=\"comment\">/*设置哨兵*/</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i - <span class=\"number\">1</span>; L-&gt;r[j] &gt; L-&gt;r[<span class=\"number\">0</span>]; j--)</span><br><span class=\"line\">                L-&gt;r[j + <span class=\"number\">1</span>] = L-&gt;r[j];\t\t\t<span class=\"comment\">/*记录后移*/</span></span><br><span class=\"line\">            L-&gt;r[j + <span class=\"number\">1</span>] = L-&gt;r[<span class=\"number\">0</span>];\t\t\t\t<span class=\"comment\">/*插入到正确位置*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度为O($n^2$)</strong></p>\n<p>性能上略优于冒泡排序和简单选择排序</p>\n<h2 id=\"6-希尔排序\"><a href=\"#6-希尔排序\" class=\"headerlink\" title=\"6.希尔排序\"></a>6.希尔排序</h2><p>(shell Sort)</p>\n<p><strong>基本有序</strong>：小的关键字基本在前面，大的基本在后面，不大不小的基本在中间</p>\n<p>将相距某个”增量“的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//希尔排序算法</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ShellSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> increment = L-&gt;length;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        increment = increment/<span class=\"number\">3</span> + <span class=\"number\">1</span>;\t\t\t\t\t<span class=\"comment\">/*增量序列*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = increment + <span class=\"number\">1</span>; i &lt;= L-&gt;length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - increment])&#123;\t\t\t<span class=\"comment\">/*需将L-&gt;[i]插入有序增量子表*/</span></span><br><span class=\"line\">                L-&gt;r[<span class=\"number\">0</span>] = L-&gt;r[i];\t\t\t\t\t\t<span class=\"comment\">/*暂存在L-&gt;r[0]*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (j = i - increment; j &gt; <span class=\"number\">0</span> &amp;&amp; L-&gt;r[<span class=\"number\">0</span>] &lt; L-&gt;r[j]; j -= increment)</span><br><span class=\"line\">                    L-&gt;r[j + increment] = L-&gt;r[j];\t\t<span class=\"comment\">/*记录后移，查找插入位置*/</span></span><br><span class=\"line\">                L-&gt;r[j + increment] = L-&gt;r[<span class=\"number\">0</span>];\t\t\t<span class=\"comment\">/*插入*/</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span> (increment &gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>增量序列最后一个增量值必须等于1</strong></p>\n<p>时间复杂度O($n^\\frac{3}{2}$)</p>\n<h2 id=\"7-堆排序\"><a href=\"#7-堆排序\" class=\"headerlink\" title=\"7.堆排序\"></a>7.堆排序</h2><p>堆是具有下列性质的二叉树：</p>\n<ul>\n<li>每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong></li>\n<li>或者每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L进行堆排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HeapSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = L-&gt;length/<span class=\"number\">2</span>; i &gt; <span class=\"number\">0</span>; i--)\t\t\t\t\t<span class=\"comment\">/*构造大顶堆*/</span></span><br><span class=\"line\">        HeapAdjust(L, i, L-&gt;length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = L-&gt;length; i &gt; <span class=\"number\">1</span>; i--)&#123;\t\t\t\t\t</span><br><span class=\"line\">        swap(L, <span class=\"number\">1</span>, i);\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*将堆顶记录和当前未经排序子序列最后一记录交换*/</span></span><br><span class=\"line\">        HeapAdjust(L, <span class=\"number\">1</span>, i - <span class=\"number\">1</span>);\t\t\t\t\t\t<span class=\"comment\">/*将L-&gt;r[1..i - 1]重新调整为大顶堆*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//堆调整</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HeapAdjust</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> s, <span class=\"type\">int</span> m)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> temp, j;</span><br><span class=\"line\">    temp = L-&gt;r[s];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">2</span> * s; j &lt;= m; j *= <span class=\"number\">2</span>)&#123;\t\t\t\t\t<span class=\"comment\">/*沿关键字较大的孩子结点向下筛选*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">            ++j;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*j为关键字中较大的记录的下标*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp &gt;= L-&gt;r[j])</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*rc应插入在位置s上*/</span></span><br><span class=\"line\">        L-&gt;r[s] = L-&gt;r[j];</span><br><span class=\"line\">        s = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;r[s] = temp;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">/*插入*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排序</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = L-&gt;lenth; i &gt; <span class=\"number\">1</span>; i--)&#123;</span><br><span class=\"line\">    swap(L, <span class=\"number\">1</span>, i);</span><br><span class=\"line\">    HeapAdjust(L, <span class=\"number\">1</span>, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>时间复杂度O(nlogn)</strong></p>\n<p>记录的比较是跳跃式进行，所以堆排序是一种不稳定的排序方法</p>\n<p>初始构建堆所需要的次数较多，不适合待排序序列个数较少情况</p>\n<h2 id=\"8-归并排序\"><a href=\"#8-归并排序\" class=\"headerlink\" title=\"8.归并排序\"></a>8.归并排序</h2><p><strong>归并排序（Merging Sort）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L作归并排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MergeSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    Msort(L-&gt;r, L-&gt;r, <span class=\"number\">1</span>, L-&gt;length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MSort</span><span class=\"params\">(<span class=\"type\">int</span> SR[], <span class=\"type\">int</span> TR1[], <span class=\"type\">int</span> s, <span class=\"type\">int</span> t)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m;</span><br><span class=\"line\">    <span class=\"type\">int</span> TR2[MAXSIZE + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == t)&#123;</span><br><span class=\"line\">        TR1[s] = SR[s];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;\t</span><br><span class=\"line\">        m = (s + t) / <span class=\"number\">2</span>;\t\t\t\t\t<span class=\"comment\">/*将SR[s..t]平分为SR[s..m]和s[m+1..t]*/</span></span><br><span class=\"line\">        MSort(SR, TR2, s, m);\t\t\t\t<span class=\"comment\">/*将SR[s..m]归并为有序序列TR2[s..m]*/</span></span><br><span class=\"line\">        MSort(SR, TR2, m + <span class=\"number\">1</span>, t);\t\t\t<span class=\"comment\">/*将SR[m+1..t]归并为有序序列TR2[m+1..t]*/</span></span><br><span class=\"line\">        Merge(SR, TR2, s, m, t);\t\t\t<span class=\"comment\">/*将TR2[s..m]和TR2[m+1..t]归并到TR1[s..m]*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将SR[s..m]和SR[m+1..t]归并到TR[s..m]</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Merge</span><span class=\"params\">(<span class=\"type\">int</span> SR[], <span class=\"type\">int</span> TR[], <span class=\"type\">int</span> i, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j, k, l;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = m + <span class=\"number\">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)&#123;\t\t\t<span class=\"comment\">/*将SR中记录由小到大并入TR*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SR[i] &lt; SR[J])</span><br><span class=\"line\">            TR[k] = SR[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            TR[k] = SR[j++];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= m)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (l = <span class=\"number\">0</span>; l &lt;= m - i; l++)</span><br><span class=\"line\">                TR[k + l] = SR[i + l];\t\t\t\t\t\t<span class=\"comment\">/*将剩余SR[i..m]复制到TR*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt;= n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (l = <span class=\"number\">0</span>; l &lt;= n - j; l++)</span><br><span class=\"line\">                TR[k + l] = SR[j + l];\t\t\t\t\t\t<span class=\"comment\">/*将剩余SR[j..n]复制到TR*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度O(nlogn)</strong></p>\n<p>归并排序是一种稳定的排序算法，比较占用内存，但效率高且稳定</p>\n<h2 id=\"9-快速排序\"><a href=\"#9-快速排序\" class=\"headerlink\" title=\"9.快速排序\"></a>9.快速排序</h2><p><strong>快速排序（Quick Sort）</strong>的基本思想是：通过一趟排序将待排记录分割成独立的两部分</p>\n<p>其中一部分记录的关键字比另一部分小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L作快速排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">QuickSort</span><span class=\"params\">(SqList *L)</span>&#123;</span><br><span class=\"line\">    QSort(L, <span class=\"number\">1</span>, L-&gt;length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对顺序表L中子序列L-&gt;r[low..high]作快速排序</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">QSort</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivot;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将L-&gt;r[low..high]一分为二，算出枢轴值pivot</span></span><br><span class=\"line\">        pivot = Partition(L, low, high);</span><br><span class=\"line\">        QSort(L, low, pivot - <span class=\"number\">1</span>);\t\t\t<span class=\"comment\">/*对低子表递归排序*/</span></span><br><span class=\"line\">        QSort(L, pivot + <span class=\"number\">1</span>, high);\t\t\t<span class=\"comment\">/*对高子表递归排序*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Patition（）要做的，就是选取当中一个关键字，想尽办法将它放到一个位置</p>\n<p>使得它左边的值都比它小，右边的值都比它大，这样的关键词称为枢轴(Pivot)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Patition</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivotkey;</span><br><span class=\"line\">    pivotkey = L-&gt;r[low];\t\t\t\t<span class=\"comment\">/*用子表的第一个记录作枢轴记录*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high)&#123;\t\t\t\t\t<span class=\"comment\">/*从表的两端交替地向中间扫描*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &gt;= pivotkey)</span><br><span class=\"line\">            high--;</span><br><span class=\"line\">        swap(L, low, high);\t\t\t\t<span class=\"comment\">/*将比枢轴记录小的记录交换到低端*/</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class=\"line\">            low++;</span><br><span class=\"line\">        swap(L, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;\t\t\t\t\t\t\t<span class=\"comment\">/*返回枢轴所在位置*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>时间复杂度O($n^2$)</strong></p>\n<p>由于关键字比较和交换是跳跃进行，因此快速排序是一种不稳定排序</p>\n<h4 id=\"快速排序优化\"><a href=\"#快速排序优化\" class=\"headerlink\" title=\"快速排序优化\"></a><strong>快速排序优化</strong></h4><h5 id=\"1-优化选取枢轴\"><a href=\"#1-优化选取枢轴\" class=\"headerlink\" title=\"1.优化选取枢轴\"></a>1.优化选取枢轴</h5><ul>\n<li>固定选取（原）</li>\n<li>随机选取</li>\n<li>三数取中</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> pivotkey;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (L-&gt;r[low] &gt; L -&gt;r[high])</span><br><span class=\"line\">    swap(L, low, high);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (L-&gt;r[m] &gt; L -&gt;r[high])</span><br><span class=\"line\">    swap(L, m, high);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (L-&gt;r[low] &gt; L -&gt;r[m])</span><br><span class=\"line\">    swap(L, low, high);</span><br><span class=\"line\"><span class=\"comment\">//此时，r[low]已经为整个序列左、中、右三个关键字的中间值</span></span><br><span class=\"line\"></span><br><span class=\"line\">pivokey = L-&gt;r[low];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>九数取中</li>\n</ul>\n<h5 id=\"2-优化不必要的交换\"><a href=\"#2-优化不必要的交换\" class=\"headerlink\" title=\"2.优化不必要的交换\"></a>2.优化不必要的交换</h5><p>&#x3D;&#x3D;<code>L-&gt;r[0] = pivotkey</code>&#x3D;&#x3D;</p>\n<p>采用替换而不是交换的方式进行操作</p>\n<p>L-&gt;r[low] &#x3D; L-&gt;r[high]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Patition</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivotkey;</span><br><span class=\"line\">    pivotkey = L-&gt;r[low];\t\t\t\t<span class=\"comment\">/*用子表的第一个记录作枢轴记录*/</span></span><br><span class=\"line\">    L-&gt;r[<span class=\"number\">0</span>] = pivotkey</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high)&#123;\t\t\t\t\t<span class=\"comment\">/*从表的两端交替地向中间扫描*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &gt;= pivotkey)</span><br><span class=\"line\">            high--;</span><br><span class=\"line\">        L-&gt;r[low] = L-&gt;r[high]\t\t\t<span class=\"comment\">/*采用替换而不是交换的方式进行操作*/</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class=\"line\">            low++;</span><br><span class=\"line\">        L-&gt;r[high] = L-&gt;r[low]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;r[low] = L-&gt;r[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;\t\t\t\t\t\t\t<span class=\"comment\">/*返回枢轴所在位置*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-优化小数组时的排序方案\"><a href=\"#3-优化小数组时的排序方案\" class=\"headerlink\" title=\"3.优化小数组时的排序方案\"></a>3.优化小数组时的排序方案</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_LENGTH_INSERT_SORT 7</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">QSort</span><span class=\"params\">(SqList *L, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivot;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)&#123;</span><br><span class=\"line\">        ......\t\t\t\t\t\t\t<span class=\"comment\">/*采用快速排序*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        InsertSort(L);\t\t\t\t\t<span class=\"comment\">/*直接用插入排序*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"4-优化递归操作\"><a href=\"#4-优化递归操作\" class=\"headerlink\" title=\"4.优化递归操作\"></a>4.优化递归操作</h5><h2 id=\"10-总结对比\"><a href=\"#10-总结对比\" class=\"headerlink\" title=\"10.总结对比\"></a>10.总结对比</h2><table>\n<thead>\n<tr>\n<th align=\"center\">排序方法</th>\n<th align=\"center\">平均情况</th>\n<th align=\"center\">最好情况</th>\n<th align=\"center\">最坏情况</th>\n<th align=\"center\">辅助空间</th>\n<th align=\"center\">稳定性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">冒泡排序</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($n$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">简单选择排序</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">直接插入排序</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($n)$</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">希尔排序</td>\n<td align=\"center\">O($n\\log{n}$)~O($n^2$)</td>\n<td align=\"center\">O($n^\\frac{3}{2}$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">堆排序</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">归并排序</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">快速排序</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n\\log{n}$)</td>\n<td align=\"center\">O($n^2$)</td>\n<td align=\"center\">O($\\log{n}$)~O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n</tbody></table>\n<ul>\n<li>简单算法：冒泡、简单选择、直接插入</li>\n<li>改进算法：希尔、堆、归并、快速</li>\n</ul>\n<p>从<strong>平均情况</strong>看，最后三种改进算法胜过希尔排序，并远胜于3钟简单算法</p>\n<p>从<strong>最好情况</strong>看，冒泡和直接插入排序更胜一筹。如果待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法</p>\n<p>从<strong>最坏情况</strong>看，堆排序与归并排序强于快速排序及其他简单排序</p>\n<p>从<strong>稳定性</strong>看，归并排序独占鳌头，对非常在乎排序稳定性的应用中，归并排序是个好算法</p>\n<p>从<strong>待排序记录的个数</strong>上看，待排序的个数越小，采用简单排序方法就越合适</p>\n"},{"title":"vscode远程免密连接","date":"2023-08-09T06:00:00.000Z","_content":"# 1.先在本地端生成密钥\n\n## 生成SSH密钥\n\n```bash\n# -t 加密类型 -b 指定指定要创建的密钥的位数\n$ ssh-keygen -t rsa -b 4096\n```\n\n连续按回车\n\n## 查看公钥\n\n```bash\n$ cat ~/.ssh/id_rsa.pub\n```\n\n将``id_rsa.pub``中的内容复制下来\n\n# 2.将本地端公钥添加至远程端\n\n## 添加\n\n```bash\n$ cd ~/.ssh\n$ vim authorized_keys #\n```\n\n将从``id_rsa.pub``中复制的内容贴进``authorized_keys``中\n\n## 权限设置\n\n```bash\n$ chmod 600 authorized_keys  #所有者可读写\n```\n\n# 3.vscode端\n\n## ssh config\n\n```bash\nHost $远程主机名$   #可以自定义，目的是知道自己用什么主机\n  HostName $远程主机IP$\n  User $用户名$\n  Port $ssh端口$   #不写默认22\n  IdentityFile $本机SSH私钥路径$\n  ForwardAgent yes $希望使用本地电脑里的密钥登录，且不想把这个密钥发送到堡垒机，之前添加 -A生成$\n```\n\n一般只配置``Host`` |``HostName``|``User``即可\n","source":"_posts/vscodessh.md","raw":"---\ntitle: vscode远程免密连接\ncategories: 实用技巧\ndate: 2023-08-09 14:00:00\n---\n# 1.先在本地端生成密钥\n\n## 生成SSH密钥\n\n```bash\n# -t 加密类型 -b 指定指定要创建的密钥的位数\n$ ssh-keygen -t rsa -b 4096\n```\n\n连续按回车\n\n## 查看公钥\n\n```bash\n$ cat ~/.ssh/id_rsa.pub\n```\n\n将``id_rsa.pub``中的内容复制下来\n\n# 2.将本地端公钥添加至远程端\n\n## 添加\n\n```bash\n$ cd ~/.ssh\n$ vim authorized_keys #\n```\n\n将从``id_rsa.pub``中复制的内容贴进``authorized_keys``中\n\n## 权限设置\n\n```bash\n$ chmod 600 authorized_keys  #所有者可读写\n```\n\n# 3.vscode端\n\n## ssh config\n\n```bash\nHost $远程主机名$   #可以自定义，目的是知道自己用什么主机\n  HostName $远程主机IP$\n  User $用户名$\n  Port $ssh端口$   #不写默认22\n  IdentityFile $本机SSH私钥路径$\n  ForwardAgent yes $希望使用本地电脑里的密钥登录，且不想把这个密钥发送到堡垒机，之前添加 -A生成$\n```\n\n一般只配置``Host`` |``HostName``|``User``即可\n","slug":"vscodessh","published":1,"updated":"2023-08-18T13:51:02.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllhr6jil000leqjg8rv94kfd","content":"<h1 id=\"1-先在本地端生成密钥\"><a href=\"#1-先在本地端生成密钥\" class=\"headerlink\" title=\"1.先在本地端生成密钥\"></a>1.先在本地端生成密钥</h1><h2 id=\"生成SSH密钥\"><a href=\"#生成SSH密钥\" class=\"headerlink\" title=\"生成SSH密钥\"></a>生成SSH密钥</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -t 加密类型 -b 指定指定要创建的密钥的位数</span></span><br><span class=\"line\">$ ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>\n\n<p>连续按回车</p>\n<h2 id=\"查看公钥\"><a href=\"#查看公钥\" class=\"headerlink\" title=\"查看公钥\"></a>查看公钥</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<p>将<code>id_rsa.pub</code>中的内容复制下来</p>\n<h1 id=\"2-将本地端公钥添加至远程端\"><a href=\"#2-将本地端公钥添加至远程端\" class=\"headerlink\" title=\"2.将本地端公钥添加至远程端\"></a>2.将本地端公钥添加至远程端</h1><h2 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/.ssh</span><br><span class=\"line\">$ vim authorized_keys <span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>将从<code>id_rsa.pub</code>中复制的内容贴进<code>authorized_keys</code>中</p>\n<h2 id=\"权限设置\"><a href=\"#权限设置\" class=\"headerlink\" title=\"权限设置\"></a>权限设置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">chmod</span> 600 authorized_keys  <span class=\"comment\">#所有者可读写</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-vscode端\"><a href=\"#3-vscode端\" class=\"headerlink\" title=\"3.vscode端\"></a>3.vscode端</h1><h2 id=\"ssh-config\"><a href=\"#ssh-config\" class=\"headerlink\" title=\"ssh config\"></a>ssh config</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host $远程主机名$   <span class=\"comment\">#可以自定义，目的是知道自己用什么主机</span></span><br><span class=\"line\">  HostName $远程主机IP$</span><br><span class=\"line\">  User $用户名$</span><br><span class=\"line\">  Port <span class=\"variable\">$ssh</span>端口$   <span class=\"comment\">#不写默认22</span></span><br><span class=\"line\">  IdentityFile $本机SSH私钥路径$</span><br><span class=\"line\">  ForwardAgent <span class=\"built_in\">yes</span> $希望使用本地电脑里的密钥登录，且不想把这个密钥发送到堡垒机，之前添加 -A生成$</span><br></pre></td></tr></table></figure>\n\n<p>一般只配置<code>Host</code> |<code>HostName</code>|<code>User</code>即可</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1-先在本地端生成密钥\"><a href=\"#1-先在本地端生成密钥\" class=\"headerlink\" title=\"1.先在本地端生成密钥\"></a>1.先在本地端生成密钥</h1><h2 id=\"生成SSH密钥\"><a href=\"#生成SSH密钥\" class=\"headerlink\" title=\"生成SSH密钥\"></a>生成SSH密钥</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -t 加密类型 -b 指定指定要创建的密钥的位数</span></span><br><span class=\"line\">$ ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>\n\n<p>连续按回车</p>\n<h2 id=\"查看公钥\"><a href=\"#查看公钥\" class=\"headerlink\" title=\"查看公钥\"></a>查看公钥</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<p>将<code>id_rsa.pub</code>中的内容复制下来</p>\n<h1 id=\"2-将本地端公钥添加至远程端\"><a href=\"#2-将本地端公钥添加至远程端\" class=\"headerlink\" title=\"2.将本地端公钥添加至远程端\"></a>2.将本地端公钥添加至远程端</h1><h2 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/.ssh</span><br><span class=\"line\">$ vim authorized_keys <span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n\n<p>将从<code>id_rsa.pub</code>中复制的内容贴进<code>authorized_keys</code>中</p>\n<h2 id=\"权限设置\"><a href=\"#权限设置\" class=\"headerlink\" title=\"权限设置\"></a>权限设置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">chmod</span> 600 authorized_keys  <span class=\"comment\">#所有者可读写</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-vscode端\"><a href=\"#3-vscode端\" class=\"headerlink\" title=\"3.vscode端\"></a>3.vscode端</h1><h2 id=\"ssh-config\"><a href=\"#ssh-config\" class=\"headerlink\" title=\"ssh config\"></a>ssh config</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host $远程主机名$   <span class=\"comment\">#可以自定义，目的是知道自己用什么主机</span></span><br><span class=\"line\">  HostName $远程主机IP$</span><br><span class=\"line\">  User $用户名$</span><br><span class=\"line\">  Port <span class=\"variable\">$ssh</span>端口$   <span class=\"comment\">#不写默认22</span></span><br><span class=\"line\">  IdentityFile $本机SSH私钥路径$</span><br><span class=\"line\">  ForwardAgent <span class=\"built_in\">yes</span> $希望使用本地电脑里的密钥登录，且不想把这个密钥发送到堡垒机，之前添加 -A生成$</span><br></pre></td></tr></table></figure>\n\n<p>一般只配置<code>Host</code> |<code>HostName</code>|<code>User</code>即可</p>\n"},{"title":"CMU15445 P2 Checkpoint1","date":"2023-08-31T07:00:00.000Z","description":"对445 B+树构造的一次总结","cover":"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/445pic1.jpg","top_img":"rgba(0,0,0,0)","_content":"## 前言\n\nP2感觉比P1的难度大了很多，内部实现基本完全由自己决定，刚上手的时候没有指引有点手足无措，但同时也代表了实现的方式可以非常自由。\n\n真的是很磨练人的一个project, 不过听说奇数年是实现hashmap要友好一些，有机会可以试一下\n\n## Task1\n\nTask 1是要实现pages类，要改动的有三个文件``b_plus_tree_page`` 、``b_plus_internal_page``、``b_plus_leaf_page``\n\n没什么好说的，先把接口补全，之后的task还是需要对内容进行改动的，这里主要是理解他们之间的关系，方便之后的完成\n\n结构如下：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/task1-2023-08-19-1530.png)\n\nleaf_page比internal_page多一个**next_page_id**的字段\n\nB+树page的整体结构:\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/page-2023-08-30-1443.png)\n\n### notes\n\n要注意的点主要有两个：1.``GetMinSize()``  2.``array_``\n\n- ``GetMinSize()``\n\n获取**minsize**，其实就是**半满**条件，但是``leaf_page``和``internal_page``对**半满**的定义不同，可以参照一下官方给的可视化工具[BusTub B+Tree Printer ](https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/)\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/halffull.png)\n\n可以看到在``max_size``都是3的情况下，内部节点的``min_size``为2, 而叶节点的``min_size``是1，所以我们在完善``GetMinSize()``函数的时候要注意区分内部节点和叶子节点，内部节点为(max_size + 1) / 2, 叶子节点为max_size / 2\n\n- ``array_``\n\n``array_``其实就是用来存储键值对的容器，这里容易产生疑问的点在于``array_[1]``只能存一个KV吗？\n\n这里的``array_``其实是一个柔性数组，允许你在结构体的末尾定义一个数组，其大小可以在运行时动态确定。\n\n简单来说，初始化一个类对象时，无法确定该数组要设置的大小，但知道类对象的大小，就可以利用柔性数组，它可以自动填充未被其他变量使用的内存从而确定长度。**柔性数组必须是类中最后一个成员**。\n\n## Task2\n\ntask2要求我们实现B+树整个数据结构，整个project的重点\n\n一共需要实现三个函数**GetValue**、**Insert**、**Remove**\n\n难度也是 **GetValue** > **Insert** > **Remove** \n\n### GetValue\n\n查找的流程比较简单，无非是找到key值、向下遍历。其中主要注意的是``KeyComparator``,这个类是专门用来比较key值大小的比较器，实现在``generic_key``文件中，具体实现方式可以自行查阅，简单来说就是\n\n```C++\nKeycomparator comparator_;\nif (key1 < key2) {\n\tcomparator_(key1, key2) < 0;\t//key1小于key2，比较结果为负\n} else if (key1 > key2) {\n    comparator_(key1, key2) > 0;\t//key1大于key2，比较结果为正\n} else {\n    comparator_(key1, key2) = 0;\t//key1等于key2，比较结果为0\n}\n```\n\n还有要注意的是**叶子节点**与**内部节点**的区别\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/kvdiff-2023-08-30-1443.png)\n\n**内部节点**的第一个**key**是无效的，而叶子节点不是\n\n并且内部节点的value值指向的是下一个节点，有可能是内部节点，有可能是叶子节点；而叶子节点的value则是**数据本身**，两者在value上也有区别\n\n理清其中的关系之后，就可以开始实现了\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/getvalue-2023-08-30-1443.png)\n\n通过**Findleaf()**函数遍历整个树，从根节点开始查找，直到找到叶节点，再在叶节点中寻找对应**key**，找到返回true，并赋值给传入参数value，未找到直接返回false\n\n查找方式可以手写**二分查找**，也可以用标准库比如**std::lower_bound**,具体实现方式比较自由\n\n注意区分内部节点和叶子节点的查找，具体实现可以在其对应的page页面中进行，重点要注意**内部节点**的查找，其key值对应的value是大于等于key的集合，如果小于要查找的key，则需要返回**key - 1**对应的value\n\n### Insert\n\n**Insert**的实现也要依赖于上面写的**Findleaf()**函数，因为在插入的时候我们需要找到**insert_key**恰好大于的**key**，将其插入到**key**的后面\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/insert-2023-08-30-1443.png)\n\n1. 首先要检查是否已经存在树，只需要比对**root_page_id**是否等于INVALID_PAGE_ID即可，如果不存在，则建立新树，开始建立的树一定是**leaf_page**，最后不要忘记更新**root_page_id**\n2. 若已经存在树，则需要通过**GetValue()**中实现的**FindLeaf()**函数，找到需要插入键值对的叶子节点，直接插入（为什么可以直接插入？可以通过[BusTub B+Tree Printer ](https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/)看出，叶子节点一旦**达到Maxsize**便立刻执行分裂操作，即叶子节点一定有空余空间插入一组键值对）\n3. 插入之后需要判断叶子节点是否已满，若未满，则插入流程结束\n4. 若叶子节点已满，则执行分裂。分裂过程无非是新建一个叶子节点，将叶子节点分成两个满足半满的节点。一般我们将新节点作为该叶子节点的右邻居节点，所以直接将后半部分copy给right_neighbor_node，注意**不要忘记risen_key**,新生成了一个节点，新节点的第一个键值将上升至父节点中，此时需要再对父节点是否达成分裂条件进行判断\n5. 内部节点的分裂条件和叶子节点不同，内部节点的键值对可以占满整个page，换句话说就是当内部节点要插入时，没有足够的空间了，在这种情况下内部节点才会进行分裂，而不像叶子节点一样，一旦达到maxsize**立刻分裂**。所以内部节点的分裂需要先为其开辟一段能容纳下新键值对的空间，再进行插入流程，插入完成后，再将新page中的键值对像叶子节点一样，copy给新内部节点，此时，由于存在新的内部节点，该内部节点的**第一个key**将上升至父节点（内部节点），再对其父节点进行判断，依次递推，直到节点不需要分裂（未满）为止\n\n**notes：**\n\n分裂过程中，原节点的值其实不需要变动，**只需修改节点的size**即可，之后如有新值会直接覆盖掉\n\n**risen_key**在叶子节点和内部节点中也不同，叶子节点是array[0].first,内部节点是array_[1].first\n\n\n\n插入操作其实也不是非常复杂，**remove**要比**insert**更为复杂一些\n\n\n\n### Remove\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/remove-2023-08-25-1530.png)\n\n1. Remove和Insert一样首先要拿到进行删除操作的叶子节点，**直接进行删除操作**，此时要考虑**删除节点是根节点**这一特殊情况，如果是根节点且恰好只剩一个孩子，那么这个根节点就没有存在的意义了，所以要让其only_child成为新根。\n\n   ![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/remove%20root-2023-08-30-2017.png)\n\n2. 如果不为特殊情况，则对进行删除操作的节点进行判断，**是否满足半满条件**（注意叶子节点和内部节点的半满条件不同），若满足，则可以直接结束\n\n3. 如果不满足半满条件，则需要进行合并(Merge)或者重构(Redistribute)，怎么判断**Merge**还是**Redistribute**呢？这里就是要拿到其邻居（前后都可以），判断能否容纳两个节点的项\n\n4. 如果不可以容纳两个节点的项，则进行**重分配**。即将前节点的最后一项copy到后节点的第一项，**注意后节点的key要在父节点中更改**（因为first_key变了），如果是叶子节点可以直接将后节点0号key上升，如果是内部节点就要复杂一些，因为内部节点不可以重复，所以就有**fallen_key**的存在，在copy之前要先将父节点对应的key下落至0号位置（虽然内部节点的第一个key值无效，但是不影响我们存储键值），再进行重分配，分配完成后再将后节点的0号key更新至**fallen_key**位置。同时，因为是内部节点，**不要忘记修改其移动项的子页面**，要将其所有子页面的parent_page_id更新。\n\n5. 如果可以容纳两个节点的项，则会进行**合并**。将节点内部项全部移动到其邻居节点中，将父节点中原本键值对移除（其实就是将所有原位置后KV前移一位，再修改一下size即可）。合并完成后，还需要进行递归操作，因为父节点的size改变了，所以有可能不满足半满条件，直到有一个父节点满足半满条件为止\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/allremove-2023-08-30-2017.png)\n\n总体的删除流程就结束了\n\n## Debug && Sum up\n\n虽然总体流程结束了，中途还会有无数个bug，尤其是当代码写的越来越长的时候，debug就成了十分折磨人的事情。但是善良的TAs为我们提供了一些用于debug的接口，可以在测试代码中利用``Draw``函数输出dot文件，将dot文件的内容贴到[Graphviz Online ](http://dreampuf.github.io/GraphvizOnline/)将树可视化，（你甚至可以看到每一步的树长什么样），再根据自己的树和测试样例进行比对，从而定位错误\n\n也可以使用``b_plus_printer``来自行定义树，进行一些操作后来和官方给的可视化工具[BusTub B+Tree Printer ](https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/)进行比对，我当时就是用的这个方法加上打断点的方式定位到remove函数中的错误。\n\n另外Insert测试样例中有用到迭代器的实现，可以忽略，也可以写上，毕竟不像B+树构造这么复杂，同时别以为本地测试样例过了就是成功了，因为checkpoint1的本地测试样例实在是太弱了（不光本地测试样例弱，我怀疑线上的测试样例也是本地的这几个），唯一有点点点难度的是**ScaleTest**，我看到好多人**ScaleTest**过不去，这个情况一般都是**UnpinPage**没有做好，多检查一下是不是**Fetch**之后**忘记Unpin**了。我当时remove函数实现有错误，提交到Gradescope上都显示全对，这个困扰了我很长时间，解决办法也是有的，下篇文章见！\n\n\n\n","source":"_posts/CMU15445 P2cp1.md","raw":"---\ntitle: CMU15445 P2 Checkpoint1\ncategories: CMU15445\ntags: \n    - CMU15445\n    - Database\ndate: 2023-08-31 15:00:00\ndescription: 对445 B+树构造的一次总结\ncover: https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/445pic1.jpg\ntop_img: rgba(0,0,0,0)\n---\n## 前言\n\nP2感觉比P1的难度大了很多，内部实现基本完全由自己决定，刚上手的时候没有指引有点手足无措，但同时也代表了实现的方式可以非常自由。\n\n真的是很磨练人的一个project, 不过听说奇数年是实现hashmap要友好一些，有机会可以试一下\n\n## Task1\n\nTask 1是要实现pages类，要改动的有三个文件``b_plus_tree_page`` 、``b_plus_internal_page``、``b_plus_leaf_page``\n\n没什么好说的，先把接口补全，之后的task还是需要对内容进行改动的，这里主要是理解他们之间的关系，方便之后的完成\n\n结构如下：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/task1-2023-08-19-1530.png)\n\nleaf_page比internal_page多一个**next_page_id**的字段\n\nB+树page的整体结构:\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/page-2023-08-30-1443.png)\n\n### notes\n\n要注意的点主要有两个：1.``GetMinSize()``  2.``array_``\n\n- ``GetMinSize()``\n\n获取**minsize**，其实就是**半满**条件，但是``leaf_page``和``internal_page``对**半满**的定义不同，可以参照一下官方给的可视化工具[BusTub B+Tree Printer ](https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/)\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/halffull.png)\n\n可以看到在``max_size``都是3的情况下，内部节点的``min_size``为2, 而叶节点的``min_size``是1，所以我们在完善``GetMinSize()``函数的时候要注意区分内部节点和叶子节点，内部节点为(max_size + 1) / 2, 叶子节点为max_size / 2\n\n- ``array_``\n\n``array_``其实就是用来存储键值对的容器，这里容易产生疑问的点在于``array_[1]``只能存一个KV吗？\n\n这里的``array_``其实是一个柔性数组，允许你在结构体的末尾定义一个数组，其大小可以在运行时动态确定。\n\n简单来说，初始化一个类对象时，无法确定该数组要设置的大小，但知道类对象的大小，就可以利用柔性数组，它可以自动填充未被其他变量使用的内存从而确定长度。**柔性数组必须是类中最后一个成员**。\n\n## Task2\n\ntask2要求我们实现B+树整个数据结构，整个project的重点\n\n一共需要实现三个函数**GetValue**、**Insert**、**Remove**\n\n难度也是 **GetValue** > **Insert** > **Remove** \n\n### GetValue\n\n查找的流程比较简单，无非是找到key值、向下遍历。其中主要注意的是``KeyComparator``,这个类是专门用来比较key值大小的比较器，实现在``generic_key``文件中，具体实现方式可以自行查阅，简单来说就是\n\n```C++\nKeycomparator comparator_;\nif (key1 < key2) {\n\tcomparator_(key1, key2) < 0;\t//key1小于key2，比较结果为负\n} else if (key1 > key2) {\n    comparator_(key1, key2) > 0;\t//key1大于key2，比较结果为正\n} else {\n    comparator_(key1, key2) = 0;\t//key1等于key2，比较结果为0\n}\n```\n\n还有要注意的是**叶子节点**与**内部节点**的区别\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/kvdiff-2023-08-30-1443.png)\n\n**内部节点**的第一个**key**是无效的，而叶子节点不是\n\n并且内部节点的value值指向的是下一个节点，有可能是内部节点，有可能是叶子节点；而叶子节点的value则是**数据本身**，两者在value上也有区别\n\n理清其中的关系之后，就可以开始实现了\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/getvalue-2023-08-30-1443.png)\n\n通过**Findleaf()**函数遍历整个树，从根节点开始查找，直到找到叶节点，再在叶节点中寻找对应**key**，找到返回true，并赋值给传入参数value，未找到直接返回false\n\n查找方式可以手写**二分查找**，也可以用标准库比如**std::lower_bound**,具体实现方式比较自由\n\n注意区分内部节点和叶子节点的查找，具体实现可以在其对应的page页面中进行，重点要注意**内部节点**的查找，其key值对应的value是大于等于key的集合，如果小于要查找的key，则需要返回**key - 1**对应的value\n\n### Insert\n\n**Insert**的实现也要依赖于上面写的**Findleaf()**函数，因为在插入的时候我们需要找到**insert_key**恰好大于的**key**，将其插入到**key**的后面\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/insert-2023-08-30-1443.png)\n\n1. 首先要检查是否已经存在树，只需要比对**root_page_id**是否等于INVALID_PAGE_ID即可，如果不存在，则建立新树，开始建立的树一定是**leaf_page**，最后不要忘记更新**root_page_id**\n2. 若已经存在树，则需要通过**GetValue()**中实现的**FindLeaf()**函数，找到需要插入键值对的叶子节点，直接插入（为什么可以直接插入？可以通过[BusTub B+Tree Printer ](https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/)看出，叶子节点一旦**达到Maxsize**便立刻执行分裂操作，即叶子节点一定有空余空间插入一组键值对）\n3. 插入之后需要判断叶子节点是否已满，若未满，则插入流程结束\n4. 若叶子节点已满，则执行分裂。分裂过程无非是新建一个叶子节点，将叶子节点分成两个满足半满的节点。一般我们将新节点作为该叶子节点的右邻居节点，所以直接将后半部分copy给right_neighbor_node，注意**不要忘记risen_key**,新生成了一个节点，新节点的第一个键值将上升至父节点中，此时需要再对父节点是否达成分裂条件进行判断\n5. 内部节点的分裂条件和叶子节点不同，内部节点的键值对可以占满整个page，换句话说就是当内部节点要插入时，没有足够的空间了，在这种情况下内部节点才会进行分裂，而不像叶子节点一样，一旦达到maxsize**立刻分裂**。所以内部节点的分裂需要先为其开辟一段能容纳下新键值对的空间，再进行插入流程，插入完成后，再将新page中的键值对像叶子节点一样，copy给新内部节点，此时，由于存在新的内部节点，该内部节点的**第一个key**将上升至父节点（内部节点），再对其父节点进行判断，依次递推，直到节点不需要分裂（未满）为止\n\n**notes：**\n\n分裂过程中，原节点的值其实不需要变动，**只需修改节点的size**即可，之后如有新值会直接覆盖掉\n\n**risen_key**在叶子节点和内部节点中也不同，叶子节点是array[0].first,内部节点是array_[1].first\n\n\n\n插入操作其实也不是非常复杂，**remove**要比**insert**更为复杂一些\n\n\n\n### Remove\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/remove-2023-08-25-1530.png)\n\n1. Remove和Insert一样首先要拿到进行删除操作的叶子节点，**直接进行删除操作**，此时要考虑**删除节点是根节点**这一特殊情况，如果是根节点且恰好只剩一个孩子，那么这个根节点就没有存在的意义了，所以要让其only_child成为新根。\n\n   ![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/remove%20root-2023-08-30-2017.png)\n\n2. 如果不为特殊情况，则对进行删除操作的节点进行判断，**是否满足半满条件**（注意叶子节点和内部节点的半满条件不同），若满足，则可以直接结束\n\n3. 如果不满足半满条件，则需要进行合并(Merge)或者重构(Redistribute)，怎么判断**Merge**还是**Redistribute**呢？这里就是要拿到其邻居（前后都可以），判断能否容纳两个节点的项\n\n4. 如果不可以容纳两个节点的项，则进行**重分配**。即将前节点的最后一项copy到后节点的第一项，**注意后节点的key要在父节点中更改**（因为first_key变了），如果是叶子节点可以直接将后节点0号key上升，如果是内部节点就要复杂一些，因为内部节点不可以重复，所以就有**fallen_key**的存在，在copy之前要先将父节点对应的key下落至0号位置（虽然内部节点的第一个key值无效，但是不影响我们存储键值），再进行重分配，分配完成后再将后节点的0号key更新至**fallen_key**位置。同时，因为是内部节点，**不要忘记修改其移动项的子页面**，要将其所有子页面的parent_page_id更新。\n\n5. 如果可以容纳两个节点的项，则会进行**合并**。将节点内部项全部移动到其邻居节点中，将父节点中原本键值对移除（其实就是将所有原位置后KV前移一位，再修改一下size即可）。合并完成后，还需要进行递归操作，因为父节点的size改变了，所以有可能不满足半满条件，直到有一个父节点满足半满条件为止\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/allremove-2023-08-30-2017.png)\n\n总体的删除流程就结束了\n\n## Debug && Sum up\n\n虽然总体流程结束了，中途还会有无数个bug，尤其是当代码写的越来越长的时候，debug就成了十分折磨人的事情。但是善良的TAs为我们提供了一些用于debug的接口，可以在测试代码中利用``Draw``函数输出dot文件，将dot文件的内容贴到[Graphviz Online ](http://dreampuf.github.io/GraphvizOnline/)将树可视化，（你甚至可以看到每一步的树长什么样），再根据自己的树和测试样例进行比对，从而定位错误\n\n也可以使用``b_plus_printer``来自行定义树，进行一些操作后来和官方给的可视化工具[BusTub B+Tree Printer ](https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/)进行比对，我当时就是用的这个方法加上打断点的方式定位到remove函数中的错误。\n\n另外Insert测试样例中有用到迭代器的实现，可以忽略，也可以写上，毕竟不像B+树构造这么复杂，同时别以为本地测试样例过了就是成功了，因为checkpoint1的本地测试样例实在是太弱了（不光本地测试样例弱，我怀疑线上的测试样例也是本地的这几个），唯一有点点点难度的是**ScaleTest**，我看到好多人**ScaleTest**过不去，这个情况一般都是**UnpinPage**没有做好，多检查一下是不是**Fetch**之后**忘记Unpin**了。我当时remove函数实现有错误，提交到Gradescope上都显示全对，这个困扰了我很长时间，解决办法也是有的，下篇文章见！\n\n\n\n","slug":"CMU15445 P2cp1","published":1,"updated":"2023-08-31T07:09:08.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmuf8mjg0000cjjgbnzxhrte","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>P2感觉比P1的难度大了很多，内部实现基本完全由自己决定，刚上手的时候没有指引有点手足无措，但同时也代表了实现的方式可以非常自由。</p>\n<p>真的是很磨练人的一个project, 不过听说奇数年是实现hashmap要友好一些，有机会可以试一下</p>\n<h2 id=\"Task1\"><a href=\"#Task1\" class=\"headerlink\" title=\"Task1\"></a>Task1</h2><p>Task 1是要实现pages类，要改动的有三个文件<code>b_plus_tree_page</code> 、<code>b_plus_internal_page</code>、<code>b_plus_leaf_page</code></p>\n<p>没什么好说的，先把接口补全，之后的task还是需要对内容进行改动的，这里主要是理解他们之间的关系，方便之后的完成</p>\n<p>结构如下：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/task1-2023-08-19-1530.png\"></p>\n<p>leaf_page比internal_page多一个<strong>next_page_id</strong>的字段</p>\n<p>B+树page的整体结构:</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/page-2023-08-30-1443.png\"></p>\n<h3 id=\"notes\"><a href=\"#notes\" class=\"headerlink\" title=\"notes\"></a>notes</h3><p>要注意的点主要有两个：1.<code>GetMinSize()</code>  2.<code>array_</code></p>\n<ul>\n<li><code>GetMinSize()</code></li>\n</ul>\n<p>获取<strong>minsize</strong>，其实就是<strong>半满</strong>条件，但是<code>leaf_page</code>和<code>internal_page</code>对<strong>半满</strong>的定义不同，可以参照一下官方给的可视化工具<a href=\"https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/\">BusTub B+Tree Printer </a></p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/halffull.png\"></p>\n<p>可以看到在<code>max_size</code>都是3的情况下，内部节点的<code>min_size</code>为2, 而叶节点的<code>min_size</code>是1，所以我们在完善<code>GetMinSize()</code>函数的时候要注意区分内部节点和叶子节点，内部节点为(max_size + 1) &#x2F; 2, 叶子节点为max_size &#x2F; 2</p>\n<ul>\n<li><code>array_</code></li>\n</ul>\n<p><code>array_</code>其实就是用来存储键值对的容器，这里容易产生疑问的点在于<code>array_[1]</code>只能存一个KV吗？</p>\n<p>这里的<code>array_</code>其实是一个柔性数组，允许你在结构体的末尾定义一个数组，其大小可以在运行时动态确定。</p>\n<p>简单来说，初始化一个类对象时，无法确定该数组要设置的大小，但知道类对象的大小，就可以利用柔性数组，它可以自动填充未被其他变量使用的内存从而确定长度。<strong>柔性数组必须是类中最后一个成员</strong>。</p>\n<h2 id=\"Task2\"><a href=\"#Task2\" class=\"headerlink\" title=\"Task2\"></a>Task2</h2><p>task2要求我们实现B+树整个数据结构，整个project的重点</p>\n<p>一共需要实现三个函数<strong>GetValue</strong>、<strong>Insert</strong>、<strong>Remove</strong></p>\n<p>难度也是 <strong>GetValue</strong> &gt; <strong>Insert</strong> &gt; <strong>Remove</strong> </p>\n<h3 id=\"GetValue\"><a href=\"#GetValue\" class=\"headerlink\" title=\"GetValue\"></a>GetValue</h3><p>查找的流程比较简单，无非是找到key值、向下遍历。其中主要注意的是<code>KeyComparator</code>,这个类是专门用来比较key值大小的比较器，实现在<code>generic_key</code>文件中，具体实现方式可以自行查阅，简单来说就是</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keycomparator comparator_;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (key1 &lt; key2) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">comparator_</span>(key1, key2) &lt; <span class=\"number\">0</span>;\t<span class=\"comment\">//key1小于key2，比较结果为负</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key1 &gt; key2) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">comparator_</span>(key1, key2) &gt; <span class=\"number\">0</span>;\t<span class=\"comment\">//key1大于key2，比较结果为正</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">comparator_</span>(key1, key2) = <span class=\"number\">0</span>;\t<span class=\"comment\">//key1等于key2，比较结果为0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有要注意的是<strong>叶子节点</strong>与<strong>内部节点</strong>的区别</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/kvdiff-2023-08-30-1443.png\"></p>\n<p><strong>内部节点</strong>的第一个<strong>key</strong>是无效的，而叶子节点不是</p>\n<p>并且内部节点的value值指向的是下一个节点，有可能是内部节点，有可能是叶子节点；而叶子节点的value则是<strong>数据本身</strong>，两者在value上也有区别</p>\n<p>理清其中的关系之后，就可以开始实现了</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/getvalue-2023-08-30-1443.png\"></p>\n<p>通过<strong>Findleaf()<strong>函数遍历整个树，从根节点开始查找，直到找到叶节点，再在叶节点中寻找对应</strong>key</strong>，找到返回true，并赋值给传入参数value，未找到直接返回false</p>\n<p>查找方式可以手写<strong>二分查找</strong>，也可以用标准库比如<strong>std::lower_bound</strong>,具体实现方式比较自由</p>\n<p>注意区分内部节点和叶子节点的查找，具体实现可以在其对应的page页面中进行，重点要注意<strong>内部节点</strong>的查找，其key值对应的value是大于等于key的集合，如果小于要查找的key，则需要返回<strong>key - 1</strong>对应的value</p>\n<h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p><strong>Insert</strong>的实现也要依赖于上面写的<strong>Findleaf()<strong>函数，因为在插入的时候我们需要找到</strong>insert_key</strong>恰好大于的<strong>key</strong>，将其插入到<strong>key</strong>的后面</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/insert-2023-08-30-1443.png\"></p>\n<ol>\n<li>首先要检查是否已经存在树，只需要比对<strong>root_page_id</strong>是否等于INVALID_PAGE_ID即可，如果不存在，则建立新树，开始建立的树一定是<strong>leaf_page</strong>，最后不要忘记更新<strong>root_page_id</strong></li>\n<li>若已经存在树，则需要通过<strong>GetValue()<strong>中实现的</strong>FindLeaf()<strong>函数，找到需要插入键值对的叶子节点，直接插入（为什么可以直接插入？可以通过<a href=\"https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/\">BusTub B+Tree Printer </a>看出，叶子节点一旦</strong>达到Maxsize</strong>便立刻执行分裂操作，即叶子节点一定有空余空间插入一组键值对）</li>\n<li>插入之后需要判断叶子节点是否已满，若未满，则插入流程结束</li>\n<li>若叶子节点已满，则执行分裂。分裂过程无非是新建一个叶子节点，将叶子节点分成两个满足半满的节点。一般我们将新节点作为该叶子节点的右邻居节点，所以直接将后半部分copy给right_neighbor_node，注意<strong>不要忘记risen_key</strong>,新生成了一个节点，新节点的第一个键值将上升至父节点中，此时需要再对父节点是否达成分裂条件进行判断</li>\n<li>内部节点的分裂条件和叶子节点不同，内部节点的键值对可以占满整个page，换句话说就是当内部节点要插入时，没有足够的空间了，在这种情况下内部节点才会进行分裂，而不像叶子节点一样，一旦达到maxsize<strong>立刻分裂</strong>。所以内部节点的分裂需要先为其开辟一段能容纳下新键值对的空间，再进行插入流程，插入完成后，再将新page中的键值对像叶子节点一样，copy给新内部节点，此时，由于存在新的内部节点，该内部节点的<strong>第一个key</strong>将上升至父节点（内部节点），再对其父节点进行判断，依次递推，直到节点不需要分裂（未满）为止</li>\n</ol>\n<p><strong>notes：</strong></p>\n<p>分裂过程中，原节点的值其实不需要变动，<strong>只需修改节点的size</strong>即可，之后如有新值会直接覆盖掉</p>\n<p><strong>risen_key</strong>在叶子节点和内部节点中也不同，叶子节点是array[0].first,内部节点是array_[1].first</p>\n<p>插入操作其实也不是非常复杂，<strong>remove</strong>要比<strong>insert</strong>更为复杂一些</p>\n<h3 id=\"Remove\"><a href=\"#Remove\" class=\"headerlink\" title=\"Remove\"></a>Remove</h3><p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/remove-2023-08-25-1530.png\"></p>\n<ol>\n<li><p>Remove和Insert一样首先要拿到进行删除操作的叶子节点，<strong>直接进行删除操作</strong>，此时要考虑<strong>删除节点是根节点</strong>这一特殊情况，如果是根节点且恰好只剩一个孩子，那么这个根节点就没有存在的意义了，所以要让其only_child成为新根。</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/remove%20root-2023-08-30-2017.png\"></p>\n</li>\n<li><p>如果不为特殊情况，则对进行删除操作的节点进行判断，<strong>是否满足半满条件</strong>（注意叶子节点和内部节点的半满条件不同），若满足，则可以直接结束</p>\n</li>\n<li><p>如果不满足半满条件，则需要进行合并(Merge)或者重构(Redistribute)，怎么判断<strong>Merge</strong>还是<strong>Redistribute</strong>呢？这里就是要拿到其邻居（前后都可以），判断能否容纳两个节点的项</p>\n</li>\n<li><p>如果不可以容纳两个节点的项，则进行<strong>重分配</strong>。即将前节点的最后一项copy到后节点的第一项，<strong>注意后节点的key要在父节点中更改</strong>（因为first_key变了），如果是叶子节点可以直接将后节点0号key上升，如果是内部节点就要复杂一些，因为内部节点不可以重复，所以就有<strong>fallen_key</strong>的存在，在copy之前要先将父节点对应的key下落至0号位置（虽然内部节点的第一个key值无效，但是不影响我们存储键值），再进行重分配，分配完成后再将后节点的0号key更新至<strong>fallen_key</strong>位置。同时，因为是内部节点，<strong>不要忘记修改其移动项的子页面</strong>，要将其所有子页面的parent_page_id更新。</p>\n</li>\n<li><p>如果可以容纳两个节点的项，则会进行<strong>合并</strong>。将节点内部项全部移动到其邻居节点中，将父节点中原本键值对移除（其实就是将所有原位置后KV前移一位，再修改一下size即可）。合并完成后，还需要进行递归操作，因为父节点的size改变了，所以有可能不满足半满条件，直到有一个父节点满足半满条件为止</p>\n</li>\n</ol>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/allremove-2023-08-30-2017.png\"></p>\n<p>总体的删除流程就结束了</p>\n<h2 id=\"Debug-Sum-up\"><a href=\"#Debug-Sum-up\" class=\"headerlink\" title=\"Debug &amp;&amp; Sum up\"></a>Debug &amp;&amp; Sum up</h2><p>虽然总体流程结束了，中途还会有无数个bug，尤其是当代码写的越来越长的时候，debug就成了十分折磨人的事情。但是善良的TAs为我们提供了一些用于debug的接口，可以在测试代码中利用<code>Draw</code>函数输出dot文件，将dot文件的内容贴到<a href=\"http://dreampuf.github.io/GraphvizOnline/\">Graphviz Online </a>将树可视化，（你甚至可以看到每一步的树长什么样），再根据自己的树和测试样例进行比对，从而定位错误</p>\n<p>也可以使用<code>b_plus_printer</code>来自行定义树，进行一些操作后来和官方给的可视化工具<a href=\"https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/\">BusTub B+Tree Printer </a>进行比对，我当时就是用的这个方法加上打断点的方式定位到remove函数中的错误。</p>\n<p>另外Insert测试样例中有用到迭代器的实现，可以忽略，也可以写上，毕竟不像B+树构造这么复杂，同时别以为本地测试样例过了就是成功了，因为checkpoint1的本地测试样例实在是太弱了（不光本地测试样例弱，我怀疑线上的测试样例也是本地的这几个），唯一有点点点难度的是<strong>ScaleTest</strong>，我看到好多人<strong>ScaleTest</strong>过不去，这个情况一般都是<strong>UnpinPage</strong>没有做好，多检查一下是不是<strong>Fetch</strong>之后<strong>忘记Unpin</strong>了。我当时remove函数实现有错误，提交到Gradescope上都显示全对，这个困扰了我很长时间，解决办法也是有的，下篇文章见！</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>P2感觉比P1的难度大了很多，内部实现基本完全由自己决定，刚上手的时候没有指引有点手足无措，但同时也代表了实现的方式可以非常自由。</p>\n<p>真的是很磨练人的一个project, 不过听说奇数年是实现hashmap要友好一些，有机会可以试一下</p>\n<h2 id=\"Task1\"><a href=\"#Task1\" class=\"headerlink\" title=\"Task1\"></a>Task1</h2><p>Task 1是要实现pages类，要改动的有三个文件<code>b_plus_tree_page</code> 、<code>b_plus_internal_page</code>、<code>b_plus_leaf_page</code></p>\n<p>没什么好说的，先把接口补全，之后的task还是需要对内容进行改动的，这里主要是理解他们之间的关系，方便之后的完成</p>\n<p>结构如下：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/task1-2023-08-19-1530.png\"></p>\n<p>leaf_page比internal_page多一个<strong>next_page_id</strong>的字段</p>\n<p>B+树page的整体结构:</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/page-2023-08-30-1443.png\"></p>\n<h3 id=\"notes\"><a href=\"#notes\" class=\"headerlink\" title=\"notes\"></a>notes</h3><p>要注意的点主要有两个：1.<code>GetMinSize()</code>  2.<code>array_</code></p>\n<ul>\n<li><code>GetMinSize()</code></li>\n</ul>\n<p>获取<strong>minsize</strong>，其实就是<strong>半满</strong>条件，但是<code>leaf_page</code>和<code>internal_page</code>对<strong>半满</strong>的定义不同，可以参照一下官方给的可视化工具<a href=\"https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/\">BusTub B+Tree Printer </a></p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/halffull.png\"></p>\n<p>可以看到在<code>max_size</code>都是3的情况下，内部节点的<code>min_size</code>为2, 而叶节点的<code>min_size</code>是1，所以我们在完善<code>GetMinSize()</code>函数的时候要注意区分内部节点和叶子节点，内部节点为(max_size + 1) &#x2F; 2, 叶子节点为max_size &#x2F; 2</p>\n<ul>\n<li><code>array_</code></li>\n</ul>\n<p><code>array_</code>其实就是用来存储键值对的容器，这里容易产生疑问的点在于<code>array_[1]</code>只能存一个KV吗？</p>\n<p>这里的<code>array_</code>其实是一个柔性数组，允许你在结构体的末尾定义一个数组，其大小可以在运行时动态确定。</p>\n<p>简单来说，初始化一个类对象时，无法确定该数组要设置的大小，但知道类对象的大小，就可以利用柔性数组，它可以自动填充未被其他变量使用的内存从而确定长度。<strong>柔性数组必须是类中最后一个成员</strong>。</p>\n<h2 id=\"Task2\"><a href=\"#Task2\" class=\"headerlink\" title=\"Task2\"></a>Task2</h2><p>task2要求我们实现B+树整个数据结构，整个project的重点</p>\n<p>一共需要实现三个函数<strong>GetValue</strong>、<strong>Insert</strong>、<strong>Remove</strong></p>\n<p>难度也是 <strong>GetValue</strong> &gt; <strong>Insert</strong> &gt; <strong>Remove</strong> </p>\n<h3 id=\"GetValue\"><a href=\"#GetValue\" class=\"headerlink\" title=\"GetValue\"></a>GetValue</h3><p>查找的流程比较简单，无非是找到key值、向下遍历。其中主要注意的是<code>KeyComparator</code>,这个类是专门用来比较key值大小的比较器，实现在<code>generic_key</code>文件中，具体实现方式可以自行查阅，简单来说就是</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keycomparator comparator_;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (key1 &lt; key2) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">comparator_</span>(key1, key2) &lt; <span class=\"number\">0</span>;\t<span class=\"comment\">//key1小于key2，比较结果为负</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key1 &gt; key2) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">comparator_</span>(key1, key2) &gt; <span class=\"number\">0</span>;\t<span class=\"comment\">//key1大于key2，比较结果为正</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">comparator_</span>(key1, key2) = <span class=\"number\">0</span>;\t<span class=\"comment\">//key1等于key2，比较结果为0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有要注意的是<strong>叶子节点</strong>与<strong>内部节点</strong>的区别</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/kvdiff-2023-08-30-1443.png\"></p>\n<p><strong>内部节点</strong>的第一个<strong>key</strong>是无效的，而叶子节点不是</p>\n<p>并且内部节点的value值指向的是下一个节点，有可能是内部节点，有可能是叶子节点；而叶子节点的value则是<strong>数据本身</strong>，两者在value上也有区别</p>\n<p>理清其中的关系之后，就可以开始实现了</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/getvalue-2023-08-30-1443.png\"></p>\n<p>通过<strong>Findleaf()<strong>函数遍历整个树，从根节点开始查找，直到找到叶节点，再在叶节点中寻找对应</strong>key</strong>，找到返回true，并赋值给传入参数value，未找到直接返回false</p>\n<p>查找方式可以手写<strong>二分查找</strong>，也可以用标准库比如<strong>std::lower_bound</strong>,具体实现方式比较自由</p>\n<p>注意区分内部节点和叶子节点的查找，具体实现可以在其对应的page页面中进行，重点要注意<strong>内部节点</strong>的查找，其key值对应的value是大于等于key的集合，如果小于要查找的key，则需要返回<strong>key - 1</strong>对应的value</p>\n<h3 id=\"Insert\"><a href=\"#Insert\" class=\"headerlink\" title=\"Insert\"></a>Insert</h3><p><strong>Insert</strong>的实现也要依赖于上面写的<strong>Findleaf()<strong>函数，因为在插入的时候我们需要找到</strong>insert_key</strong>恰好大于的<strong>key</strong>，将其插入到<strong>key</strong>的后面</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/insert-2023-08-30-1443.png\"></p>\n<ol>\n<li>首先要检查是否已经存在树，只需要比对<strong>root_page_id</strong>是否等于INVALID_PAGE_ID即可，如果不存在，则建立新树，开始建立的树一定是<strong>leaf_page</strong>，最后不要忘记更新<strong>root_page_id</strong></li>\n<li>若已经存在树，则需要通过<strong>GetValue()<strong>中实现的</strong>FindLeaf()<strong>函数，找到需要插入键值对的叶子节点，直接插入（为什么可以直接插入？可以通过<a href=\"https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/\">BusTub B+Tree Printer </a>看出，叶子节点一旦</strong>达到Maxsize</strong>便立刻执行分裂操作，即叶子节点一定有空余空间插入一组键值对）</li>\n<li>插入之后需要判断叶子节点是否已满，若未满，则插入流程结束</li>\n<li>若叶子节点已满，则执行分裂。分裂过程无非是新建一个叶子节点，将叶子节点分成两个满足半满的节点。一般我们将新节点作为该叶子节点的右邻居节点，所以直接将后半部分copy给right_neighbor_node，注意<strong>不要忘记risen_key</strong>,新生成了一个节点，新节点的第一个键值将上升至父节点中，此时需要再对父节点是否达成分裂条件进行判断</li>\n<li>内部节点的分裂条件和叶子节点不同，内部节点的键值对可以占满整个page，换句话说就是当内部节点要插入时，没有足够的空间了，在这种情况下内部节点才会进行分裂，而不像叶子节点一样，一旦达到maxsize<strong>立刻分裂</strong>。所以内部节点的分裂需要先为其开辟一段能容纳下新键值对的空间，再进行插入流程，插入完成后，再将新page中的键值对像叶子节点一样，copy给新内部节点，此时，由于存在新的内部节点，该内部节点的<strong>第一个key</strong>将上升至父节点（内部节点），再对其父节点进行判断，依次递推，直到节点不需要分裂（未满）为止</li>\n</ol>\n<p><strong>notes：</strong></p>\n<p>分裂过程中，原节点的值其实不需要变动，<strong>只需修改节点的size</strong>即可，之后如有新值会直接覆盖掉</p>\n<p><strong>risen_key</strong>在叶子节点和内部节点中也不同，叶子节点是array[0].first,内部节点是array_[1].first</p>\n<p>插入操作其实也不是非常复杂，<strong>remove</strong>要比<strong>insert</strong>更为复杂一些</p>\n<h3 id=\"Remove\"><a href=\"#Remove\" class=\"headerlink\" title=\"Remove\"></a>Remove</h3><p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/remove-2023-08-25-1530.png\"></p>\n<ol>\n<li><p>Remove和Insert一样首先要拿到进行删除操作的叶子节点，<strong>直接进行删除操作</strong>，此时要考虑<strong>删除节点是根节点</strong>这一特殊情况，如果是根节点且恰好只剩一个孩子，那么这个根节点就没有存在的意义了，所以要让其only_child成为新根。</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/remove%20root-2023-08-30-2017.png\"></p>\n</li>\n<li><p>如果不为特殊情况，则对进行删除操作的节点进行判断，<strong>是否满足半满条件</strong>（注意叶子节点和内部节点的半满条件不同），若满足，则可以直接结束</p>\n</li>\n<li><p>如果不满足半满条件，则需要进行合并(Merge)或者重构(Redistribute)，怎么判断<strong>Merge</strong>还是<strong>Redistribute</strong>呢？这里就是要拿到其邻居（前后都可以），判断能否容纳两个节点的项</p>\n</li>\n<li><p>如果不可以容纳两个节点的项，则进行<strong>重分配</strong>。即将前节点的最后一项copy到后节点的第一项，<strong>注意后节点的key要在父节点中更改</strong>（因为first_key变了），如果是叶子节点可以直接将后节点0号key上升，如果是内部节点就要复杂一些，因为内部节点不可以重复，所以就有<strong>fallen_key</strong>的存在，在copy之前要先将父节点对应的key下落至0号位置（虽然内部节点的第一个key值无效，但是不影响我们存储键值），再进行重分配，分配完成后再将后节点的0号key更新至<strong>fallen_key</strong>位置。同时，因为是内部节点，<strong>不要忘记修改其移动项的子页面</strong>，要将其所有子页面的parent_page_id更新。</p>\n</li>\n<li><p>如果可以容纳两个节点的项，则会进行<strong>合并</strong>。将节点内部项全部移动到其邻居节点中，将父节点中原本键值对移除（其实就是将所有原位置后KV前移一位，再修改一下size即可）。合并完成后，还需要进行递归操作，因为父节点的size改变了，所以有可能不满足半满条件，直到有一个父节点满足半满条件为止</p>\n</li>\n</ol>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/allremove-2023-08-30-2017.png\"></p>\n<p>总体的删除流程就结束了</p>\n<h2 id=\"Debug-Sum-up\"><a href=\"#Debug-Sum-up\" class=\"headerlink\" title=\"Debug &amp;&amp; Sum up\"></a>Debug &amp;&amp; Sum up</h2><p>虽然总体流程结束了，中途还会有无数个bug，尤其是当代码写的越来越长的时候，debug就成了十分折磨人的事情。但是善良的TAs为我们提供了一些用于debug的接口，可以在测试代码中利用<code>Draw</code>函数输出dot文件，将dot文件的内容贴到<a href=\"http://dreampuf.github.io/GraphvizOnline/\">Graphviz Online </a>将树可视化，（你甚至可以看到每一步的树长什么样），再根据自己的树和测试样例进行比对，从而定位错误</p>\n<p>也可以使用<code>b_plus_printer</code>来自行定义树，进行一些操作后来和官方给的可视化工具<a href=\"https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/\">BusTub B+Tree Printer </a>进行比对，我当时就是用的这个方法加上打断点的方式定位到remove函数中的错误。</p>\n<p>另外Insert测试样例中有用到迭代器的实现，可以忽略，也可以写上，毕竟不像B+树构造这么复杂，同时别以为本地测试样例过了就是成功了，因为checkpoint1的本地测试样例实在是太弱了（不光本地测试样例弱，我怀疑线上的测试样例也是本地的这几个），唯一有点点点难度的是<strong>ScaleTest</strong>，我看到好多人<strong>ScaleTest</strong>过不去，这个情况一般都是<strong>UnpinPage</strong>没有做好，多检查一下是不是<strong>Fetch</strong>之后<strong>忘记Unpin</strong>了。我当时remove函数实现有错误，提交到Gradescope上都显示全对，这个困扰了我很长时间，解决办法也是有的，下篇文章见！</p>\n"},{"title":"CMU15445 P2 Checkpoint2","date":"2023-09-01T04:40:00.000Z","description":"B+树并发索引","cover":"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/445pic1.jpg","top_img":"rgba(0,0,0,0)","_content":"## 前言\n\n上一篇我们已经实现了B+树，因为本地测试案例里包含了迭代器的实现，所以我们也可以将前三个task作为一个整体\n\n## Task3 Index Iterator\n\nIterator的实现主要在``index_iterator``文件中，而调用的接口则在``b_plus_tree``中的``begin()``、``begin(key)``、``end()``函数中\n\n主要的作用就是直接从叶子层遍历整个数据，在一些需要用到连续数据的时候不必每次都从根节点进行遍历\n\n### 内部实现\n\n迭代器内部的实现主要有以下几个函数\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/iterator-20230831184023.png)\n\n在**Iterator**类中添加几个成员变量，我这里添加了**leaf**, **index**, 还有一个需要的**bufferpoolmanager**\n\n**leaf**代表了叶节点，**index**代表了数据在array中的索引，两个变量即可确定迭代器需要的数据，bufferpoolmanager的作用就是在叶子节点变更时，**通过leaf的next_page_id**拿到下个叶节点\n\n这里的函数都不难，无非只有**operator++()**内容稍微多一点点，需要区分两个情况\n\n1. 在叶节点中递增\n2. 在叶节点间递增\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/iterator2-2023-08-31-2138.png)\n\n如果是叶节点内递增，index直接++即可；如果是叶节点间进行递增，则可以通过leaf的**next_page_id**获取其nextpage，同时将index置零即可实现++操作\n\n### 接口实现\n\n没什么难度，``begin()``就是在Findeaf的过程中始终拿第一个value，``end()``则是相反，``begin(key)``则是查找指定key的迭代器，有点类似``GetValue``，findleaf可以直接实现。\n\n## 重要！！！\n\n实现了前三个Task，只剩最后一个并发控制没有实现了。并发控制实现的基础，肯定是之前的B+树索引的正确实现，B+树部分的实现有误，并发控制怎么都不会跑通的。\n\n你以为你过了checkpoint1就代表你的B+树没问题了？\n\ncheckpoint1的测试样例弱到查不出B+树的错误，我在Remove函数出错的情况下，提交checkpoint1代码，50分通过。\n\n那该怎么办呢？\n\nProject2文档中有写道\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/hint20230831215232.png)\n\n并发设计不允许用全局锁，但是我们可以先上一把大锁来验证一下B+树实现的正确性啊( ﹁ ﹁ ) ~\n\n所以在前面三个Task的基础上上一把大锁，然后直接将代码交到Gradescope上去，果不其然，一堆报错\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/gradescope20230831215636.png)\n\n开始修改代码，一定要改到用上全局锁之后，**全部通过**才可以，不然无论你的锁实现的正确与否，都会报错。\n\n保证前三个Task的正确性之后，就来到了最后一个环节，并发控制。\n\n## Task4 Concurrent Index\n\n个人认为并发控制不是特别复杂，主要是理解课上讲的``latch crabbing``机制，先给子节点上锁，再给父节点解锁，不同操作的上锁解锁逻辑不同\n\n- GetValue：没有修改数据，所以只用上读锁，读锁非常简单，先拿子节点，上锁，释放父节点上读锁即可\n- Insert：沿途加写锁，直到遇到安全节点可释放其祖先页面的锁\n- Delete：沿途加写锁，直到遇到安全节点可释放其祖先页面的锁\n\n重点要梳理的就是**插入**和**删除**对安全节点的定义，什么叫安全呢？安全就是该节点的变动不会影响到父节点。那为什么一旦有安全节点，就可以释放祖先页面的锁呢？安全节点不会影响到父节点，其父节点更不会修改祖先页面。\n\n下面重点讨论**Insert**和**Delete**对安全节点的定义\n\n- Insert：插入后不会分裂\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/insertsafe20230831221935.png)\n\n- Delete：删除后不会合并\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/deletesaf20230831222155.png)\n\n主要的改变在**Findleaf()**函数中，可以先定义一个枚举类\n\n```c++\nenum class Operation {SEARCH, INSERT, REMOVE};\n```\n\n将操作类型和安全条件都放在findleaf中实现\n\n这里还需要用到之前一直都没有用到的``Transaction``，是一个处理事务的类，这里主要用到其中**AddIntoPageSet()**函数，可以通过**GetPageSet()**获取存储页面的队列，具体实现自行查阅。这里可以将加了写锁的祖先page加入该队列，在确定安全节点后释放其所有祖先节点，释放要从上向下依次释放，因为上级的锁被争用的更为激烈。\n\n哦对了，**千万不要忘记给树一个根锁**，为什么还要一个root_latch呢？这里的root_latch不是用来锁住树根节点的，而是整个树的入口，因为当你**Insert**或者**Delete**导致树根改变时，如果没有锁住树的入口，那么其他线程的操作可能已经在原来树根的地方排队等候了，等这边树根改变之后释放写锁，后来的进程还会从之前等候的位置等待进入，那么这个时候拿到的节点便不是根节点了。\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/rootlatch_20230901102911.png)\n\n只要前面的B+树实现没问题，那后面的并发索引的实现就考验细心程度了，改了又改，最后终于过了\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/grade50-20230901100758.png)\n\n本地测试的``b_plus_tree_contention_test``会评估全局锁和你的实现的耗时比，正确的实现应该在2.5~3.5之间\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/evaluate-2023-08-31-2138.png)\n\n**nodes：**这里我只实现了悲观锁，乐观锁部分还没有尝试，还有很大的提升空间\n\n\n\n## Sum up\n\n最后P2就到此为止，之后有新回忆起的细节再往博客里添加吧，整个过程真的很磨砺人，不论是代码能力还是debug能力都有一定的提升（多线程DEBUG是真的不好搞TAT）收获颇多,最后在附上一个**比较**完整的[concurrent_test文件](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/b_plus_tree_concurrent_test.cpp)（还是和线上测试不同，不过要比本地的测试样例强很多）\n\n","source":"_posts/CMU15445 P2cp2.md","raw":"---\ntitle: CMU15445 P2 Checkpoint2\ncategories: CMU15445\ntags: \n    - CMU15445\n    - Database\ndate: 2023-09-01 12:40:00\ndescription: B+树并发索引\ncover: https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/445pic1.jpg\ntop_img: rgba(0,0,0,0)\n---\n## 前言\n\n上一篇我们已经实现了B+树，因为本地测试案例里包含了迭代器的实现，所以我们也可以将前三个task作为一个整体\n\n## Task3 Index Iterator\n\nIterator的实现主要在``index_iterator``文件中，而调用的接口则在``b_plus_tree``中的``begin()``、``begin(key)``、``end()``函数中\n\n主要的作用就是直接从叶子层遍历整个数据，在一些需要用到连续数据的时候不必每次都从根节点进行遍历\n\n### 内部实现\n\n迭代器内部的实现主要有以下几个函数\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/iterator-20230831184023.png)\n\n在**Iterator**类中添加几个成员变量，我这里添加了**leaf**, **index**, 还有一个需要的**bufferpoolmanager**\n\n**leaf**代表了叶节点，**index**代表了数据在array中的索引，两个变量即可确定迭代器需要的数据，bufferpoolmanager的作用就是在叶子节点变更时，**通过leaf的next_page_id**拿到下个叶节点\n\n这里的函数都不难，无非只有**operator++()**内容稍微多一点点，需要区分两个情况\n\n1. 在叶节点中递增\n2. 在叶节点间递增\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/iterator2-2023-08-31-2138.png)\n\n如果是叶节点内递增，index直接++即可；如果是叶节点间进行递增，则可以通过leaf的**next_page_id**获取其nextpage，同时将index置零即可实现++操作\n\n### 接口实现\n\n没什么难度，``begin()``就是在Findeaf的过程中始终拿第一个value，``end()``则是相反，``begin(key)``则是查找指定key的迭代器，有点类似``GetValue``，findleaf可以直接实现。\n\n## 重要！！！\n\n实现了前三个Task，只剩最后一个并发控制没有实现了。并发控制实现的基础，肯定是之前的B+树索引的正确实现，B+树部分的实现有误，并发控制怎么都不会跑通的。\n\n你以为你过了checkpoint1就代表你的B+树没问题了？\n\ncheckpoint1的测试样例弱到查不出B+树的错误，我在Remove函数出错的情况下，提交checkpoint1代码，50分通过。\n\n那该怎么办呢？\n\nProject2文档中有写道\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/hint20230831215232.png)\n\n并发设计不允许用全局锁，但是我们可以先上一把大锁来验证一下B+树实现的正确性啊( ﹁ ﹁ ) ~\n\n所以在前面三个Task的基础上上一把大锁，然后直接将代码交到Gradescope上去，果不其然，一堆报错\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/gradescope20230831215636.png)\n\n开始修改代码，一定要改到用上全局锁之后，**全部通过**才可以，不然无论你的锁实现的正确与否，都会报错。\n\n保证前三个Task的正确性之后，就来到了最后一个环节，并发控制。\n\n## Task4 Concurrent Index\n\n个人认为并发控制不是特别复杂，主要是理解课上讲的``latch crabbing``机制，先给子节点上锁，再给父节点解锁，不同操作的上锁解锁逻辑不同\n\n- GetValue：没有修改数据，所以只用上读锁，读锁非常简单，先拿子节点，上锁，释放父节点上读锁即可\n- Insert：沿途加写锁，直到遇到安全节点可释放其祖先页面的锁\n- Delete：沿途加写锁，直到遇到安全节点可释放其祖先页面的锁\n\n重点要梳理的就是**插入**和**删除**对安全节点的定义，什么叫安全呢？安全就是该节点的变动不会影响到父节点。那为什么一旦有安全节点，就可以释放祖先页面的锁呢？安全节点不会影响到父节点，其父节点更不会修改祖先页面。\n\n下面重点讨论**Insert**和**Delete**对安全节点的定义\n\n- Insert：插入后不会分裂\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/insertsafe20230831221935.png)\n\n- Delete：删除后不会合并\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/deletesaf20230831222155.png)\n\n主要的改变在**Findleaf()**函数中，可以先定义一个枚举类\n\n```c++\nenum class Operation {SEARCH, INSERT, REMOVE};\n```\n\n将操作类型和安全条件都放在findleaf中实现\n\n这里还需要用到之前一直都没有用到的``Transaction``，是一个处理事务的类，这里主要用到其中**AddIntoPageSet()**函数，可以通过**GetPageSet()**获取存储页面的队列，具体实现自行查阅。这里可以将加了写锁的祖先page加入该队列，在确定安全节点后释放其所有祖先节点，释放要从上向下依次释放，因为上级的锁被争用的更为激烈。\n\n哦对了，**千万不要忘记给树一个根锁**，为什么还要一个root_latch呢？这里的root_latch不是用来锁住树根节点的，而是整个树的入口，因为当你**Insert**或者**Delete**导致树根改变时，如果没有锁住树的入口，那么其他线程的操作可能已经在原来树根的地方排队等候了，等这边树根改变之后释放写锁，后来的进程还会从之前等候的位置等待进入，那么这个时候拿到的节点便不是根节点了。\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/rootlatch_20230901102911.png)\n\n只要前面的B+树实现没问题，那后面的并发索引的实现就考验细心程度了，改了又改，最后终于过了\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/grade50-20230901100758.png)\n\n本地测试的``b_plus_tree_contention_test``会评估全局锁和你的实现的耗时比，正确的实现应该在2.5~3.5之间\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/evaluate-2023-08-31-2138.png)\n\n**nodes：**这里我只实现了悲观锁，乐观锁部分还没有尝试，还有很大的提升空间\n\n\n\n## Sum up\n\n最后P2就到此为止，之后有新回忆起的细节再往博客里添加吧，整个过程真的很磨砺人，不论是代码能力还是debug能力都有一定的提升（多线程DEBUG是真的不好搞TAT）收获颇多,最后在附上一个**比较**完整的[concurrent_test文件](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/b_plus_tree_concurrent_test.cpp)（还是和线上测试不同，不过要比本地的测试样例强很多）\n\n","slug":"CMU15445 P2cp2","published":1,"updated":"2023-09-01T04:50:35.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmuf8mjk0001cjjghdog9ne0","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇我们已经实现了B+树，因为本地测试案例里包含了迭代器的实现，所以我们也可以将前三个task作为一个整体</p>\n<h2 id=\"Task3-Index-Iterator\"><a href=\"#Task3-Index-Iterator\" class=\"headerlink\" title=\"Task3 Index Iterator\"></a>Task3 Index Iterator</h2><p>Iterator的实现主要在<code>index_iterator</code>文件中，而调用的接口则在<code>b_plus_tree</code>中的<code>begin()</code>、<code>begin(key)</code>、<code>end()</code>函数中</p>\n<p>主要的作用就是直接从叶子层遍历整个数据，在一些需要用到连续数据的时候不必每次都从根节点进行遍历</p>\n<h3 id=\"内部实现\"><a href=\"#内部实现\" class=\"headerlink\" title=\"内部实现\"></a>内部实现</h3><p>迭代器内部的实现主要有以下几个函数</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/iterator-20230831184023.png\"></p>\n<p>在<strong>Iterator</strong>类中添加几个成员变量，我这里添加了<strong>leaf</strong>, <strong>index</strong>, 还有一个需要的<strong>bufferpoolmanager</strong></p>\n<p><strong>leaf</strong>代表了叶节点，<strong>index</strong>代表了数据在array中的索引，两个变量即可确定迭代器需要的数据，bufferpoolmanager的作用就是在叶子节点变更时，<strong>通过leaf的next_page_id</strong>拿到下个叶节点</p>\n<p>这里的函数都不难，无非只有**operator++()**内容稍微多一点点，需要区分两个情况</p>\n<ol>\n<li>在叶节点中递增</li>\n<li>在叶节点间递增</li>\n</ol>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/iterator2-2023-08-31-2138.png\"></p>\n<p>如果是叶节点内递增，index直接++即可；如果是叶节点间进行递增，则可以通过leaf的<strong>next_page_id</strong>获取其nextpage，同时将index置零即可实现++操作</p>\n<h3 id=\"接口实现\"><a href=\"#接口实现\" class=\"headerlink\" title=\"接口实现\"></a>接口实现</h3><p>没什么难度，<code>begin()</code>就是在Findeaf的过程中始终拿第一个value，<code>end()</code>则是相反，<code>begin(key)</code>则是查找指定key的迭代器，有点类似<code>GetValue</code>，findleaf可以直接实现。</p>\n<h2 id=\"重要！！！\"><a href=\"#重要！！！\" class=\"headerlink\" title=\"重要！！！\"></a>重要！！！</h2><p>实现了前三个Task，只剩最后一个并发控制没有实现了。并发控制实现的基础，肯定是之前的B+树索引的正确实现，B+树部分的实现有误，并发控制怎么都不会跑通的。</p>\n<p>你以为你过了checkpoint1就代表你的B+树没问题了？</p>\n<p>checkpoint1的测试样例弱到查不出B+树的错误，我在Remove函数出错的情况下，提交checkpoint1代码，50分通过。</p>\n<p>那该怎么办呢？</p>\n<p>Project2文档中有写道</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/hint20230831215232.png\"></p>\n<p>并发设计不允许用全局锁，但是我们可以先上一把大锁来验证一下B+树实现的正确性啊( ﹁ ﹁ ) ~</p>\n<p>所以在前面三个Task的基础上上一把大锁，然后直接将代码交到Gradescope上去，果不其然，一堆报错</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/gradescope20230831215636.png\"></p>\n<p>开始修改代码，一定要改到用上全局锁之后，<strong>全部通过</strong>才可以，不然无论你的锁实现的正确与否，都会报错。</p>\n<p>保证前三个Task的正确性之后，就来到了最后一个环节，并发控制。</p>\n<h2 id=\"Task4-Concurrent-Index\"><a href=\"#Task4-Concurrent-Index\" class=\"headerlink\" title=\"Task4 Concurrent Index\"></a>Task4 Concurrent Index</h2><p>个人认为并发控制不是特别复杂，主要是理解课上讲的<code>latch crabbing</code>机制，先给子节点上锁，再给父节点解锁，不同操作的上锁解锁逻辑不同</p>\n<ul>\n<li>GetValue：没有修改数据，所以只用上读锁，读锁非常简单，先拿子节点，上锁，释放父节点上读锁即可</li>\n<li>Insert：沿途加写锁，直到遇到安全节点可释放其祖先页面的锁</li>\n<li>Delete：沿途加写锁，直到遇到安全节点可释放其祖先页面的锁</li>\n</ul>\n<p>重点要梳理的就是<strong>插入</strong>和<strong>删除</strong>对安全节点的定义，什么叫安全呢？安全就是该节点的变动不会影响到父节点。那为什么一旦有安全节点，就可以释放祖先页面的锁呢？安全节点不会影响到父节点，其父节点更不会修改祖先页面。</p>\n<p>下面重点讨论<strong>Insert</strong>和<strong>Delete</strong>对安全节点的定义</p>\n<ul>\n<li>Insert：插入后不会分裂</li>\n</ul>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/insertsafe20230831221935.png\"></p>\n<ul>\n<li>Delete：删除后不会合并</li>\n</ul>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/deletesaf20230831222155.png\"></p>\n<p>主要的改变在**Findleaf()**函数中，可以先定义一个枚举类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">Operation</span> &#123;SEARCH, INSERT, REMOVE&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>将操作类型和安全条件都放在findleaf中实现</p>\n<p>这里还需要用到之前一直都没有用到的<code>Transaction</code>，是一个处理事务的类，这里主要用到其中**AddIntoPageSet()<strong>函数，可以通过</strong>GetPageSet()**获取存储页面的队列，具体实现自行查阅。这里可以将加了写锁的祖先page加入该队列，在确定安全节点后释放其所有祖先节点，释放要从上向下依次释放，因为上级的锁被争用的更为激烈。</p>\n<p>哦对了，<strong>千万不要忘记给树一个根锁</strong>，为什么还要一个root_latch呢？这里的root_latch不是用来锁住树根节点的，而是整个树的入口，因为当你<strong>Insert</strong>或者<strong>Delete</strong>导致树根改变时，如果没有锁住树的入口，那么其他线程的操作可能已经在原来树根的地方排队等候了，等这边树根改变之后释放写锁，后来的进程还会从之前等候的位置等待进入，那么这个时候拿到的节点便不是根节点了。</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/rootlatch_20230901102911.png\"></p>\n<p>只要前面的B+树实现没问题，那后面的并发索引的实现就考验细心程度了，改了又改，最后终于过了</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/grade50-20230901100758.png\"></p>\n<p>本地测试的<code>b_plus_tree_contention_test</code>会评估全局锁和你的实现的耗时比，正确的实现应该在2.5~3.5之间</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/evaluate-2023-08-31-2138.png\"></p>\n<p><strong>nodes：</strong>这里我只实现了悲观锁，乐观锁部分还没有尝试，还有很大的提升空间</p>\n<h2 id=\"Sum-up\"><a href=\"#Sum-up\" class=\"headerlink\" title=\"Sum up\"></a>Sum up</h2><p>最后P2就到此为止，之后有新回忆起的细节再往博客里添加吧，整个过程真的很磨砺人，不论是代码能力还是debug能力都有一定的提升（多线程DEBUG是真的不好搞TAT）收获颇多,最后在附上一个<strong>比较</strong>完整的<a href=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/b_plus_tree_concurrent_test.cpp\">concurrent_test文件</a>（还是和线上测试不同，不过要比本地的测试样例强很多）</p>\n","site":{"data":{}},"cover_type":"img","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇我们已经实现了B+树，因为本地测试案例里包含了迭代器的实现，所以我们也可以将前三个task作为一个整体</p>\n<h2 id=\"Task3-Index-Iterator\"><a href=\"#Task3-Index-Iterator\" class=\"headerlink\" title=\"Task3 Index Iterator\"></a>Task3 Index Iterator</h2><p>Iterator的实现主要在<code>index_iterator</code>文件中，而调用的接口则在<code>b_plus_tree</code>中的<code>begin()</code>、<code>begin(key)</code>、<code>end()</code>函数中</p>\n<p>主要的作用就是直接从叶子层遍历整个数据，在一些需要用到连续数据的时候不必每次都从根节点进行遍历</p>\n<h3 id=\"内部实现\"><a href=\"#内部实现\" class=\"headerlink\" title=\"内部实现\"></a>内部实现</h3><p>迭代器内部的实现主要有以下几个函数</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/iterator-20230831184023.png\"></p>\n<p>在<strong>Iterator</strong>类中添加几个成员变量，我这里添加了<strong>leaf</strong>, <strong>index</strong>, 还有一个需要的<strong>bufferpoolmanager</strong></p>\n<p><strong>leaf</strong>代表了叶节点，<strong>index</strong>代表了数据在array中的索引，两个变量即可确定迭代器需要的数据，bufferpoolmanager的作用就是在叶子节点变更时，<strong>通过leaf的next_page_id</strong>拿到下个叶节点</p>\n<p>这里的函数都不难，无非只有**operator++()**内容稍微多一点点，需要区分两个情况</p>\n<ol>\n<li>在叶节点中递增</li>\n<li>在叶节点间递增</li>\n</ol>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/iterator2-2023-08-31-2138.png\"></p>\n<p>如果是叶节点内递增，index直接++即可；如果是叶节点间进行递增，则可以通过leaf的<strong>next_page_id</strong>获取其nextpage，同时将index置零即可实现++操作</p>\n<h3 id=\"接口实现\"><a href=\"#接口实现\" class=\"headerlink\" title=\"接口实现\"></a>接口实现</h3><p>没什么难度，<code>begin()</code>就是在Findeaf的过程中始终拿第一个value，<code>end()</code>则是相反，<code>begin(key)</code>则是查找指定key的迭代器，有点类似<code>GetValue</code>，findleaf可以直接实现。</p>\n<h2 id=\"重要！！！\"><a href=\"#重要！！！\" class=\"headerlink\" title=\"重要！！！\"></a>重要！！！</h2><p>实现了前三个Task，只剩最后一个并发控制没有实现了。并发控制实现的基础，肯定是之前的B+树索引的正确实现，B+树部分的实现有误，并发控制怎么都不会跑通的。</p>\n<p>你以为你过了checkpoint1就代表你的B+树没问题了？</p>\n<p>checkpoint1的测试样例弱到查不出B+树的错误，我在Remove函数出错的情况下，提交checkpoint1代码，50分通过。</p>\n<p>那该怎么办呢？</p>\n<p>Project2文档中有写道</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/hint20230831215232.png\"></p>\n<p>并发设计不允许用全局锁，但是我们可以先上一把大锁来验证一下B+树实现的正确性啊( ﹁ ﹁ ) ~</p>\n<p>所以在前面三个Task的基础上上一把大锁，然后直接将代码交到Gradescope上去，果不其然，一堆报错</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/gradescope20230831215636.png\"></p>\n<p>开始修改代码，一定要改到用上全局锁之后，<strong>全部通过</strong>才可以，不然无论你的锁实现的正确与否，都会报错。</p>\n<p>保证前三个Task的正确性之后，就来到了最后一个环节，并发控制。</p>\n<h2 id=\"Task4-Concurrent-Index\"><a href=\"#Task4-Concurrent-Index\" class=\"headerlink\" title=\"Task4 Concurrent Index\"></a>Task4 Concurrent Index</h2><p>个人认为并发控制不是特别复杂，主要是理解课上讲的<code>latch crabbing</code>机制，先给子节点上锁，再给父节点解锁，不同操作的上锁解锁逻辑不同</p>\n<ul>\n<li>GetValue：没有修改数据，所以只用上读锁，读锁非常简单，先拿子节点，上锁，释放父节点上读锁即可</li>\n<li>Insert：沿途加写锁，直到遇到安全节点可释放其祖先页面的锁</li>\n<li>Delete：沿途加写锁，直到遇到安全节点可释放其祖先页面的锁</li>\n</ul>\n<p>重点要梳理的就是<strong>插入</strong>和<strong>删除</strong>对安全节点的定义，什么叫安全呢？安全就是该节点的变动不会影响到父节点。那为什么一旦有安全节点，就可以释放祖先页面的锁呢？安全节点不会影响到父节点，其父节点更不会修改祖先页面。</p>\n<p>下面重点讨论<strong>Insert</strong>和<strong>Delete</strong>对安全节点的定义</p>\n<ul>\n<li>Insert：插入后不会分裂</li>\n</ul>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/insertsafe20230831221935.png\"></p>\n<ul>\n<li>Delete：删除后不会合并</li>\n</ul>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/deletesaf20230831222155.png\"></p>\n<p>主要的改变在**Findleaf()**函数中，可以先定义一个枚举类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">Operation</span> &#123;SEARCH, INSERT, REMOVE&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>将操作类型和安全条件都放在findleaf中实现</p>\n<p>这里还需要用到之前一直都没有用到的<code>Transaction</code>，是一个处理事务的类，这里主要用到其中**AddIntoPageSet()<strong>函数，可以通过</strong>GetPageSet()**获取存储页面的队列，具体实现自行查阅。这里可以将加了写锁的祖先page加入该队列，在确定安全节点后释放其所有祖先节点，释放要从上向下依次释放，因为上级的锁被争用的更为激烈。</p>\n<p>哦对了，<strong>千万不要忘记给树一个根锁</strong>，为什么还要一个root_latch呢？这里的root_latch不是用来锁住树根节点的，而是整个树的入口，因为当你<strong>Insert</strong>或者<strong>Delete</strong>导致树根改变时，如果没有锁住树的入口，那么其他线程的操作可能已经在原来树根的地方排队等候了，等这边树根改变之后释放写锁，后来的进程还会从之前等候的位置等待进入，那么这个时候拿到的节点便不是根节点了。</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/rootlatch_20230901102911.png\"></p>\n<p>只要前面的B+树实现没问题，那后面的并发索引的实现就考验细心程度了，改了又改，最后终于过了</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/grade50-20230901100758.png\"></p>\n<p>本地测试的<code>b_plus_tree_contention_test</code>会评估全局锁和你的实现的耗时比，正确的实现应该在2.5~3.5之间</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/evaluate-2023-08-31-2138.png\"></p>\n<p><strong>nodes：</strong>这里我只实现了悲观锁，乐观锁部分还没有尝试，还有很大的提升空间</p>\n<h2 id=\"Sum-up\"><a href=\"#Sum-up\" class=\"headerlink\" title=\"Sum up\"></a>Sum up</h2><p>最后P2就到此为止，之后有新回忆起的细节再往博客里添加吧，整个过程真的很磨砺人，不论是代码能力还是debug能力都有一定的提升（多线程DEBUG是真的不好搞TAT）收获颇多,最后在附上一个<strong>比较</strong>完整的<a href=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/b_plus_tree_concurrent_test.cpp\">concurrent_test文件</a>（还是和线上测试不同，不过要比本地的测试样例强很多）</p>\n"},{"title":"CMU15445 P3","date":"2023-09-22T09:50:00.000Z","description":"执行算子及优化策略","cover":"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/445pic1.jpg","top_img":"rgba(0,0,0,0)","_content":"# 1. Preview\n\n做P2花了很长时间，P3做起来相对于P2要容易一些，因为测试样例都在本地，所以也不会被奇奇怪怪的bug困扰。\n\nP2与P3的差别还是很明显的，P2是让我们从0实现一个B+树，而P3则更偏向考察阅读代码的能力，感觉整个P3的难点就在阅读代码、理解代码的部分，整个过程中我主要遇到的困难就是知道该怎么写，但是找不到对应的接口在哪，所以阅读代码是完成P3的一个非常重要的部分。\n\n在这个Task里，我们已经可以使用**BusTub shell**来执行SQL查询了，自己代码的实现可以直观的看到了\n\n同时，也要记得和网页版的bustub比对一下，就像P2的**B+ tree Printer**一样\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/archictecture.png)\n\n这是P3给我们的整体架构，P3就是实现**Optimizer**部分。\n\n一个SQL走进来，要经过**Parser**、**Binder**、**Planner**和**Optimizer**，他们的作用分别是什么呢？\n\n## Parser\n\n**Parser（解析器）**：\n\n- 解析器负责将输入的SQL查询字符串解析为语法树或解析树。这个树状结构表示了查询的语法结构，包括查询的关键字、表名、列名、操作符、条件等等。\n- 解析器会验证查询是否符合SQL语法规则，如果查询包含语法错误，解析器将抛出错误信息。\n- 解析器通常将查询转化为一种内部数据结构，以便后续的处理器（如查询优化器和执行引擎）能够更容易地处理和分析查询。\n\n\n\n一般情况下会使用第三方库\n\n## Binder\n\n**Binder（绑定器）**：\n\n- Binder是SQL查询处理的下一步，它负责解析器生成的语法树中的语义分析和绑定过程。\n- 绑定器的主要任务是将查询中的各个元素与数据库中的实际对象进行关联，例如将表名和列名映射到实际的数据库表和列。\n- 绑定器还会执行权限检查，以确保用户有权执行查询中指定的操作。\n- 在绑定阶段，还会对查询中的一些元素进行类型检查，以确保操作符和操作数之间的数据类型兼容。\n\n\n\n到这里，便生成了一棵Bustub可以理解的抽象语法树(AST)了。\n\n## Planner\n\n**Planner（计划生成器）**：\n\n- Planner是数据库查询处理的一部分，它的主要任务是将解析器生成的查询语法树转换成可执行的查询计划（Execution Plan）。\n- 查询计划是一种数据结构，描述了如何执行查询，包括了查询的执行顺序、使用哪些索引、连接哪些表、应用哪些过滤条件等等。\n- Planner需要考虑查询的复杂性、数据量、索引情况等因素，以选择一个高效的执行计划。\n- 这个执行计划将被传递给优化器，后者将进一步优化它以提高查询性能。\n\n\n\n这一步，遍历AST，生成查询计划，查询计划同样是一棵树的形式\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/planner.png)\n\n## Optimizer\n\n**Optimizer（查询优化器）**：\n\n- 优化器是数据库查询处理的重要组成部分，它的任务是接收查询计划并尝试找到最佳的执行路径，以最小化查询的执行时间和资源消耗。\n- 优化器会考虑多个执行策略，例如不同的连接顺序、索引使用、表扫描方式等，然后评估这些策略的成本，并选择最佳策略。\n- 为了评估执行策略的成本，优化器需要统计信息，例如表的大小、索引的选择性、磁盘I/O成本等。\n- 优化器的目标是生成一个执行计划，使查询在给定的资源约束下尽可能高效地执行。\n\n\n\n最后，再有优化器优化查询计划。\n\n考虑一个复杂的SQL情况\n\n```\nbustub> EXPLAIN SELECT colA, MAX(colB) FROM\n  (SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE) GROUP BY colA;\n```\n\nPlanner给出的计划是：\n\n```\n=== PLANNER ===\nProjection { exprs=[#0.0, #0.1] } | (__subquery#0.__mock_table_1.colA:INTEGER, <unnamed>:INTEGER)\n  Agg { types=[max], aggregates=[#0.1], group_by=[#0.0] } | (__subquery#0.__mock_table_1.colA:INTEGER, agg#0:INTEGER)\n    Projection { exprs=[#0.0, #0.1, #0.2, #0.3] } | (__subquery#0.__mock_table_1.colA:INTEGER, __subquery#0.__mock_table_1.colB:INTEGER, __subquery#0.__mock_table_3.colE:INTEGER, __subquery#0.__mock_table_3.colF:VARCHAR)\n      Projection { exprs=[#0.0, #0.1, #0.2, #0.3] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n        Filter { predicate=(#0.0=#0.2) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n          NestedLoopJoin { type=Inner, predicate=true } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n            MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)\n            MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n=== OPTIMIZER ===\nAgg { types=[max], aggregates=[#0.1], group_by=[#0.0] } | (__subquery#0.__mock_table_1.colA:INTEGER, <unnamed>:INTEGER)\n  HashJoin { type=Inner, left_key=#0.0, right_key=#0.0 } | (__subquery#0.__mock_table_1.colA:INTEGER, __subquery#0.__mock_table_1.colB:INTEGER, __subquery#0.__mock_table_3.colE:INTEGER, __subquery#0.__mock_table_3.colF:VARCHAR)\n    MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)\n    MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n```\n\n可以看到，本来很复杂的planner被优化成了\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/planner.jpg)\n\n\n\n\n\n总的来说，**Parser**和**Binder**是SQL查询处理的前两个关键步骤，它们负责将用户输入的SQL查询字符串解析为可执行的语法树，并将查询中的各个元素与数据库中的实际对象进行关联和验证。完成这些步骤后，查询就准备好由查询优化器进一步优化，并由执行引擎执行。**Planner**负责将查询语法树转化为查询计划的初始版本，而**Optimizer**负责进一步优化这个计划，以确保查询在数据库中以最佳方式执行。这个优化过程对于提高查询性能和减少资源消耗非常重要，尤其是在处理复杂查询时。\n\n\n\n接下来就是执行算子了，也来到了我们project要实现的部分\n\n# 2. Task1\n\n获得了最终的查询计划后，轮到执行算子出场了。\n\n这里使用的是火山模型，每个算子有``Init()``和``Next()``两个函数，分别对应了算子的初始化和向上层吐数据的部分。每一次调用``Next()``都会向上层算子吐一组**tuple**，有效避免了内存占用的问题\n\nTask1需要我们实现``SeqScan``、``Insert``、``Delete``和``IndexScan``四个算子，其中``SeqScan``和``IndexScan``类似，``Insert``和``Delete``类似，可以分成两组进行分析\n\n## 2.1 Scan\n\n### Seqscan\n\n先从``Seqscan``开始说，**Scan**就是遍历整个**table**，没什么难度，利用Bustub给我们的**Table Iterator**可以轻松实现，这里主要看一下Bustub的数据结构\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/struct-2023-09-02-1711.png)\n\n可以看到**table info**存在**Catalog**里，并且由**table Heap**保存整个表的**first page id**, 经由此才能拿到tuple\n\n获取**table info**后，将``table iterator``置为**table heap**的**begin()**，之后每次调用``Next()``函数，++iterator即可\n\n### IndexScan\n\n``IndexScan``也是类似的，和``SeqScan``的区别就在一个拿到的是**table info**，一个是**index info**\n\n多提一下，这里的index就对应着P2中我们实现的**B+ tree**，用**Index iterator**的时候，用到的接口都是我们在P2中实现的，``!=``、解引用*、``++``等重载函数也是我们亲自实现的。整个创建索引的过程，我们已经深刻理解（备受折磨）了。\n\n## 2.2 Write\n\n``Insert``和``Delete``是为二的写算子了，在写的同时不仅要将值在表中写入/删除，同时如果这个表有索引，还需要在其对应的索引中执行操作。最后要输出修改的元组数量。\n\n不断调用子算子的``Next()``函数获取要进行操作的元组，然后遍历表的所有索引组，依次将新的tuple及其索引插入索引即可，同时不要忘记记录修改的tuple数量\n\ntips：有一些会用到的接口函数比如``InsertTuple()``、``InsertEntry()``等等需要自己多看几遍代码，多读多记会有很大的帮助的，找不到也别着急，慢慢来（反正我急死了）\n\n# 3. Task2\n\nTask2要实现的算子相较Task1要复杂一些\n\n## 3.1 Agg\n\n聚合算子在实现的时候会有一个简化设计的假设，即聚合哈希表可以全部存入内存，不需要实现聚合的两阶段（分区、重哈希）。\n\n除此之外，还要注意区分**count(*)**和**count(column)**的区别，**count(*)**包含所有的列，相当于行数，统计结果的时候不会忽略NULL值，而**count(column)**则会忽略NULL值\n\n\n\n聚合类型只有以下五种，没有要求实现**avg**\n\n```C++\nenum class AggregationType { CountStarAggregate, CountAggregate, SumAggregate, MinAggregate, MaxAggregate };\n```\n\n\n\n通过头文件可以看到插入**agghashtable**需要**agg_key**和**agg_value**，这里的KV需要通过``MakeAggregateKey()``函数和``MakeAggregateValue()``函数将**tuple**转化为对应的**agg_key**和**agg_value**。这里的**key**是分组字段的排列组合，比如下面这条SQL:\n\n```sql\nSELECT count(*) FROM t1 GROUP BY gender, grade;\n```\n\n这里的**key**就是<gender, grade>的排列组合，比如性别分为man和woman，grade有ABCD四个等级，那么最后的key就有8组分别为<man, A> \\ < man, B> \\ <man, C> \\ <man, D> \\ <woman, A> \\ <woman, B> \\ <woman, C> \\ <woman, D>\n\n**value**就是agg对应的列值，比如**sum()**就是将每次的值累加\n\n所以总的来说就是**先分组，再聚集**\n\n头文件里给的``aht_``就是我们要在``Init()``函数中做的聚集哈希表初始化，先将表内信息按照**key**分好组别，再对各组的**value**进行聚集。\n\n``Init()``函数里，将子算子吐出的**tuple**插入聚集哈希表中，再在``Next()``函数中完成聚集的操作。如果是个空表，那么count(*)返回0，其他聚集操作返回**NULL**\n\n## 3.2 NLJ\n\nP3中只要实现NestedLoopJoin, 对HashJoin没有做要求（后面优化的时候还是要做一下），NestLoopJoin的逻辑非常简单，就是遍历两个表，如果配对成功就将其组合成的新tuple输出即可\n\n```\nfor outer_tuple in outer_table:\n\tfor inner_tuple in inner_table:\n\t\tif matched:\n\t\t\temit\n```\n\n要注意的是，为了使**left_tuple**和每个**right_tuple**进行比较，需要预先将**right_tuple**存至一个新的数组中，每次从左孩子中拉取一个tuple，与新数组进行比对，比对成功则组合并输出。这里有个很关键的问题，**left_tuple**与**right_tuple**的匹配可能存在多个，如果匹配成功后直接开始下一个**left_tuple**的match环节，那就会遗漏，所以可以设置一个cur，记录新数组中的index，如果没有到最后一个，那么**left_tuple**不用改变，继续与后面的**right_tuple**进行比对，直到遍历完新数组，再获取下一个**left_tuple**, 这样就不会有错过的匹配项了\n\n## 3.3 NestedIndexJoin\n\n同样是Join操作，当存在相等条件且恰好该条件在右侧表中存在索引，DBMS将会使用``NestedIndexJoinPlanNode``\n\n具体操作于NLJ类似，区别在匹配时通过``Key_predicate``构造出**probe key**, 这里P3帮我们简化了一些要考虑的情况，不会存在重复行及奇怪的情况(P2也是这样，没有重复key)，所以如果有错误，对着测试用例改改即可\n\n！！不要忘记区分**left_join**和**inner_join**\n\n# 4. Task3\n\ntask3需要我们实现**Sort、Limit**算子和**Top-N优化**\n\n## 4.1 Sort\n\n在没有index_key的情况下，**order_by**会采用``SortPlanNode``进行排序\n\n这里主要使用``std::sort``的标准库函数，自定义排序可以实用**lambda表达式**，对**order_bys**中获取的关键字进行比较，``compare``函数已经给好我们了(CompareLessThan和CompareGreaterThan)，我们只需要区分升降序即可，默认或者**ASC**即为升序，**DESC**则是降序，清楚之间的关系再进行实现就比较容易了\n\n关键内容如下：\n\n```c++\nstd::sort(sorted_tuples.begin(), sorted_tuples.end(), [](const Tuple &a, const Tuple &b){\n    for (auto [type, expr] : plan_->GetOrderBy()){\t\t\t//type为排序类型，expr用来比较两个tuple的前后顺序\n        //比较\n    }\n});\n```\n\n## 4.2 Limit\n\nLimit限制查询生成的tuple数量，比Seqscan多一个count记录输出tuple数量，一旦达到限制数量即停止\n\n## 4.3 Top-N optimizer\n\n到了最后一个任务，我们需要修改optimizer使Limit+sort的组合通过Top-N执行算子执行。\n\n默认的情况先将所有的tuple排序(sort excutor), 然后再取排序的结果前N个最小元素(limit excutor)，``TopNExcutor``要做的是在排序的过程中收集N个最小的元素，动态更新。\n\n这里与之前的任务有些不同，之前的任务仅需要修改对应的执行算子，这里还需要修改``src/optimizer/``目录下的``optimizer_custom_rules.cpp``目录中的各个优化函数，这里主要是``OptimizerSortLimitAsTopN()``\n\n一上来无从下手可以先阅读其他优化规则，比如``OptimizerNLJAsIndexJoin()``\n\n```c++\nstd::vector<AbstractPlanNodeRef> children; \nfor (const auto &child : plan->GetChildren()) {\n   children.emplace_back(OptimizeNLJAsIndexJoin(child));\n}\nauto optimized_plan = plan->CloneWithChildren(std::move(children));\n```\n\n对plan进行后序遍历，如果执行算子满足特定条件则进行优化，比如这里的``NLJAsIndexJoin``\n\n```c++\nif (optimizerd_plan->GetType() == PlanType::NestedLoopJoin){\n    ...\n}\n```\n\n与``NLJAsIndexJoin``相比``SortLimitAsTopN``的逻辑就简单很多\n\n```c++\nif (optimizerd_plan->GetType() == PlanType::Limit) {\n    ...\n    if (optimizerd_plan->GetChildAt(0)->GetType() == PlanType::Sort) {\n        ...\n    }\n}\n```\n\n自底向上遍历各个算子，如果该算子执行**Limit**操作，且其下层执行**Sort**操作，则可以将两个节点替换为**TopN**算子\n\n实现可以使用优先队列(std::priority_queue)，主要是要设计好自定义比较器，之前一直用的默认比较类型，这里学习了一下对自定义类的比较器做法\n\n```c++\nstd::priority_queue<Tuple, std::vector<Tuple>, decltype(cmp)> pq(cmp); //cmp 为自定义比较函数\n```\n\n至此，P3所有的必做项目都已完成\n\n# Leaderboard\n\nLeaderboard部分我没有很仔细的去做，网上也看到了很多大佬提供的各种方案，打算等有时间再进行仔细研究、尝试，这里我只实现了**HashJoin**，对**Query1**有一定的优化，**Q2**和**Q3**的优化就放到以后了-。-\n\n``HashJoin``主要对Join操作进行的优化，在``optimizer_custom_rules.cpp``中将注释的那行取消注释即为开启``NLJAsHash``优化，进去看一下可以看到，该优化器会将类型为``NestLoopJoin``且比较类型为**Equal**的操作，优化为**HashJoin**，我们实现**HashJoin Excutor**即可\n\nHashJoin主要分为两个阶段：\n\n- Build阶段\n\n​\t\t将右表数据存入哈希表\n\n- Probe阶段\n\n​\t\t扫描左表，在哈希表中查找，存在对应值则匹配\n\n在``Init()``阶段遍历右表，其tuple调用``HashValue()``后存入哈希表，再遍历左表，将其与哈希表中tuple进行匹配，leadborad测试样例只要求了**inner join**，但是其他测试样例需要我们区分**inner join**和**left join**，在打开``NLJAsHash``优化策略后，其他的Join操作也会被优化为**HashJoin**，所以要考虑到**left join**，和之前的要求相似，这里就不再赘述。最后将匹配上的**new tuple**放入临时的数组，Init就完成了\n\n``Next()``函数就如之前一样，不断emit tuple即可。\n\n# Debug && Sum Up\n\n这里debug可以用GDB\n\n```shell\ngdb ./bin/bustub-sqllogictest\t\t\t\t\t\t//gdb\nset args ../test/sql/p3.01-seqscan.slt --verbose\t//设置参数\nb seq_scan_excutor.cpp \t\t\t\t\t\t\t\t//断点\n```\n\n也可以``make shell``\n\n直接用IDEA(我用的vscode)在对应执行器中打断点，再输入出错的SQL语句，以定位错误\n\n至此，P3结束，开始P4篇章!\n","source":"_posts/CMU15445 P3.md","raw":"---\ntitle: CMU15445 P3\ncategories: CMU15445\ntags: \n    - CMU15445\n    - Database\n    - Query Execution\ndate: 2023-09-22 17:50:00\ndescription: 执行算子及优化策略\ncover: https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/445pic1.jpg\ntop_img: rgba(0,0,0,0)\n---\n# 1. Preview\n\n做P2花了很长时间，P3做起来相对于P2要容易一些，因为测试样例都在本地，所以也不会被奇奇怪怪的bug困扰。\n\nP2与P3的差别还是很明显的，P2是让我们从0实现一个B+树，而P3则更偏向考察阅读代码的能力，感觉整个P3的难点就在阅读代码、理解代码的部分，整个过程中我主要遇到的困难就是知道该怎么写，但是找不到对应的接口在哪，所以阅读代码是完成P3的一个非常重要的部分。\n\n在这个Task里，我们已经可以使用**BusTub shell**来执行SQL查询了，自己代码的实现可以直观的看到了\n\n同时，也要记得和网页版的bustub比对一下，就像P2的**B+ tree Printer**一样\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/archictecture.png)\n\n这是P3给我们的整体架构，P3就是实现**Optimizer**部分。\n\n一个SQL走进来，要经过**Parser**、**Binder**、**Planner**和**Optimizer**，他们的作用分别是什么呢？\n\n## Parser\n\n**Parser（解析器）**：\n\n- 解析器负责将输入的SQL查询字符串解析为语法树或解析树。这个树状结构表示了查询的语法结构，包括查询的关键字、表名、列名、操作符、条件等等。\n- 解析器会验证查询是否符合SQL语法规则，如果查询包含语法错误，解析器将抛出错误信息。\n- 解析器通常将查询转化为一种内部数据结构，以便后续的处理器（如查询优化器和执行引擎）能够更容易地处理和分析查询。\n\n\n\n一般情况下会使用第三方库\n\n## Binder\n\n**Binder（绑定器）**：\n\n- Binder是SQL查询处理的下一步，它负责解析器生成的语法树中的语义分析和绑定过程。\n- 绑定器的主要任务是将查询中的各个元素与数据库中的实际对象进行关联，例如将表名和列名映射到实际的数据库表和列。\n- 绑定器还会执行权限检查，以确保用户有权执行查询中指定的操作。\n- 在绑定阶段，还会对查询中的一些元素进行类型检查，以确保操作符和操作数之间的数据类型兼容。\n\n\n\n到这里，便生成了一棵Bustub可以理解的抽象语法树(AST)了。\n\n## Planner\n\n**Planner（计划生成器）**：\n\n- Planner是数据库查询处理的一部分，它的主要任务是将解析器生成的查询语法树转换成可执行的查询计划（Execution Plan）。\n- 查询计划是一种数据结构，描述了如何执行查询，包括了查询的执行顺序、使用哪些索引、连接哪些表、应用哪些过滤条件等等。\n- Planner需要考虑查询的复杂性、数据量、索引情况等因素，以选择一个高效的执行计划。\n- 这个执行计划将被传递给优化器，后者将进一步优化它以提高查询性能。\n\n\n\n这一步，遍历AST，生成查询计划，查询计划同样是一棵树的形式\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/planner.png)\n\n## Optimizer\n\n**Optimizer（查询优化器）**：\n\n- 优化器是数据库查询处理的重要组成部分，它的任务是接收查询计划并尝试找到最佳的执行路径，以最小化查询的执行时间和资源消耗。\n- 优化器会考虑多个执行策略，例如不同的连接顺序、索引使用、表扫描方式等，然后评估这些策略的成本，并选择最佳策略。\n- 为了评估执行策略的成本，优化器需要统计信息，例如表的大小、索引的选择性、磁盘I/O成本等。\n- 优化器的目标是生成一个执行计划，使查询在给定的资源约束下尽可能高效地执行。\n\n\n\n最后，再有优化器优化查询计划。\n\n考虑一个复杂的SQL情况\n\n```\nbustub> EXPLAIN SELECT colA, MAX(colB) FROM\n  (SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE) GROUP BY colA;\n```\n\nPlanner给出的计划是：\n\n```\n=== PLANNER ===\nProjection { exprs=[#0.0, #0.1] } | (__subquery#0.__mock_table_1.colA:INTEGER, <unnamed>:INTEGER)\n  Agg { types=[max], aggregates=[#0.1], group_by=[#0.0] } | (__subquery#0.__mock_table_1.colA:INTEGER, agg#0:INTEGER)\n    Projection { exprs=[#0.0, #0.1, #0.2, #0.3] } | (__subquery#0.__mock_table_1.colA:INTEGER, __subquery#0.__mock_table_1.colB:INTEGER, __subquery#0.__mock_table_3.colE:INTEGER, __subquery#0.__mock_table_3.colF:VARCHAR)\n      Projection { exprs=[#0.0, #0.1, #0.2, #0.3] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n        Filter { predicate=(#0.0=#0.2) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n          NestedLoopJoin { type=Inner, predicate=true } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n            MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)\n            MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n=== OPTIMIZER ===\nAgg { types=[max], aggregates=[#0.1], group_by=[#0.0] } | (__subquery#0.__mock_table_1.colA:INTEGER, <unnamed>:INTEGER)\n  HashJoin { type=Inner, left_key=#0.0, right_key=#0.0 } | (__subquery#0.__mock_table_1.colA:INTEGER, __subquery#0.__mock_table_1.colB:INTEGER, __subquery#0.__mock_table_3.colE:INTEGER, __subquery#0.__mock_table_3.colF:VARCHAR)\n    MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)\n    MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)\n```\n\n可以看到，本来很复杂的planner被优化成了\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/planner.jpg)\n\n\n\n\n\n总的来说，**Parser**和**Binder**是SQL查询处理的前两个关键步骤，它们负责将用户输入的SQL查询字符串解析为可执行的语法树，并将查询中的各个元素与数据库中的实际对象进行关联和验证。完成这些步骤后，查询就准备好由查询优化器进一步优化，并由执行引擎执行。**Planner**负责将查询语法树转化为查询计划的初始版本，而**Optimizer**负责进一步优化这个计划，以确保查询在数据库中以最佳方式执行。这个优化过程对于提高查询性能和减少资源消耗非常重要，尤其是在处理复杂查询时。\n\n\n\n接下来就是执行算子了，也来到了我们project要实现的部分\n\n# 2. Task1\n\n获得了最终的查询计划后，轮到执行算子出场了。\n\n这里使用的是火山模型，每个算子有``Init()``和``Next()``两个函数，分别对应了算子的初始化和向上层吐数据的部分。每一次调用``Next()``都会向上层算子吐一组**tuple**，有效避免了内存占用的问题\n\nTask1需要我们实现``SeqScan``、``Insert``、``Delete``和``IndexScan``四个算子，其中``SeqScan``和``IndexScan``类似，``Insert``和``Delete``类似，可以分成两组进行分析\n\n## 2.1 Scan\n\n### Seqscan\n\n先从``Seqscan``开始说，**Scan**就是遍历整个**table**，没什么难度，利用Bustub给我们的**Table Iterator**可以轻松实现，这里主要看一下Bustub的数据结构\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/struct-2023-09-02-1711.png)\n\n可以看到**table info**存在**Catalog**里，并且由**table Heap**保存整个表的**first page id**, 经由此才能拿到tuple\n\n获取**table info**后，将``table iterator``置为**table heap**的**begin()**，之后每次调用``Next()``函数，++iterator即可\n\n### IndexScan\n\n``IndexScan``也是类似的，和``SeqScan``的区别就在一个拿到的是**table info**，一个是**index info**\n\n多提一下，这里的index就对应着P2中我们实现的**B+ tree**，用**Index iterator**的时候，用到的接口都是我们在P2中实现的，``!=``、解引用*、``++``等重载函数也是我们亲自实现的。整个创建索引的过程，我们已经深刻理解（备受折磨）了。\n\n## 2.2 Write\n\n``Insert``和``Delete``是为二的写算子了，在写的同时不仅要将值在表中写入/删除，同时如果这个表有索引，还需要在其对应的索引中执行操作。最后要输出修改的元组数量。\n\n不断调用子算子的``Next()``函数获取要进行操作的元组，然后遍历表的所有索引组，依次将新的tuple及其索引插入索引即可，同时不要忘记记录修改的tuple数量\n\ntips：有一些会用到的接口函数比如``InsertTuple()``、``InsertEntry()``等等需要自己多看几遍代码，多读多记会有很大的帮助的，找不到也别着急，慢慢来（反正我急死了）\n\n# 3. Task2\n\nTask2要实现的算子相较Task1要复杂一些\n\n## 3.1 Agg\n\n聚合算子在实现的时候会有一个简化设计的假设，即聚合哈希表可以全部存入内存，不需要实现聚合的两阶段（分区、重哈希）。\n\n除此之外，还要注意区分**count(*)**和**count(column)**的区别，**count(*)**包含所有的列，相当于行数，统计结果的时候不会忽略NULL值，而**count(column)**则会忽略NULL值\n\n\n\n聚合类型只有以下五种，没有要求实现**avg**\n\n```C++\nenum class AggregationType { CountStarAggregate, CountAggregate, SumAggregate, MinAggregate, MaxAggregate };\n```\n\n\n\n通过头文件可以看到插入**agghashtable**需要**agg_key**和**agg_value**，这里的KV需要通过``MakeAggregateKey()``函数和``MakeAggregateValue()``函数将**tuple**转化为对应的**agg_key**和**agg_value**。这里的**key**是分组字段的排列组合，比如下面这条SQL:\n\n```sql\nSELECT count(*) FROM t1 GROUP BY gender, grade;\n```\n\n这里的**key**就是<gender, grade>的排列组合，比如性别分为man和woman，grade有ABCD四个等级，那么最后的key就有8组分别为<man, A> \\ < man, B> \\ <man, C> \\ <man, D> \\ <woman, A> \\ <woman, B> \\ <woman, C> \\ <woman, D>\n\n**value**就是agg对应的列值，比如**sum()**就是将每次的值累加\n\n所以总的来说就是**先分组，再聚集**\n\n头文件里给的``aht_``就是我们要在``Init()``函数中做的聚集哈希表初始化，先将表内信息按照**key**分好组别，再对各组的**value**进行聚集。\n\n``Init()``函数里，将子算子吐出的**tuple**插入聚集哈希表中，再在``Next()``函数中完成聚集的操作。如果是个空表，那么count(*)返回0，其他聚集操作返回**NULL**\n\n## 3.2 NLJ\n\nP3中只要实现NestedLoopJoin, 对HashJoin没有做要求（后面优化的时候还是要做一下），NestLoopJoin的逻辑非常简单，就是遍历两个表，如果配对成功就将其组合成的新tuple输出即可\n\n```\nfor outer_tuple in outer_table:\n\tfor inner_tuple in inner_table:\n\t\tif matched:\n\t\t\temit\n```\n\n要注意的是，为了使**left_tuple**和每个**right_tuple**进行比较，需要预先将**right_tuple**存至一个新的数组中，每次从左孩子中拉取一个tuple，与新数组进行比对，比对成功则组合并输出。这里有个很关键的问题，**left_tuple**与**right_tuple**的匹配可能存在多个，如果匹配成功后直接开始下一个**left_tuple**的match环节，那就会遗漏，所以可以设置一个cur，记录新数组中的index，如果没有到最后一个，那么**left_tuple**不用改变，继续与后面的**right_tuple**进行比对，直到遍历完新数组，再获取下一个**left_tuple**, 这样就不会有错过的匹配项了\n\n## 3.3 NestedIndexJoin\n\n同样是Join操作，当存在相等条件且恰好该条件在右侧表中存在索引，DBMS将会使用``NestedIndexJoinPlanNode``\n\n具体操作于NLJ类似，区别在匹配时通过``Key_predicate``构造出**probe key**, 这里P3帮我们简化了一些要考虑的情况，不会存在重复行及奇怪的情况(P2也是这样，没有重复key)，所以如果有错误，对着测试用例改改即可\n\n！！不要忘记区分**left_join**和**inner_join**\n\n# 4. Task3\n\ntask3需要我们实现**Sort、Limit**算子和**Top-N优化**\n\n## 4.1 Sort\n\n在没有index_key的情况下，**order_by**会采用``SortPlanNode``进行排序\n\n这里主要使用``std::sort``的标准库函数，自定义排序可以实用**lambda表达式**，对**order_bys**中获取的关键字进行比较，``compare``函数已经给好我们了(CompareLessThan和CompareGreaterThan)，我们只需要区分升降序即可，默认或者**ASC**即为升序，**DESC**则是降序，清楚之间的关系再进行实现就比较容易了\n\n关键内容如下：\n\n```c++\nstd::sort(sorted_tuples.begin(), sorted_tuples.end(), [](const Tuple &a, const Tuple &b){\n    for (auto [type, expr] : plan_->GetOrderBy()){\t\t\t//type为排序类型，expr用来比较两个tuple的前后顺序\n        //比较\n    }\n});\n```\n\n## 4.2 Limit\n\nLimit限制查询生成的tuple数量，比Seqscan多一个count记录输出tuple数量，一旦达到限制数量即停止\n\n## 4.3 Top-N optimizer\n\n到了最后一个任务，我们需要修改optimizer使Limit+sort的组合通过Top-N执行算子执行。\n\n默认的情况先将所有的tuple排序(sort excutor), 然后再取排序的结果前N个最小元素(limit excutor)，``TopNExcutor``要做的是在排序的过程中收集N个最小的元素，动态更新。\n\n这里与之前的任务有些不同，之前的任务仅需要修改对应的执行算子，这里还需要修改``src/optimizer/``目录下的``optimizer_custom_rules.cpp``目录中的各个优化函数，这里主要是``OptimizerSortLimitAsTopN()``\n\n一上来无从下手可以先阅读其他优化规则，比如``OptimizerNLJAsIndexJoin()``\n\n```c++\nstd::vector<AbstractPlanNodeRef> children; \nfor (const auto &child : plan->GetChildren()) {\n   children.emplace_back(OptimizeNLJAsIndexJoin(child));\n}\nauto optimized_plan = plan->CloneWithChildren(std::move(children));\n```\n\n对plan进行后序遍历，如果执行算子满足特定条件则进行优化，比如这里的``NLJAsIndexJoin``\n\n```c++\nif (optimizerd_plan->GetType() == PlanType::NestedLoopJoin){\n    ...\n}\n```\n\n与``NLJAsIndexJoin``相比``SortLimitAsTopN``的逻辑就简单很多\n\n```c++\nif (optimizerd_plan->GetType() == PlanType::Limit) {\n    ...\n    if (optimizerd_plan->GetChildAt(0)->GetType() == PlanType::Sort) {\n        ...\n    }\n}\n```\n\n自底向上遍历各个算子，如果该算子执行**Limit**操作，且其下层执行**Sort**操作，则可以将两个节点替换为**TopN**算子\n\n实现可以使用优先队列(std::priority_queue)，主要是要设计好自定义比较器，之前一直用的默认比较类型，这里学习了一下对自定义类的比较器做法\n\n```c++\nstd::priority_queue<Tuple, std::vector<Tuple>, decltype(cmp)> pq(cmp); //cmp 为自定义比较函数\n```\n\n至此，P3所有的必做项目都已完成\n\n# Leaderboard\n\nLeaderboard部分我没有很仔细的去做，网上也看到了很多大佬提供的各种方案，打算等有时间再进行仔细研究、尝试，这里我只实现了**HashJoin**，对**Query1**有一定的优化，**Q2**和**Q3**的优化就放到以后了-。-\n\n``HashJoin``主要对Join操作进行的优化，在``optimizer_custom_rules.cpp``中将注释的那行取消注释即为开启``NLJAsHash``优化，进去看一下可以看到，该优化器会将类型为``NestLoopJoin``且比较类型为**Equal**的操作，优化为**HashJoin**，我们实现**HashJoin Excutor**即可\n\nHashJoin主要分为两个阶段：\n\n- Build阶段\n\n​\t\t将右表数据存入哈希表\n\n- Probe阶段\n\n​\t\t扫描左表，在哈希表中查找，存在对应值则匹配\n\n在``Init()``阶段遍历右表，其tuple调用``HashValue()``后存入哈希表，再遍历左表，将其与哈希表中tuple进行匹配，leadborad测试样例只要求了**inner join**，但是其他测试样例需要我们区分**inner join**和**left join**，在打开``NLJAsHash``优化策略后，其他的Join操作也会被优化为**HashJoin**，所以要考虑到**left join**，和之前的要求相似，这里就不再赘述。最后将匹配上的**new tuple**放入临时的数组，Init就完成了\n\n``Next()``函数就如之前一样，不断emit tuple即可。\n\n# Debug && Sum Up\n\n这里debug可以用GDB\n\n```shell\ngdb ./bin/bustub-sqllogictest\t\t\t\t\t\t//gdb\nset args ../test/sql/p3.01-seqscan.slt --verbose\t//设置参数\nb seq_scan_excutor.cpp \t\t\t\t\t\t\t\t//断点\n```\n\n也可以``make shell``\n\n直接用IDEA(我用的vscode)在对应执行器中打断点，再输入出错的SQL语句，以定位错误\n\n至此，P3结束，开始P4篇章!\n","slug":"CMU15445 P3","published":1,"updated":"2023-10-31T05:40:34.807Z","_id":"clmuf8mjn0004cjjgd6vdgkwq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-Preview\"><a href=\"#1-Preview\" class=\"headerlink\" title=\"1. Preview\"></a>1. Preview</h1><p>做P2花了很长时间，P3做起来相对于P2要容易一些，因为测试样例都在本地，所以也不会被奇奇怪怪的bug困扰。</p>\n<p>P2与P3的差别还是很明显的，P2是让我们从0实现一个B+树，而P3则更偏向考察阅读代码的能力，感觉整个P3的难点就在阅读代码、理解代码的部分，整个过程中我主要遇到的困难就是知道该怎么写，但是找不到对应的接口在哪，所以阅读代码是完成P3的一个非常重要的部分。</p>\n<p>在这个Task里，我们已经可以使用<strong>BusTub shell</strong>来执行SQL查询了，自己代码的实现可以直观的看到了</p>\n<p>同时，也要记得和网页版的bustub比对一下，就像P2的<strong>B+ tree Printer</strong>一样</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/archictecture.png\"></p>\n<p>这是P3给我们的整体架构，P3就是实现<strong>Optimizer</strong>部分。</p>\n<p>一个SQL走进来，要经过<strong>Parser</strong>、<strong>Binder</strong>、<strong>Planner</strong>和<strong>Optimizer</strong>，他们的作用分别是什么呢？</p>\n<h2 id=\"Parser\"><a href=\"#Parser\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p><strong>Parser（解析器）</strong>：</p>\n<ul>\n<li>解析器负责将输入的SQL查询字符串解析为语法树或解析树。这个树状结构表示了查询的语法结构，包括查询的关键字、表名、列名、操作符、条件等等。</li>\n<li>解析器会验证查询是否符合SQL语法规则，如果查询包含语法错误，解析器将抛出错误信息。</li>\n<li>解析器通常将查询转化为一种内部数据结构，以便后续的处理器（如查询优化器和执行引擎）能够更容易地处理和分析查询。</li>\n</ul>\n<p>一般情况下会使用第三方库</p>\n<h2 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h2><p><strong>Binder（绑定器）</strong>：</p>\n<ul>\n<li>Binder是SQL查询处理的下一步，它负责解析器生成的语法树中的语义分析和绑定过程。</li>\n<li>绑定器的主要任务是将查询中的各个元素与数据库中的实际对象进行关联，例如将表名和列名映射到实际的数据库表和列。</li>\n<li>绑定器还会执行权限检查，以确保用户有权执行查询中指定的操作。</li>\n<li>在绑定阶段，还会对查询中的一些元素进行类型检查，以确保操作符和操作数之间的数据类型兼容。</li>\n</ul>\n<p>到这里，便生成了一棵Bustub可以理解的抽象语法树(AST)了。</p>\n<h2 id=\"Planner\"><a href=\"#Planner\" class=\"headerlink\" title=\"Planner\"></a>Planner</h2><p><strong>Planner（计划生成器）</strong>：</p>\n<ul>\n<li>Planner是数据库查询处理的一部分，它的主要任务是将解析器生成的查询语法树转换成可执行的查询计划（Execution Plan）。</li>\n<li>查询计划是一种数据结构，描述了如何执行查询，包括了查询的执行顺序、使用哪些索引、连接哪些表、应用哪些过滤条件等等。</li>\n<li>Planner需要考虑查询的复杂性、数据量、索引情况等因素，以选择一个高效的执行计划。</li>\n<li>这个执行计划将被传递给优化器，后者将进一步优化它以提高查询性能。</li>\n</ul>\n<p>这一步，遍历AST，生成查询计划，查询计划同样是一棵树的形式</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/planner.png\"></p>\n<h2 id=\"Optimizer\"><a href=\"#Optimizer\" class=\"headerlink\" title=\"Optimizer\"></a>Optimizer</h2><p><strong>Optimizer（查询优化器）</strong>：</p>\n<ul>\n<li>优化器是数据库查询处理的重要组成部分，它的任务是接收查询计划并尝试找到最佳的执行路径，以最小化查询的执行时间和资源消耗。</li>\n<li>优化器会考虑多个执行策略，例如不同的连接顺序、索引使用、表扫描方式等，然后评估这些策略的成本，并选择最佳策略。</li>\n<li>为了评估执行策略的成本，优化器需要统计信息，例如表的大小、索引的选择性、磁盘I&#x2F;O成本等。</li>\n<li>优化器的目标是生成一个执行计划，使查询在给定的资源约束下尽可能高效地执行。</li>\n</ul>\n<p>最后，再有优化器优化查询计划。</p>\n<p>考虑一个复杂的SQL情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bustub&gt; EXPLAIN SELECT colA, MAX(colB) FROM</span><br><span class=\"line\">  (SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE) GROUP BY colA;</span><br></pre></td></tr></table></figure>\n\n<p>Planner给出的计划是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=== PLANNER ===</span><br><span class=\"line\">Projection &#123; exprs=[#0.0, #0.1] &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, &lt;unnamed&gt;:INTEGER)</span><br><span class=\"line\">  Agg &#123; types=[max], aggregates=[#0.1], group_by=[#0.0] &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, agg#0:INTEGER)</span><br><span class=\"line\">    Projection &#123; exprs=[#0.0, #0.1, #0.2, #0.3] &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, __subquery#0.__mock_table_1.colB:INTEGER, __subquery#0.__mock_table_3.colE:INTEGER, __subquery#0.__mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">      Projection &#123; exprs=[#0.0, #0.1, #0.2, #0.3] &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">        Filter &#123; predicate=(#0.0=#0.2) &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">          NestedLoopJoin &#123; type=Inner, predicate=true &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">            MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class=\"line\">            MockScan &#123; table=__mock_table_3 &#125; | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">Agg &#123; types=[max], aggregates=[#0.1], group_by=[#0.0] &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, &lt;unnamed&gt;:INTEGER)</span><br><span class=\"line\">  HashJoin &#123; type=Inner, left_key=#0.0, right_key=#0.0 &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, __subquery#0.__mock_table_1.colB:INTEGER, __subquery#0.__mock_table_3.colE:INTEGER, __subquery#0.__mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">    MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class=\"line\">    MockScan &#123; table=__mock_table_3 &#125; | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，本来很复杂的planner被优化成了</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/planner.jpg\"></p>\n<p>总的来说，<strong>Parser</strong>和<strong>Binder</strong>是SQL查询处理的前两个关键步骤，它们负责将用户输入的SQL查询字符串解析为可执行的语法树，并将查询中的各个元素与数据库中的实际对象进行关联和验证。完成这些步骤后，查询就准备好由查询优化器进一步优化，并由执行引擎执行。<strong>Planner</strong>负责将查询语法树转化为查询计划的初始版本，而<strong>Optimizer</strong>负责进一步优化这个计划，以确保查询在数据库中以最佳方式执行。这个优化过程对于提高查询性能和减少资源消耗非常重要，尤其是在处理复杂查询时。</p>\n<p>接下来就是执行算子了，也来到了我们project要实现的部分</p>\n<h1 id=\"2-Task1\"><a href=\"#2-Task1\" class=\"headerlink\" title=\"2. Task1\"></a>2. Task1</h1><p>获得了最终的查询计划后，轮到执行算子出场了。</p>\n<p>这里使用的是火山模型，每个算子有<code>Init()</code>和<code>Next()</code>两个函数，分别对应了算子的初始化和向上层吐数据的部分。每一次调用<code>Next()</code>都会向上层算子吐一组<strong>tuple</strong>，有效避免了内存占用的问题</p>\n<p>Task1需要我们实现<code>SeqScan</code>、<code>Insert</code>、<code>Delete</code>和<code>IndexScan</code>四个算子，其中<code>SeqScan</code>和<code>IndexScan</code>类似，<code>Insert</code>和<code>Delete</code>类似，可以分成两组进行分析</p>\n<h2 id=\"2-1-Scan\"><a href=\"#2-1-Scan\" class=\"headerlink\" title=\"2.1 Scan\"></a>2.1 Scan</h2><h3 id=\"Seqscan\"><a href=\"#Seqscan\" class=\"headerlink\" title=\"Seqscan\"></a>Seqscan</h3><p>先从<code>Seqscan</code>开始说，<strong>Scan</strong>就是遍历整个<strong>table</strong>，没什么难度，利用Bustub给我们的<strong>Table Iterator</strong>可以轻松实现，这里主要看一下Bustub的数据结构</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/struct-2023-09-02-1711.png\"></p>\n<p>可以看到<strong>table info</strong>存在<strong>Catalog</strong>里，并且由<strong>table Heap</strong>保存整个表的<strong>first page id</strong>, 经由此才能拿到tuple</p>\n<p>获取<strong>table info</strong>后，将<code>table iterator</code>置为<strong>table heap</strong>的**begin()**，之后每次调用<code>Next()</code>函数，++iterator即可</p>\n<h3 id=\"IndexScan\"><a href=\"#IndexScan\" class=\"headerlink\" title=\"IndexScan\"></a>IndexScan</h3><p><code>IndexScan</code>也是类似的，和<code>SeqScan</code>的区别就在一个拿到的是<strong>table info</strong>，一个是<strong>index info</strong></p>\n<p>多提一下，这里的index就对应着P2中我们实现的<strong>B+ tree</strong>，用<strong>Index iterator</strong>的时候，用到的接口都是我们在P2中实现的，<code>!=</code>、解引用*、<code>++</code>等重载函数也是我们亲自实现的。整个创建索引的过程，我们已经深刻理解（备受折磨）了。</p>\n<h2 id=\"2-2-Write\"><a href=\"#2-2-Write\" class=\"headerlink\" title=\"2.2 Write\"></a>2.2 Write</h2><p><code>Insert</code>和<code>Delete</code>是为二的写算子了，在写的同时不仅要将值在表中写入&#x2F;删除，同时如果这个表有索引，还需要在其对应的索引中执行操作。最后要输出修改的元组数量。</p>\n<p>不断调用子算子的<code>Next()</code>函数获取要进行操作的元组，然后遍历表的所有索引组，依次将新的tuple及其索引插入索引即可，同时不要忘记记录修改的tuple数量</p>\n<p>tips：有一些会用到的接口函数比如<code>InsertTuple()</code>、<code>InsertEntry()</code>等等需要自己多看几遍代码，多读多记会有很大的帮助的，找不到也别着急，慢慢来（反正我急死了）</p>\n<h1 id=\"3-Task2\"><a href=\"#3-Task2\" class=\"headerlink\" title=\"3. Task2\"></a>3. Task2</h1><p>Task2要实现的算子相较Task1要复杂一些</p>\n<h2 id=\"3-1-Agg\"><a href=\"#3-1-Agg\" class=\"headerlink\" title=\"3.1 Agg\"></a>3.1 Agg</h2><p>聚合算子在实现的时候会有一个简化设计的假设，即聚合哈希表可以全部存入内存，不需要实现聚合的两阶段（分区、重哈希）。</p>\n<p>除此之外，还要注意区分*<em>count(</em>)<strong>和</strong>count(column)<strong>的区别，</strong>count(*)<strong>包含所有的列，相当于行数，统计结果的时候不会忽略NULL值，而</strong>count(column)**则会忽略NULL值</p>\n<p>聚合类型只有以下五种，没有要求实现<strong>avg</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">AggregationType</span> &#123; CountStarAggregate, CountAggregate, SumAggregate, MinAggregate, MaxAggregate &#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过头文件可以看到插入<strong>agghashtable</strong>需要<strong>agg_key</strong>和<strong>agg_value</strong>，这里的KV需要通过<code>MakeAggregateKey()</code>函数和<code>MakeAggregateValue()</code>函数将<strong>tuple</strong>转化为对应的<strong>agg_key</strong>和<strong>agg_value</strong>。这里的<strong>key</strong>是分组字段的排列组合，比如下面这条SQL:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> gender, grade;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<strong>key</strong>就是&lt;gender, grade&gt;的排列组合，比如性别分为man和woman，grade有ABCD四个等级，那么最后的key就有8组分别为&lt;man, A&gt; \\ &lt; man, B&gt; \\ &lt;man, C&gt; \\ &lt;man, D&gt; \\ &lt;woman, A&gt; \\ &lt;woman, B&gt; \\ &lt;woman, C&gt; \\ &lt;woman, D&gt;</p>\n<p><strong>value</strong>就是agg对应的列值，比如**sum()**就是将每次的值累加</p>\n<p>所以总的来说就是<strong>先分组，再聚集</strong></p>\n<p>头文件里给的<code>aht_</code>就是我们要在<code>Init()</code>函数中做的聚集哈希表初始化，先将表内信息按照<strong>key</strong>分好组别，再对各组的<strong>value</strong>进行聚集。</p>\n<p><code>Init()</code>函数里，将子算子吐出的<strong>tuple</strong>插入聚集哈希表中，再在<code>Next()</code>函数中完成聚集的操作。如果是个空表，那么count(<em>)返回0，其他聚集操作返回*<em>NULL</em></em></p>\n<h2 id=\"3-2-NLJ\"><a href=\"#3-2-NLJ\" class=\"headerlink\" title=\"3.2 NLJ\"></a>3.2 NLJ</h2><p>P3中只要实现NestedLoopJoin, 对HashJoin没有做要求（后面优化的时候还是要做一下），NestLoopJoin的逻辑非常简单，就是遍历两个表，如果配对成功就将其组合成的新tuple输出即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for outer_tuple in outer_table:</span><br><span class=\"line\">\tfor inner_tuple in inner_table:</span><br><span class=\"line\">\t\tif matched:</span><br><span class=\"line\">\t\t\temit</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是，为了使<strong>left_tuple</strong>和每个<strong>right_tuple</strong>进行比较，需要预先将<strong>right_tuple</strong>存至一个新的数组中，每次从左孩子中拉取一个tuple，与新数组进行比对，比对成功则组合并输出。这里有个很关键的问题，<strong>left_tuple</strong>与<strong>right_tuple</strong>的匹配可能存在多个，如果匹配成功后直接开始下一个<strong>left_tuple</strong>的match环节，那就会遗漏，所以可以设置一个cur，记录新数组中的index，如果没有到最后一个，那么<strong>left_tuple</strong>不用改变，继续与后面的<strong>right_tuple</strong>进行比对，直到遍历完新数组，再获取下一个<strong>left_tuple</strong>, 这样就不会有错过的匹配项了</p>\n<h2 id=\"3-3-NestedIndexJoin\"><a href=\"#3-3-NestedIndexJoin\" class=\"headerlink\" title=\"3.3 NestedIndexJoin\"></a>3.3 NestedIndexJoin</h2><p>同样是Join操作，当存在相等条件且恰好该条件在右侧表中存在索引，DBMS将会使用<code>NestedIndexJoinPlanNode</code></p>\n<p>具体操作于NLJ类似，区别在匹配时通过<code>Key_predicate</code>构造出<strong>probe key</strong>, 这里P3帮我们简化了一些要考虑的情况，不会存在重复行及奇怪的情况(P2也是这样，没有重复key)，所以如果有错误，对着测试用例改改即可</p>\n<p>！！不要忘记区分<strong>left_join</strong>和<strong>inner_join</strong></p>\n<h1 id=\"4-Task3\"><a href=\"#4-Task3\" class=\"headerlink\" title=\"4. Task3\"></a>4. Task3</h1><p>task3需要我们实现<strong>Sort、Limit</strong>算子和<strong>Top-N优化</strong></p>\n<h2 id=\"4-1-Sort\"><a href=\"#4-1-Sort\" class=\"headerlink\" title=\"4.1 Sort\"></a>4.1 Sort</h2><p>在没有index_key的情况下，<strong>order_by</strong>会采用<code>SortPlanNode</code>进行排序</p>\n<p>这里主要使用<code>std::sort</code>的标准库函数，自定义排序可以实用<strong>lambda表达式</strong>，对<strong>order_bys</strong>中获取的关键字进行比较，<code>compare</code>函数已经给好我们了(CompareLessThan和CompareGreaterThan)，我们只需要区分升降序即可，默认或者<strong>ASC</strong>即为升序，<strong>DESC</strong>则是降序，清楚之间的关系再进行实现就比较容易了</p>\n<p>关键内容如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">sort</span>(sorted_tuples.<span class=\"built_in\">begin</span>(), sorted_tuples.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> Tuple &amp;a, <span class=\"type\">const</span> Tuple &amp;b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> [type, expr] : plan_-&gt;<span class=\"built_in\">GetOrderBy</span>())&#123;\t\t\t<span class=\"comment\">//type为排序类型，expr用来比较两个tuple的前后顺序</span></span><br><span class=\"line\">        <span class=\"comment\">//比较</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-Limit\"><a href=\"#4-2-Limit\" class=\"headerlink\" title=\"4.2 Limit\"></a>4.2 Limit</h2><p>Limit限制查询生成的tuple数量，比Seqscan多一个count记录输出tuple数量，一旦达到限制数量即停止</p>\n<h2 id=\"4-3-Top-N-optimizer\"><a href=\"#4-3-Top-N-optimizer\" class=\"headerlink\" title=\"4.3 Top-N optimizer\"></a>4.3 Top-N optimizer</h2><p>到了最后一个任务，我们需要修改optimizer使Limit+sort的组合通过Top-N执行算子执行。</p>\n<p>默认的情况先将所有的tuple排序(sort excutor), 然后再取排序的结果前N个最小元素(limit excutor)，<code>TopNExcutor</code>要做的是在排序的过程中收集N个最小的元素，动态更新。</p>\n<p>这里与之前的任务有些不同，之前的任务仅需要修改对应的执行算子，这里还需要修改<code>src/optimizer/</code>目录下的<code>optimizer_custom_rules.cpp</code>目录中的各个优化函数，这里主要是<code>OptimizerSortLimitAsTopN()</code></p>\n<p>一上来无从下手可以先阅读其他优化规则，比如<code>OptimizerNLJAsIndexJoin()</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;AbstractPlanNodeRef&gt; children; </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;<span class=\"built_in\">GetChildren</span>()) &#123;</span><br><span class=\"line\">   children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeNLJAsIndexJoin</span>(child));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> optimized_plan = plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(children));</span><br></pre></td></tr></table></figure>\n\n<p>对plan进行后序遍历，如果执行算子满足特定条件则进行优化，比如这里的<code>NLJAsIndexJoin</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (optimizerd_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::NestedLoopJoin)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与<code>NLJAsIndexJoin</code>相比<code>SortLimitAsTopN</code>的逻辑就简单很多</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (optimizerd_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Limit) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (optimizerd_plan-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">0</span>)-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Sort) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自底向上遍历各个算子，如果该算子执行<strong>Limit</strong>操作，且其下层执行<strong>Sort</strong>操作，则可以将两个节点替换为<strong>TopN</strong>算子</p>\n<p>实现可以使用优先队列(std::priority_queue)，主要是要设计好自定义比较器，之前一直用的默认比较类型，这里学习了一下对自定义类的比较器做法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::priority_queue&lt;Tuple, std::vector&lt;Tuple&gt;, <span class=\"keyword\">decltype</span>(cmp)&gt; <span class=\"built_in\">pq</span>(cmp); <span class=\"comment\">//cmp 为自定义比较函数</span></span><br></pre></td></tr></table></figure>\n\n<p>至此，P3所有的必做项目都已完成</p>\n<h1 id=\"Leaderboard\"><a href=\"#Leaderboard\" class=\"headerlink\" title=\"Leaderboard\"></a>Leaderboard</h1><p>Leaderboard部分我没有很仔细的去做，网上也看到了很多大佬提供的各种方案，打算等有时间再进行仔细研究、尝试，这里我只实现了<strong>HashJoin</strong>，对<strong>Query1</strong>有一定的优化，<strong>Q2</strong>和<strong>Q3</strong>的优化就放到以后了-。-</p>\n<p><code>HashJoin</code>主要对Join操作进行的优化，在<code>optimizer_custom_rules.cpp</code>中将注释的那行取消注释即为开启<code>NLJAsHash</code>优化，进去看一下可以看到，该优化器会将类型为<code>NestLoopJoin</code>且比较类型为<strong>Equal</strong>的操作，优化为<strong>HashJoin</strong>，我们实现<strong>HashJoin Excutor</strong>即可</p>\n<p>HashJoin主要分为两个阶段：</p>\n<ul>\n<li>Build阶段</li>\n</ul>\n<p>​\t\t将右表数据存入哈希表</p>\n<ul>\n<li>Probe阶段</li>\n</ul>\n<p>​\t\t扫描左表，在哈希表中查找，存在对应值则匹配</p>\n<p>在<code>Init()</code>阶段遍历右表，其tuple调用<code>HashValue()</code>后存入哈希表，再遍历左表，将其与哈希表中tuple进行匹配，leadborad测试样例只要求了<strong>inner join</strong>，但是其他测试样例需要我们区分<strong>inner join</strong>和<strong>left join</strong>，在打开<code>NLJAsHash</code>优化策略后，其他的Join操作也会被优化为<strong>HashJoin</strong>，所以要考虑到<strong>left join</strong>，和之前的要求相似，这里就不再赘述。最后将匹配上的<strong>new tuple</strong>放入临时的数组，Init就完成了</p>\n<p><code>Next()</code>函数就如之前一样，不断emit tuple即可。</p>\n<h1 id=\"Debug-Sum-Up\"><a href=\"#Debug-Sum-Up\" class=\"headerlink\" title=\"Debug &amp;&amp; Sum Up\"></a>Debug &amp;&amp; Sum Up</h1><p>这里debug可以用GDB</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdb ./bin/bustub-sqllogictest\t\t\t\t\t\t//gdb</span><br><span class=\"line\">set args ../test/sql/p3.01-seqscan.slt --verbose\t//设置参数</span><br><span class=\"line\">b seq_scan_excutor.cpp \t\t\t\t\t\t\t\t//断点</span><br></pre></td></tr></table></figure>\n\n<p>也可以<code>make shell</code></p>\n<p>直接用IDEA(我用的vscode)在对应执行器中打断点，再输入出错的SQL语句，以定位错误</p>\n<p>至此，P3结束，开始P4篇章!</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"butterfly配置文档","link_list":[{"name":"Butterfly","link":"https://butterfly.js.org/"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"1-Preview\"><a href=\"#1-Preview\" class=\"headerlink\" title=\"1. Preview\"></a>1. Preview</h1><p>做P2花了很长时间，P3做起来相对于P2要容易一些，因为测试样例都在本地，所以也不会被奇奇怪怪的bug困扰。</p>\n<p>P2与P3的差别还是很明显的，P2是让我们从0实现一个B+树，而P3则更偏向考察阅读代码的能力，感觉整个P3的难点就在阅读代码、理解代码的部分，整个过程中我主要遇到的困难就是知道该怎么写，但是找不到对应的接口在哪，所以阅读代码是完成P3的一个非常重要的部分。</p>\n<p>在这个Task里，我们已经可以使用<strong>BusTub shell</strong>来执行SQL查询了，自己代码的实现可以直观的看到了</p>\n<p>同时，也要记得和网页版的bustub比对一下，就像P2的<strong>B+ tree Printer</strong>一样</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/archictecture.png\"></p>\n<p>这是P3给我们的整体架构，P3就是实现<strong>Optimizer</strong>部分。</p>\n<p>一个SQL走进来，要经过<strong>Parser</strong>、<strong>Binder</strong>、<strong>Planner</strong>和<strong>Optimizer</strong>，他们的作用分别是什么呢？</p>\n<h2 id=\"Parser\"><a href=\"#Parser\" class=\"headerlink\" title=\"Parser\"></a>Parser</h2><p><strong>Parser（解析器）</strong>：</p>\n<ul>\n<li>解析器负责将输入的SQL查询字符串解析为语法树或解析树。这个树状结构表示了查询的语法结构，包括查询的关键字、表名、列名、操作符、条件等等。</li>\n<li>解析器会验证查询是否符合SQL语法规则，如果查询包含语法错误，解析器将抛出错误信息。</li>\n<li>解析器通常将查询转化为一种内部数据结构，以便后续的处理器（如查询优化器和执行引擎）能够更容易地处理和分析查询。</li>\n</ul>\n<p>一般情况下会使用第三方库</p>\n<h2 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h2><p><strong>Binder（绑定器）</strong>：</p>\n<ul>\n<li>Binder是SQL查询处理的下一步，它负责解析器生成的语法树中的语义分析和绑定过程。</li>\n<li>绑定器的主要任务是将查询中的各个元素与数据库中的实际对象进行关联，例如将表名和列名映射到实际的数据库表和列。</li>\n<li>绑定器还会执行权限检查，以确保用户有权执行查询中指定的操作。</li>\n<li>在绑定阶段，还会对查询中的一些元素进行类型检查，以确保操作符和操作数之间的数据类型兼容。</li>\n</ul>\n<p>到这里，便生成了一棵Bustub可以理解的抽象语法树(AST)了。</p>\n<h2 id=\"Planner\"><a href=\"#Planner\" class=\"headerlink\" title=\"Planner\"></a>Planner</h2><p><strong>Planner（计划生成器）</strong>：</p>\n<ul>\n<li>Planner是数据库查询处理的一部分，它的主要任务是将解析器生成的查询语法树转换成可执行的查询计划（Execution Plan）。</li>\n<li>查询计划是一种数据结构，描述了如何执行查询，包括了查询的执行顺序、使用哪些索引、连接哪些表、应用哪些过滤条件等等。</li>\n<li>Planner需要考虑查询的复杂性、数据量、索引情况等因素，以选择一个高效的执行计划。</li>\n<li>这个执行计划将被传递给优化器，后者将进一步优化它以提高查询性能。</li>\n</ul>\n<p>这一步，遍历AST，生成查询计划，查询计划同样是一棵树的形式</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/planner.png\"></p>\n<h2 id=\"Optimizer\"><a href=\"#Optimizer\" class=\"headerlink\" title=\"Optimizer\"></a>Optimizer</h2><p><strong>Optimizer（查询优化器）</strong>：</p>\n<ul>\n<li>优化器是数据库查询处理的重要组成部分，它的任务是接收查询计划并尝试找到最佳的执行路径，以最小化查询的执行时间和资源消耗。</li>\n<li>优化器会考虑多个执行策略，例如不同的连接顺序、索引使用、表扫描方式等，然后评估这些策略的成本，并选择最佳策略。</li>\n<li>为了评估执行策略的成本，优化器需要统计信息，例如表的大小、索引的选择性、磁盘I&#x2F;O成本等。</li>\n<li>优化器的目标是生成一个执行计划，使查询在给定的资源约束下尽可能高效地执行。</li>\n</ul>\n<p>最后，再有优化器优化查询计划。</p>\n<p>考虑一个复杂的SQL情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bustub&gt; EXPLAIN SELECT colA, MAX(colB) FROM</span><br><span class=\"line\">  (SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE) GROUP BY colA;</span><br></pre></td></tr></table></figure>\n\n<p>Planner给出的计划是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=== PLANNER ===</span><br><span class=\"line\">Projection &#123; exprs=[#0.0, #0.1] &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, &lt;unnamed&gt;:INTEGER)</span><br><span class=\"line\">  Agg &#123; types=[max], aggregates=[#0.1], group_by=[#0.0] &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, agg#0:INTEGER)</span><br><span class=\"line\">    Projection &#123; exprs=[#0.0, #0.1, #0.2, #0.3] &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, __subquery#0.__mock_table_1.colB:INTEGER, __subquery#0.__mock_table_3.colE:INTEGER, __subquery#0.__mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">      Projection &#123; exprs=[#0.0, #0.1, #0.2, #0.3] &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">        Filter &#123; predicate=(#0.0=#0.2) &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">          NestedLoopJoin &#123; type=Inner, predicate=true &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">            MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class=\"line\">            MockScan &#123; table=__mock_table_3 &#125; | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">=== OPTIMIZER ===</span><br><span class=\"line\">Agg &#123; types=[max], aggregates=[#0.1], group_by=[#0.0] &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, &lt;unnamed&gt;:INTEGER)</span><br><span class=\"line\">  HashJoin &#123; type=Inner, left_key=#0.0, right_key=#0.0 &#125; | (__subquery#0.__mock_table_1.colA:INTEGER, __subquery#0.__mock_table_1.colB:INTEGER, __subquery#0.__mock_table_3.colE:INTEGER, __subquery#0.__mock_table_3.colF:VARCHAR)</span><br><span class=\"line\">    MockScan &#123; table=__mock_table_1 &#125; | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)</span><br><span class=\"line\">    MockScan &#123; table=__mock_table_3 &#125; | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，本来很复杂的planner被优化成了</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/planner.jpg\"></p>\n<p>总的来说，<strong>Parser</strong>和<strong>Binder</strong>是SQL查询处理的前两个关键步骤，它们负责将用户输入的SQL查询字符串解析为可执行的语法树，并将查询中的各个元素与数据库中的实际对象进行关联和验证。完成这些步骤后，查询就准备好由查询优化器进一步优化，并由执行引擎执行。<strong>Planner</strong>负责将查询语法树转化为查询计划的初始版本，而<strong>Optimizer</strong>负责进一步优化这个计划，以确保查询在数据库中以最佳方式执行。这个优化过程对于提高查询性能和减少资源消耗非常重要，尤其是在处理复杂查询时。</p>\n<p>接下来就是执行算子了，也来到了我们project要实现的部分</p>\n<h1 id=\"2-Task1\"><a href=\"#2-Task1\" class=\"headerlink\" title=\"2. Task1\"></a>2. Task1</h1><p>获得了最终的查询计划后，轮到执行算子出场了。</p>\n<p>这里使用的是火山模型，每个算子有<code>Init()</code>和<code>Next()</code>两个函数，分别对应了算子的初始化和向上层吐数据的部分。每一次调用<code>Next()</code>都会向上层算子吐一组<strong>tuple</strong>，有效避免了内存占用的问题</p>\n<p>Task1需要我们实现<code>SeqScan</code>、<code>Insert</code>、<code>Delete</code>和<code>IndexScan</code>四个算子，其中<code>SeqScan</code>和<code>IndexScan</code>类似，<code>Insert</code>和<code>Delete</code>类似，可以分成两组进行分析</p>\n<h2 id=\"2-1-Scan\"><a href=\"#2-1-Scan\" class=\"headerlink\" title=\"2.1 Scan\"></a>2.1 Scan</h2><h3 id=\"Seqscan\"><a href=\"#Seqscan\" class=\"headerlink\" title=\"Seqscan\"></a>Seqscan</h3><p>先从<code>Seqscan</code>开始说，<strong>Scan</strong>就是遍历整个<strong>table</strong>，没什么难度，利用Bustub给我们的<strong>Table Iterator</strong>可以轻松实现，这里主要看一下Bustub的数据结构</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/18/struct-2023-09-02-1711.png\"></p>\n<p>可以看到<strong>table info</strong>存在<strong>Catalog</strong>里，并且由<strong>table Heap</strong>保存整个表的<strong>first page id</strong>, 经由此才能拿到tuple</p>\n<p>获取<strong>table info</strong>后，将<code>table iterator</code>置为<strong>table heap</strong>的**begin()**，之后每次调用<code>Next()</code>函数，++iterator即可</p>\n<h3 id=\"IndexScan\"><a href=\"#IndexScan\" class=\"headerlink\" title=\"IndexScan\"></a>IndexScan</h3><p><code>IndexScan</code>也是类似的，和<code>SeqScan</code>的区别就在一个拿到的是<strong>table info</strong>，一个是<strong>index info</strong></p>\n<p>多提一下，这里的index就对应着P2中我们实现的<strong>B+ tree</strong>，用<strong>Index iterator</strong>的时候，用到的接口都是我们在P2中实现的，<code>!=</code>、解引用*、<code>++</code>等重载函数也是我们亲自实现的。整个创建索引的过程，我们已经深刻理解（备受折磨）了。</p>\n<h2 id=\"2-2-Write\"><a href=\"#2-2-Write\" class=\"headerlink\" title=\"2.2 Write\"></a>2.2 Write</h2><p><code>Insert</code>和<code>Delete</code>是为二的写算子了，在写的同时不仅要将值在表中写入&#x2F;删除，同时如果这个表有索引，还需要在其对应的索引中执行操作。最后要输出修改的元组数量。</p>\n<p>不断调用子算子的<code>Next()</code>函数获取要进行操作的元组，然后遍历表的所有索引组，依次将新的tuple及其索引插入索引即可，同时不要忘记记录修改的tuple数量</p>\n<p>tips：有一些会用到的接口函数比如<code>InsertTuple()</code>、<code>InsertEntry()</code>等等需要自己多看几遍代码，多读多记会有很大的帮助的，找不到也别着急，慢慢来（反正我急死了）</p>\n<h1 id=\"3-Task2\"><a href=\"#3-Task2\" class=\"headerlink\" title=\"3. Task2\"></a>3. Task2</h1><p>Task2要实现的算子相较Task1要复杂一些</p>\n<h2 id=\"3-1-Agg\"><a href=\"#3-1-Agg\" class=\"headerlink\" title=\"3.1 Agg\"></a>3.1 Agg</h2><p>聚合算子在实现的时候会有一个简化设计的假设，即聚合哈希表可以全部存入内存，不需要实现聚合的两阶段（分区、重哈希）。</p>\n<p>除此之外，还要注意区分*<em>count(</em>)<strong>和</strong>count(column)<strong>的区别，</strong>count(*)<strong>包含所有的列，相当于行数，统计结果的时候不会忽略NULL值，而</strong>count(column)**则会忽略NULL值</p>\n<p>聚合类型只有以下五种，没有要求实现<strong>avg</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">AggregationType</span> &#123; CountStarAggregate, CountAggregate, SumAggregate, MinAggregate, MaxAggregate &#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过头文件可以看到插入<strong>agghashtable</strong>需要<strong>agg_key</strong>和<strong>agg_value</strong>，这里的KV需要通过<code>MakeAggregateKey()</code>函数和<code>MakeAggregateValue()</code>函数将<strong>tuple</strong>转化为对应的<strong>agg_key</strong>和<strong>agg_value</strong>。这里的<strong>key</strong>是分组字段的排列组合，比如下面这条SQL:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> gender, grade;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<strong>key</strong>就是&lt;gender, grade&gt;的排列组合，比如性别分为man和woman，grade有ABCD四个等级，那么最后的key就有8组分别为&lt;man, A&gt; \\ &lt; man, B&gt; \\ &lt;man, C&gt; \\ &lt;man, D&gt; \\ &lt;woman, A&gt; \\ &lt;woman, B&gt; \\ &lt;woman, C&gt; \\ &lt;woman, D&gt;</p>\n<p><strong>value</strong>就是agg对应的列值，比如**sum()**就是将每次的值累加</p>\n<p>所以总的来说就是<strong>先分组，再聚集</strong></p>\n<p>头文件里给的<code>aht_</code>就是我们要在<code>Init()</code>函数中做的聚集哈希表初始化，先将表内信息按照<strong>key</strong>分好组别，再对各组的<strong>value</strong>进行聚集。</p>\n<p><code>Init()</code>函数里，将子算子吐出的<strong>tuple</strong>插入聚集哈希表中，再在<code>Next()</code>函数中完成聚集的操作。如果是个空表，那么count(<em>)返回0，其他聚集操作返回*<em>NULL</em></em></p>\n<h2 id=\"3-2-NLJ\"><a href=\"#3-2-NLJ\" class=\"headerlink\" title=\"3.2 NLJ\"></a>3.2 NLJ</h2><p>P3中只要实现NestedLoopJoin, 对HashJoin没有做要求（后面优化的时候还是要做一下），NestLoopJoin的逻辑非常简单，就是遍历两个表，如果配对成功就将其组合成的新tuple输出即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for outer_tuple in outer_table:</span><br><span class=\"line\">\tfor inner_tuple in inner_table:</span><br><span class=\"line\">\t\tif matched:</span><br><span class=\"line\">\t\t\temit</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是，为了使<strong>left_tuple</strong>和每个<strong>right_tuple</strong>进行比较，需要预先将<strong>right_tuple</strong>存至一个新的数组中，每次从左孩子中拉取一个tuple，与新数组进行比对，比对成功则组合并输出。这里有个很关键的问题，<strong>left_tuple</strong>与<strong>right_tuple</strong>的匹配可能存在多个，如果匹配成功后直接开始下一个<strong>left_tuple</strong>的match环节，那就会遗漏，所以可以设置一个cur，记录新数组中的index，如果没有到最后一个，那么<strong>left_tuple</strong>不用改变，继续与后面的<strong>right_tuple</strong>进行比对，直到遍历完新数组，再获取下一个<strong>left_tuple</strong>, 这样就不会有错过的匹配项了</p>\n<h2 id=\"3-3-NestedIndexJoin\"><a href=\"#3-3-NestedIndexJoin\" class=\"headerlink\" title=\"3.3 NestedIndexJoin\"></a>3.3 NestedIndexJoin</h2><p>同样是Join操作，当存在相等条件且恰好该条件在右侧表中存在索引，DBMS将会使用<code>NestedIndexJoinPlanNode</code></p>\n<p>具体操作于NLJ类似，区别在匹配时通过<code>Key_predicate</code>构造出<strong>probe key</strong>, 这里P3帮我们简化了一些要考虑的情况，不会存在重复行及奇怪的情况(P2也是这样，没有重复key)，所以如果有错误，对着测试用例改改即可</p>\n<p>！！不要忘记区分<strong>left_join</strong>和<strong>inner_join</strong></p>\n<h1 id=\"4-Task3\"><a href=\"#4-Task3\" class=\"headerlink\" title=\"4. Task3\"></a>4. Task3</h1><p>task3需要我们实现<strong>Sort、Limit</strong>算子和<strong>Top-N优化</strong></p>\n<h2 id=\"4-1-Sort\"><a href=\"#4-1-Sort\" class=\"headerlink\" title=\"4.1 Sort\"></a>4.1 Sort</h2><p>在没有index_key的情况下，<strong>order_by</strong>会采用<code>SortPlanNode</code>进行排序</p>\n<p>这里主要使用<code>std::sort</code>的标准库函数，自定义排序可以实用<strong>lambda表达式</strong>，对<strong>order_bys</strong>中获取的关键字进行比较，<code>compare</code>函数已经给好我们了(CompareLessThan和CompareGreaterThan)，我们只需要区分升降序即可，默认或者<strong>ASC</strong>即为升序，<strong>DESC</strong>则是降序，清楚之间的关系再进行实现就比较容易了</p>\n<p>关键内容如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">sort</span>(sorted_tuples.<span class=\"built_in\">begin</span>(), sorted_tuples.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> Tuple &amp;a, <span class=\"type\">const</span> Tuple &amp;b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> [type, expr] : plan_-&gt;<span class=\"built_in\">GetOrderBy</span>())&#123;\t\t\t<span class=\"comment\">//type为排序类型，expr用来比较两个tuple的前后顺序</span></span><br><span class=\"line\">        <span class=\"comment\">//比较</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-Limit\"><a href=\"#4-2-Limit\" class=\"headerlink\" title=\"4.2 Limit\"></a>4.2 Limit</h2><p>Limit限制查询生成的tuple数量，比Seqscan多一个count记录输出tuple数量，一旦达到限制数量即停止</p>\n<h2 id=\"4-3-Top-N-optimizer\"><a href=\"#4-3-Top-N-optimizer\" class=\"headerlink\" title=\"4.3 Top-N optimizer\"></a>4.3 Top-N optimizer</h2><p>到了最后一个任务，我们需要修改optimizer使Limit+sort的组合通过Top-N执行算子执行。</p>\n<p>默认的情况先将所有的tuple排序(sort excutor), 然后再取排序的结果前N个最小元素(limit excutor)，<code>TopNExcutor</code>要做的是在排序的过程中收集N个最小的元素，动态更新。</p>\n<p>这里与之前的任务有些不同，之前的任务仅需要修改对应的执行算子，这里还需要修改<code>src/optimizer/</code>目录下的<code>optimizer_custom_rules.cpp</code>目录中的各个优化函数，这里主要是<code>OptimizerSortLimitAsTopN()</code></p>\n<p>一上来无从下手可以先阅读其他优化规则，比如<code>OptimizerNLJAsIndexJoin()</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;AbstractPlanNodeRef&gt; children; </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;child : plan-&gt;<span class=\"built_in\">GetChildren</span>()) &#123;</span><br><span class=\"line\">   children.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">OptimizeNLJAsIndexJoin</span>(child));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> optimized_plan = plan-&gt;<span class=\"built_in\">CloneWithChildren</span>(std::<span class=\"built_in\">move</span>(children));</span><br></pre></td></tr></table></figure>\n\n<p>对plan进行后序遍历，如果执行算子满足特定条件则进行优化，比如这里的<code>NLJAsIndexJoin</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (optimizerd_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::NestedLoopJoin)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与<code>NLJAsIndexJoin</code>相比<code>SortLimitAsTopN</code>的逻辑就简单很多</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (optimizerd_plan-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Limit) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (optimizerd_plan-&gt;<span class=\"built_in\">GetChildAt</span>(<span class=\"number\">0</span>)-&gt;<span class=\"built_in\">GetType</span>() == PlanType::Sort) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自底向上遍历各个算子，如果该算子执行<strong>Limit</strong>操作，且其下层执行<strong>Sort</strong>操作，则可以将两个节点替换为<strong>TopN</strong>算子</p>\n<p>实现可以使用优先队列(std::priority_queue)，主要是要设计好自定义比较器，之前一直用的默认比较类型，这里学习了一下对自定义类的比较器做法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::priority_queue&lt;Tuple, std::vector&lt;Tuple&gt;, <span class=\"keyword\">decltype</span>(cmp)&gt; <span class=\"built_in\">pq</span>(cmp); <span class=\"comment\">//cmp 为自定义比较函数</span></span><br></pre></td></tr></table></figure>\n\n<p>至此，P3所有的必做项目都已完成</p>\n<h1 id=\"Leaderboard\"><a href=\"#Leaderboard\" class=\"headerlink\" title=\"Leaderboard\"></a>Leaderboard</h1><p>Leaderboard部分我没有很仔细的去做，网上也看到了很多大佬提供的各种方案，打算等有时间再进行仔细研究、尝试，这里我只实现了<strong>HashJoin</strong>，对<strong>Query1</strong>有一定的优化，<strong>Q2</strong>和<strong>Q3</strong>的优化就放到以后了-。-</p>\n<p><code>HashJoin</code>主要对Join操作进行的优化，在<code>optimizer_custom_rules.cpp</code>中将注释的那行取消注释即为开启<code>NLJAsHash</code>优化，进去看一下可以看到，该优化器会将类型为<code>NestLoopJoin</code>且比较类型为<strong>Equal</strong>的操作，优化为<strong>HashJoin</strong>，我们实现<strong>HashJoin Excutor</strong>即可</p>\n<p>HashJoin主要分为两个阶段：</p>\n<ul>\n<li>Build阶段</li>\n</ul>\n<p>​\t\t将右表数据存入哈希表</p>\n<ul>\n<li>Probe阶段</li>\n</ul>\n<p>​\t\t扫描左表，在哈希表中查找，存在对应值则匹配</p>\n<p>在<code>Init()</code>阶段遍历右表，其tuple调用<code>HashValue()</code>后存入哈希表，再遍历左表，将其与哈希表中tuple进行匹配，leadborad测试样例只要求了<strong>inner join</strong>，但是其他测试样例需要我们区分<strong>inner join</strong>和<strong>left join</strong>，在打开<code>NLJAsHash</code>优化策略后，其他的Join操作也会被优化为<strong>HashJoin</strong>，所以要考虑到<strong>left join</strong>，和之前的要求相似，这里就不再赘述。最后将匹配上的<strong>new tuple</strong>放入临时的数组，Init就完成了</p>\n<p><code>Next()</code>函数就如之前一样，不断emit tuple即可。</p>\n<h1 id=\"Debug-Sum-Up\"><a href=\"#Debug-Sum-Up\" class=\"headerlink\" title=\"Debug &amp;&amp; Sum Up\"></a>Debug &amp;&amp; Sum Up</h1><p>这里debug可以用GDB</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdb ./bin/bustub-sqllogictest\t\t\t\t\t\t//gdb</span><br><span class=\"line\">set args ../test/sql/p3.01-seqscan.slt --verbose\t//设置参数</span><br><span class=\"line\">b seq_scan_excutor.cpp \t\t\t\t\t\t\t\t//断点</span><br></pre></td></tr></table></figure>\n\n<p>也可以<code>make shell</code></p>\n<p>直接用IDEA(我用的vscode)在对应执行器中打断点，再输入出错的SQL语句，以定位错误</p>\n<p>至此，P3结束，开始P4篇章!</p>\n"},{"title":"CMU15445 P4","date":"2023-10-12T11:50:00.000Z","description":"并发控制","cover":"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/445pic1.jpg","top_img":"rgba(0,0,0,0)","_content":"# Preview\n\n二阶段锁：\n\n- Growing\n\n​\t\t该阶段只能加锁，不能解锁\n\n- Shrinking\n\n​\t\t该阶段只能解锁，不能加锁\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/2pl.png)\n\n### 隔离级别\n\n四种隔离等级\n\n- **READ_UNCOMMITED 读未提交** \n\n​\t\t为了避免脏写，加X锁，读不加锁，每次读最新数据记录。 **（存在脏读问题）**\n\n​\t\t在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。\n\n- **READ_COMMITED 读提交**\n\n​\t\t加S锁，每次读完立即释放。 **（strict-2PL）**\n\n​\t\t若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。\n\n- **REPEATABLE_READ 可重复读**\n\n​\t\t加S锁，在事务提交/中止时由TransactionManager统一释放 **（rigorous-2PL）**\n\n​\t\t重复读可以解决不可重复读问题。不可重复读对应的是修改，**即UPDATE操作**。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。\n\n- **SERIALIZABLE 串行化**\n\n| 隔离级别 |  脏读  | 不可重复读 |  幻读  |\n| :------: | :----: | :--------: | :----: |\n| 读未提交 |  可能  |    可能    |  可能  |\n|  读提交  | 不可能 |    可能    |  可能  |\n| 可重复读 | 不可能 |   不可能   |  可能  |\n|  串行化  | 不可能 |   不可能   | 不可能 |\n\n**问题：**\n\n- 脏读\n\n​\t\t指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作可能是不正确的。\n\n- 不可重复读\n\n​\t\t指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。\n\n- 幻读\n\n​\t\t一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）\n\n不同数据库处理隔离等级内容不相同\n\n# Task1\n\n## LockTable()\n\n整个``LockTable()``流程图如下所示：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/locktable.png)\n\n仔细阅读``lockmanager.h``中的提示**[LOCK_NOTE]**,可以确定三种隔离等级需要满足的条件，如果不满足则要置**TransactionState**为**abort**状态\n\n### 查找加锁页面\n\n接下来就要对锁表进行操作了，在操作锁表之前要先将整个哈希表上锁，在拿到该txn需要操作的table后再释放锁，过程像P2的螃蟹锁一样，先锁table，再释放哈希表锁\n\n确定了需要操作的**table**后，下一步就是拿到该**table**的**request_queue**，**request_queue**里存的是该**table**所被请求的锁队列，总的数据结构如下\n\n```mermaid\nclassDiagram\n\tLockManager --|> hash_table\n\thash_table --|> LockRequestQueue\n\tLockRequestQueue --|> LockRequest\n\tclass LockManager {\n\t\t- 哈希表[表/行]\n\t\t- 互斥锁[表/行]\n\t}\n\tclass hash_table {\n\t\t- LockRequestQueue\n\t}\n\tclass LockRequestQueue {\n\t\t+ request_queue [LockRequest]\n\t\t+ cv\n\t\t+ upgrading\n\t\t+ latch\n\t}\n\tclass LockRequest {\n\t\t+ tid\n\t\t+ oid\n\t\t+ rid\n\t\t+ lock_mode\t\t\n\t\t+ granted\n\t}\n```\n\n**request_queue**为一个队列，存放着加在该表（行）的锁请求，其中**tid**为事务id，**oid**为表id，**rid**为行id（在表锁中不需要）,**lock_mode**为要加锁的模式，**granted**为布尔变量，标志着该锁是否被授予\n\n如果需要加锁的页面没有**request**则新建**request**请求，至此，查找加锁页面结束\n\n### 判断新旧事务\n\n拿到该**table**的**request_queue**后，遍历整个队列\n\n- 如果**request**中没有改事务存在（该事务为新事务），则直接将该请求放到队尾，通过条件变量模型等待锁授权\n\n- 如果**request**中已经有该事务存在，则进行**锁升级**的判断：\n\n如果原锁模式与该锁模式相同，则不需要加锁，因为已经有这把锁了，**直接return true**\n\n如果原锁模式与该锁模式不同，则需要先判断是否已经有锁在升级，**LockRequestQueue**中**upgrading**标记着请求队列中正在升级的事务id，若无锁升级，则**upgrading**的值为**INVALID**，存在其他正在升级的锁时，该事务置为**ABORT**；无其他正在升级的锁时，判断当前锁模式是否满足升级条件，锁升级条件在**[LOCK_NOTE]**中可以看到\n\n```\n   *        IS -> [S, X, IX, SIX]\n   *        S -> [X, SIX]\n   *        IX -> [X, SIX]\n   *        SIX -> [X]\n```\n\n若满足升级条件，则对该锁进行升级：\n\n升级需要先将原锁请求从队列中删除，再创建一个新加锁请求，让新加锁请求成为第一个未授权锁（升级锁拥有高权限），方法是遍历整个**request_queue**，找到第一个**granted 为 false**的位置，将新请求插入该位置即可，最后要更新**upgrading**，标记为正在升级状态,防止多个锁同时进行升级\n\n升级完成后，通过条件变量模型等待锁授权\n\n### *条件变量\n\n条件变量并不是某一个特定语言中的概念，而是操作系统中线程同步的一种机制。条件变量经典的使用形式：\n\n```c++\nstd::unique_lock<std::mutex> lock(latch);\nwhile (!resource) {\n    cv.wait(lock);\n}\n```\n\n条件变量与互斥锁配合使用。首先需要持有锁，并查看是否能够获取资源。这个锁与资源绑定，是用来保护资源的锁。若暂时无法获取资源，则调用条件变量的 wait 函数。调用 wait 函数后，latch 将自动**释放**，并且当前线程被挂起，以节省资源。这就是阻塞的过程。此外，允许有多个线程在 wait 同一个 latch。\n\n当其他线程的活动使得资源状态发生改变时，需要调用条件遍历的 `notify_all()` 函数。\n\n```c++\ncv.notify_all();\n```\n\n`notify_all()` 可以看作一次广播，会唤醒所有正在此条件变量上阻塞的线程。在线程被唤醒后，其仍处于 wait 函数中。在 wait 函数中尝试获取 latch。在成功获取 latch 后，退出 wait 函数，进入循环的判断条件，检查是否能获取资源。若仍不能获取资源，就继续进入 wait 阻塞，释放锁，挂起线程。若能获取资源，则退出循环。这样就实现了阻塞等待资源的模型。条件变量中的条件指的就是满足某个条件，在这里即能够获取资源。\n\n理解条件变量的作用后，就可以写出如下代码：\n\n```c++\nstd::unique_lock<std::mutex> lock(queue->latch_);\nwhile (!GrantLock(...)) {\n    queue->cv_.wait(lock);\n}\n```\n\n``GrantLock()``函数中，会判断出事务是否可以成功获取锁，授予锁的条件为：\n\n1. 前面事务都兼容\n2. 遵循FIFO，只有当前事务未第一个未授予的锁\n\n## UnlockTable()\n\n怎么加的锁就怎么去解锁，流程如下：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/Unlocktable.png)\n\n\n\n## LockRow()\n\n与``LockTable()``基本相同\n\n- 不支持意向锁（只允许S/X锁）\n- 加锁时需要判断表的锁状态\n- 其他流程类似\n\n## UnLockRow()\n\n与``UnLockTable()``相同\n\n# Task2\n\n后台线程，中止阻塞的事务\n\n要求我们动态构建有向图，不需要长久维护一个图，可以从题目中给到的API入手\n\n``AddEdge()``、``RemoveEdge()``、``GetEdgeList()``都是比较简单的增边删边操作，用来构建有向图，**点代表事务**ID，**边代表依赖关系**，指向被依赖的事务\n\n重要逻辑在``HasCycle()``、``RunCycleDetection()``中\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/deadlock.png)\n\n## 建图\n\n``T1->T2``代表T1正在等待T2释放资源，哈希表**waits_for_**代表着该事务所等待释放资源的事务合集，根据Lab要求，我们遍历所有页和行的请求队列，**已经被授予的锁作为箭头所指向的点**，waiting中的事务将作为出发点建边。\n\n## 判环\n\n构建完图之后，我们选择DFS进行环检测，要求保证搜索的确定性（不理解），应该就是遍历的顺序要从tid小的事务开始搜索，选择其邻居的过程也要优先最小的tid，若存在环，则挑选合适（youngest，即TID最大）的事务进行中止\n\n中止之后，需要在请求队列中移除事务，释放该事务所持有的所有锁，并通知正在阻塞的相关事务。不要忘记修改**waits_for_**，因为有可能存在多个环，需要在死锁检测线程结束时打破所有环。\n\n难度不大，主要内容在DFS中\n\n# Task3\n\n将P3实现的执行算子中``SeqScan``、``Insert``、``Delete``三个算子实现可并发操作\n\n其中``SeqScan``代表读，``Insert``、``Delete``则代表写\n\n## 读\n\n**SeqScan**在表中加IS锁，在行中加S锁，表锁可以在``Init()``函数中实现，行锁的加锁和释放则在对应读取数据时进行即可\n\n## 写\n\n与**SeqScan**类似，IX锁在``Init()``函数中实现，行锁在``Next()``中实现，要注意的是**Insert**和**Delete**的加锁顺序不同，**Insert**是插入完成再加锁，**Delete**则是先加锁，再进行删除操作，两个写算子都不需要释放锁，锁会在COMMIT的时候进行释放\n\n# Leaderboard Task\n\n看都没看，最近太忙，有空再来挑战一下！\n","source":"_posts/CMU15445 P4.md","raw":"---\ntitle: CMU15445 P4\ncategories: CMU15445\ntags: \n    - CMU15445\n    - Database\n    - Concurrency Control\ndate: 2023-10-12 19:50:00\ndescription: 并发控制\ncover: https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/08/20/445pic1.jpg\ntop_img: rgba(0,0,0,0)\n---\n# Preview\n\n二阶段锁：\n\n- Growing\n\n​\t\t该阶段只能加锁，不能解锁\n\n- Shrinking\n\n​\t\t该阶段只能解锁，不能加锁\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/2pl.png)\n\n### 隔离级别\n\n四种隔离等级\n\n- **READ_UNCOMMITED 读未提交** \n\n​\t\t为了避免脏写，加X锁，读不加锁，每次读最新数据记录。 **（存在脏读问题）**\n\n​\t\t在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。\n\n- **READ_COMMITED 读提交**\n\n​\t\t加S锁，每次读完立即释放。 **（strict-2PL）**\n\n​\t\t若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。\n\n- **REPEATABLE_READ 可重复读**\n\n​\t\t加S锁，在事务提交/中止时由TransactionManager统一释放 **（rigorous-2PL）**\n\n​\t\t重复读可以解决不可重复读问题。不可重复读对应的是修改，**即UPDATE操作**。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。\n\n- **SERIALIZABLE 串行化**\n\n| 隔离级别 |  脏读  | 不可重复读 |  幻读  |\n| :------: | :----: | :--------: | :----: |\n| 读未提交 |  可能  |    可能    |  可能  |\n|  读提交  | 不可能 |    可能    |  可能  |\n| 可重复读 | 不可能 |   不可能   |  可能  |\n|  串行化  | 不可能 |   不可能   | 不可能 |\n\n**问题：**\n\n- 脏读\n\n​\t\t指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作可能是不正确的。\n\n- 不可重复读\n\n​\t\t指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。\n\n- 幻读\n\n​\t\t一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）\n\n不同数据库处理隔离等级内容不相同\n\n# Task1\n\n## LockTable()\n\n整个``LockTable()``流程图如下所示：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/locktable.png)\n\n仔细阅读``lockmanager.h``中的提示**[LOCK_NOTE]**,可以确定三种隔离等级需要满足的条件，如果不满足则要置**TransactionState**为**abort**状态\n\n### 查找加锁页面\n\n接下来就要对锁表进行操作了，在操作锁表之前要先将整个哈希表上锁，在拿到该txn需要操作的table后再释放锁，过程像P2的螃蟹锁一样，先锁table，再释放哈希表锁\n\n确定了需要操作的**table**后，下一步就是拿到该**table**的**request_queue**，**request_queue**里存的是该**table**所被请求的锁队列，总的数据结构如下\n\n```mermaid\nclassDiagram\n\tLockManager --|> hash_table\n\thash_table --|> LockRequestQueue\n\tLockRequestQueue --|> LockRequest\n\tclass LockManager {\n\t\t- 哈希表[表/行]\n\t\t- 互斥锁[表/行]\n\t}\n\tclass hash_table {\n\t\t- LockRequestQueue\n\t}\n\tclass LockRequestQueue {\n\t\t+ request_queue [LockRequest]\n\t\t+ cv\n\t\t+ upgrading\n\t\t+ latch\n\t}\n\tclass LockRequest {\n\t\t+ tid\n\t\t+ oid\n\t\t+ rid\n\t\t+ lock_mode\t\t\n\t\t+ granted\n\t}\n```\n\n**request_queue**为一个队列，存放着加在该表（行）的锁请求，其中**tid**为事务id，**oid**为表id，**rid**为行id（在表锁中不需要）,**lock_mode**为要加锁的模式，**granted**为布尔变量，标志着该锁是否被授予\n\n如果需要加锁的页面没有**request**则新建**request**请求，至此，查找加锁页面结束\n\n### 判断新旧事务\n\n拿到该**table**的**request_queue**后，遍历整个队列\n\n- 如果**request**中没有改事务存在（该事务为新事务），则直接将该请求放到队尾，通过条件变量模型等待锁授权\n\n- 如果**request**中已经有该事务存在，则进行**锁升级**的判断：\n\n如果原锁模式与该锁模式相同，则不需要加锁，因为已经有这把锁了，**直接return true**\n\n如果原锁模式与该锁模式不同，则需要先判断是否已经有锁在升级，**LockRequestQueue**中**upgrading**标记着请求队列中正在升级的事务id，若无锁升级，则**upgrading**的值为**INVALID**，存在其他正在升级的锁时，该事务置为**ABORT**；无其他正在升级的锁时，判断当前锁模式是否满足升级条件，锁升级条件在**[LOCK_NOTE]**中可以看到\n\n```\n   *        IS -> [S, X, IX, SIX]\n   *        S -> [X, SIX]\n   *        IX -> [X, SIX]\n   *        SIX -> [X]\n```\n\n若满足升级条件，则对该锁进行升级：\n\n升级需要先将原锁请求从队列中删除，再创建一个新加锁请求，让新加锁请求成为第一个未授权锁（升级锁拥有高权限），方法是遍历整个**request_queue**，找到第一个**granted 为 false**的位置，将新请求插入该位置即可，最后要更新**upgrading**，标记为正在升级状态,防止多个锁同时进行升级\n\n升级完成后，通过条件变量模型等待锁授权\n\n### *条件变量\n\n条件变量并不是某一个特定语言中的概念，而是操作系统中线程同步的一种机制。条件变量经典的使用形式：\n\n```c++\nstd::unique_lock<std::mutex> lock(latch);\nwhile (!resource) {\n    cv.wait(lock);\n}\n```\n\n条件变量与互斥锁配合使用。首先需要持有锁，并查看是否能够获取资源。这个锁与资源绑定，是用来保护资源的锁。若暂时无法获取资源，则调用条件变量的 wait 函数。调用 wait 函数后，latch 将自动**释放**，并且当前线程被挂起，以节省资源。这就是阻塞的过程。此外，允许有多个线程在 wait 同一个 latch。\n\n当其他线程的活动使得资源状态发生改变时，需要调用条件遍历的 `notify_all()` 函数。\n\n```c++\ncv.notify_all();\n```\n\n`notify_all()` 可以看作一次广播，会唤醒所有正在此条件变量上阻塞的线程。在线程被唤醒后，其仍处于 wait 函数中。在 wait 函数中尝试获取 latch。在成功获取 latch 后，退出 wait 函数，进入循环的判断条件，检查是否能获取资源。若仍不能获取资源，就继续进入 wait 阻塞，释放锁，挂起线程。若能获取资源，则退出循环。这样就实现了阻塞等待资源的模型。条件变量中的条件指的就是满足某个条件，在这里即能够获取资源。\n\n理解条件变量的作用后，就可以写出如下代码：\n\n```c++\nstd::unique_lock<std::mutex> lock(queue->latch_);\nwhile (!GrantLock(...)) {\n    queue->cv_.wait(lock);\n}\n```\n\n``GrantLock()``函数中，会判断出事务是否可以成功获取锁，授予锁的条件为：\n\n1. 前面事务都兼容\n2. 遵循FIFO，只有当前事务未第一个未授予的锁\n\n## UnlockTable()\n\n怎么加的锁就怎么去解锁，流程如下：\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/Unlocktable.png)\n\n\n\n## LockRow()\n\n与``LockTable()``基本相同\n\n- 不支持意向锁（只允许S/X锁）\n- 加锁时需要判断表的锁状态\n- 其他流程类似\n\n## UnLockRow()\n\n与``UnLockTable()``相同\n\n# Task2\n\n后台线程，中止阻塞的事务\n\n要求我们动态构建有向图，不需要长久维护一个图，可以从题目中给到的API入手\n\n``AddEdge()``、``RemoveEdge()``、``GetEdgeList()``都是比较简单的增边删边操作，用来构建有向图，**点代表事务**ID，**边代表依赖关系**，指向被依赖的事务\n\n重要逻辑在``HasCycle()``、``RunCycleDetection()``中\n\n![](https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/deadlock.png)\n\n## 建图\n\n``T1->T2``代表T1正在等待T2释放资源，哈希表**waits_for_**代表着该事务所等待释放资源的事务合集，根据Lab要求，我们遍历所有页和行的请求队列，**已经被授予的锁作为箭头所指向的点**，waiting中的事务将作为出发点建边。\n\n## 判环\n\n构建完图之后，我们选择DFS进行环检测，要求保证搜索的确定性（不理解），应该就是遍历的顺序要从tid小的事务开始搜索，选择其邻居的过程也要优先最小的tid，若存在环，则挑选合适（youngest，即TID最大）的事务进行中止\n\n中止之后，需要在请求队列中移除事务，释放该事务所持有的所有锁，并通知正在阻塞的相关事务。不要忘记修改**waits_for_**，因为有可能存在多个环，需要在死锁检测线程结束时打破所有环。\n\n难度不大，主要内容在DFS中\n\n# Task3\n\n将P3实现的执行算子中``SeqScan``、``Insert``、``Delete``三个算子实现可并发操作\n\n其中``SeqScan``代表读，``Insert``、``Delete``则代表写\n\n## 读\n\n**SeqScan**在表中加IS锁，在行中加S锁，表锁可以在``Init()``函数中实现，行锁的加锁和释放则在对应读取数据时进行即可\n\n## 写\n\n与**SeqScan**类似，IX锁在``Init()``函数中实现，行锁在``Next()``中实现，要注意的是**Insert**和**Delete**的加锁顺序不同，**Insert**是插入完成再加锁，**Delete**则是先加锁，再进行删除操作，两个写算子都不需要释放锁，锁会在COMMIT的时候进行释放\n\n# Leaderboard Task\n\n看都没看，最近太忙，有空再来挑战一下！\n","slug":"CMU15445 P4","published":1,"updated":"2023-10-31T05:40:34.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloh9mybb0001dlji7n4ihp9j","content":"<h1 id=\"Preview\"><a href=\"#Preview\" class=\"headerlink\" title=\"Preview\"></a>Preview</h1><p>二阶段锁：</p>\n<ul>\n<li>Growing</li>\n</ul>\n<p>​\t\t该阶段只能加锁，不能解锁</p>\n<ul>\n<li>Shrinking</li>\n</ul>\n<p>​\t\t该阶段只能解锁，不能加锁</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/2pl.png\"></p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><p>四种隔离等级</p>\n<ul>\n<li><strong>READ_UNCOMMITED 读未提交</strong></li>\n</ul>\n<p>​\t\t为了避免脏写，加X锁，读不加锁，每次读最新数据记录。 <strong>（存在脏读问题）</strong></p>\n<p>​\t\t在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。</p>\n<ul>\n<li><strong>READ_COMMITED 读提交</strong></li>\n</ul>\n<p>​\t\t加S锁，每次读完立即释放。 <strong>（strict-2PL）</strong></p>\n<p>​\t\t若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p>\n<ul>\n<li><strong>REPEATABLE_READ 可重复读</strong></li>\n</ul>\n<p>​\t\t加S锁，在事务提交&#x2F;中止时由TransactionManager统一释放 <strong>（rigorous-2PL）</strong></p>\n<p>​\t\t重复读可以解决不可重复读问题。不可重复读对应的是修改，<strong>即UPDATE操作</strong>。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</p>\n<ul>\n<li><strong>SERIALIZABLE 串行化</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">读未提交</td>\n<td align=\"center\">可能</td>\n<td align=\"center\">可能</td>\n<td align=\"center\">可能</td>\n</tr>\n<tr>\n<td align=\"center\">读提交</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">可能</td>\n<td align=\"center\">可能</td>\n</tr>\n<tr>\n<td align=\"center\">可重复读</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">可能</td>\n</tr>\n<tr>\n<td align=\"center\">串行化</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">不可能</td>\n</tr>\n</tbody></table>\n<p><strong>问题：</strong></p>\n<ul>\n<li>脏读</li>\n</ul>\n<p>​\t\t指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作可能是不正确的。</p>\n<ul>\n<li>不可重复读</li>\n</ul>\n<p>​\t\t指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</p>\n<ul>\n<li>幻读</li>\n</ul>\n<p>​\t\t一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</p>\n<p>不同数据库处理隔离等级内容不相同</p>\n<h1 id=\"Task1\"><a href=\"#Task1\" class=\"headerlink\" title=\"Task1\"></a>Task1</h1><h2 id=\"LockTable\"><a href=\"#LockTable\" class=\"headerlink\" title=\"LockTable()\"></a>LockTable()</h2><p>整个<code>LockTable()</code>流程图如下所示：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/locktable.png\"></p>\n<p>仔细阅读<code>lockmanager.h</code>中的提示**[LOCK_NOTE]<strong>,可以确定三种隔离等级需要满足的条件，如果不满足则要置</strong>TransactionState<strong>为</strong>abort**状态</p>\n<h3 id=\"查找加锁页面\"><a href=\"#查找加锁页面\" class=\"headerlink\" title=\"查找加锁页面\"></a>查找加锁页面</h3><p>接下来就要对锁表进行操作了，在操作锁表之前要先将整个哈希表上锁，在拿到该txn需要操作的table后再释放锁，过程像P2的螃蟹锁一样，先锁table，再释放哈希表锁</p>\n<p>确定了需要操作的<strong>table</strong>后，下一步就是拿到该<strong>table</strong>的<strong>request_queue</strong>，<strong>request_queue</strong>里存的是该<strong>table</strong>所被请求的锁队列，总的数据结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">\tLockManager --|&gt; hash_table</span><br><span class=\"line\">\thash_table --|&gt; LockRequestQueue</span><br><span class=\"line\">\tLockRequestQueue --|&gt; LockRequest</span><br><span class=\"line\">\tclass LockManager &#123;</span><br><span class=\"line\">\t\t- 哈希表[表/行]</span><br><span class=\"line\">\t\t- 互斥锁[表/行]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclass hash_table &#123;</span><br><span class=\"line\">\t\t- LockRequestQueue</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclass LockRequestQueue &#123;</span><br><span class=\"line\">\t\t+ request_queue [LockRequest]</span><br><span class=\"line\">\t\t+ cv</span><br><span class=\"line\">\t\t+ upgrading</span><br><span class=\"line\">\t\t+ latch</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclass LockRequest &#123;</span><br><span class=\"line\">\t\t+ tid</span><br><span class=\"line\">\t\t+ oid</span><br><span class=\"line\">\t\t+ rid</span><br><span class=\"line\">\t\t+ lock_mode\t\t</span><br><span class=\"line\">\t\t+ granted</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>request_queue</strong>为一个队列，存放着加在该表（行）的锁请求，其中<strong>tid</strong>为事务id，<strong>oid</strong>为表id，<strong>rid</strong>为行id（在表锁中不需要）,<strong>lock_mode</strong>为要加锁的模式，<strong>granted</strong>为布尔变量，标志着该锁是否被授予</p>\n<p>如果需要加锁的页面没有<strong>request</strong>则新建<strong>request</strong>请求，至此，查找加锁页面结束</p>\n<h3 id=\"判断新旧事务\"><a href=\"#判断新旧事务\" class=\"headerlink\" title=\"判断新旧事务\"></a>判断新旧事务</h3><p>拿到该<strong>table</strong>的<strong>request_queue</strong>后，遍历整个队列</p>\n<ul>\n<li><p>如果<strong>request</strong>中没有改事务存在（该事务为新事务），则直接将该请求放到队尾，通过条件变量模型等待锁授权</p>\n</li>\n<li><p>如果<strong>request</strong>中已经有该事务存在，则进行<strong>锁升级</strong>的判断：</p>\n</li>\n</ul>\n<p>如果原锁模式与该锁模式相同，则不需要加锁，因为已经有这把锁了，<strong>直接return true</strong></p>\n<p>如果原锁模式与该锁模式不同，则需要先判断是否已经有锁在升级，<strong>LockRequestQueue</strong>中<strong>upgrading</strong>标记着请求队列中正在升级的事务id，若无锁升级，则<strong>upgrading</strong>的值为<strong>INVALID</strong>，存在其他正在升级的锁时，该事务置为<strong>ABORT</strong>；无其他正在升级的锁时，判断当前锁模式是否满足升级条件，锁升级条件在**[LOCK_NOTE]**中可以看到</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*        IS -&gt; [S, X, IX, SIX]</span><br><span class=\"line\">*        S -&gt; [X, SIX]</span><br><span class=\"line\">*        IX -&gt; [X, SIX]</span><br><span class=\"line\">*        SIX -&gt; [X]</span><br></pre></td></tr></table></figure>\n\n<p>若满足升级条件，则对该锁进行升级：</p>\n<p>升级需要先将原锁请求从队列中删除，再创建一个新加锁请求，让新加锁请求成为第一个未授权锁（升级锁拥有高权限），方法是遍历整个<strong>request_queue</strong>，找到第一个<strong>granted 为 false</strong>的位置，将新请求插入该位置即可，最后要更新<strong>upgrading</strong>，标记为正在升级状态,防止多个锁同时进行升级</p>\n<p>升级完成后，通过条件变量模型等待锁授权</p>\n<h3 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"*条件变量\"></a>*条件变量</h3><p>条件变量并不是某一个特定语言中的概念，而是操作系统中线程同步的一种机制。条件变量经典的使用形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(latch)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!resource) &#123;</span><br><span class=\"line\">    cv.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>条件变量与互斥锁配合使用。首先需要持有锁，并查看是否能够获取资源。这个锁与资源绑定，是用来保护资源的锁。若暂时无法获取资源，则调用条件变量的 wait 函数。调用 wait 函数后，latch 将自动<strong>释放</strong>，并且当前线程被挂起，以节省资源。这就是阻塞的过程。此外，允许有多个线程在 wait 同一个 latch。</p>\n<p>当其他线程的活动使得资源状态发生改变时，需要调用条件遍历的 <code>notify_all()</code> 函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.<span class=\"built_in\">notify_all</span>();</span><br></pre></td></tr></table></figure>\n\n<p><code>notify_all()</code> 可以看作一次广播，会唤醒所有正在此条件变量上阻塞的线程。在线程被唤醒后，其仍处于 wait 函数中。在 wait 函数中尝试获取 latch。在成功获取 latch 后，退出 wait 函数，进入循环的判断条件，检查是否能获取资源。若仍不能获取资源，就继续进入 wait 阻塞，释放锁，挂起线程。若能获取资源，则退出循环。这样就实现了阻塞等待资源的模型。条件变量中的条件指的就是满足某个条件，在这里即能够获取资源。</p>\n<p>理解条件变量的作用后，就可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(queue-&gt;latch_)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!<span class=\"built_in\">GrantLock</span>(...)) &#123;</span><br><span class=\"line\">    queue-&gt;cv_.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>GrantLock()</code>函数中，会判断出事务是否可以成功获取锁，授予锁的条件为：</p>\n<ol>\n<li>前面事务都兼容</li>\n<li>遵循FIFO，只有当前事务未第一个未授予的锁</li>\n</ol>\n<h2 id=\"UnlockTable\"><a href=\"#UnlockTable\" class=\"headerlink\" title=\"UnlockTable()\"></a>UnlockTable()</h2><p>怎么加的锁就怎么去解锁，流程如下：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/Unlocktable.png\"></p>\n<h2 id=\"LockRow\"><a href=\"#LockRow\" class=\"headerlink\" title=\"LockRow()\"></a>LockRow()</h2><p>与<code>LockTable()</code>基本相同</p>\n<ul>\n<li>不支持意向锁（只允许S&#x2F;X锁）</li>\n<li>加锁时需要判断表的锁状态</li>\n<li>其他流程类似</li>\n</ul>\n<h2 id=\"UnLockRow\"><a href=\"#UnLockRow\" class=\"headerlink\" title=\"UnLockRow()\"></a>UnLockRow()</h2><p>与<code>UnLockTable()</code>相同</p>\n<h1 id=\"Task2\"><a href=\"#Task2\" class=\"headerlink\" title=\"Task2\"></a>Task2</h1><p>后台线程，中止阻塞的事务</p>\n<p>要求我们动态构建有向图，不需要长久维护一个图，可以从题目中给到的API入手</p>\n<p><code>AddEdge()</code>、<code>RemoveEdge()</code>、<code>GetEdgeList()</code>都是比较简单的增边删边操作，用来构建有向图，<strong>点代表事务</strong>ID，<strong>边代表依赖关系</strong>，指向被依赖的事务</p>\n<p>重要逻辑在<code>HasCycle()</code>、<code>RunCycleDetection()</code>中</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/deadlock.png\"></p>\n<h2 id=\"建图\"><a href=\"#建图\" class=\"headerlink\" title=\"建图\"></a>建图</h2><p><code>T1-&gt;T2</code>代表T1正在等待T2释放资源，哈希表<strong>waits_for_<strong>代表着该事务所等待释放资源的事务合集，根据Lab要求，我们遍历所有页和行的请求队列，</strong>已经被授予的锁作为箭头所指向的点</strong>，waiting中的事务将作为出发点建边。</p>\n<h2 id=\"判环\"><a href=\"#判环\" class=\"headerlink\" title=\"判环\"></a>判环</h2><p>构建完图之后，我们选择DFS进行环检测，要求保证搜索的确定性（不理解），应该就是遍历的顺序要从tid小的事务开始搜索，选择其邻居的过程也要优先最小的tid，若存在环，则挑选合适（youngest，即TID最大）的事务进行中止</p>\n<p>中止之后，需要在请求队列中移除事务，释放该事务所持有的所有锁，并通知正在阻塞的相关事务。不要忘记修改**waits_for_**，因为有可能存在多个环，需要在死锁检测线程结束时打破所有环。</p>\n<p>难度不大，主要内容在DFS中</p>\n<h1 id=\"Task3\"><a href=\"#Task3\" class=\"headerlink\" title=\"Task3\"></a>Task3</h1><p>将P3实现的执行算子中<code>SeqScan</code>、<code>Insert</code>、<code>Delete</code>三个算子实现可并发操作</p>\n<p>其中<code>SeqScan</code>代表读，<code>Insert</code>、<code>Delete</code>则代表写</p>\n<h2 id=\"读\"><a href=\"#读\" class=\"headerlink\" title=\"读\"></a>读</h2><p><strong>SeqScan</strong>在表中加IS锁，在行中加S锁，表锁可以在<code>Init()</code>函数中实现，行锁的加锁和释放则在对应读取数据时进行即可</p>\n<h2 id=\"写\"><a href=\"#写\" class=\"headerlink\" title=\"写\"></a>写</h2><p>与<strong>SeqScan</strong>类似，IX锁在<code>Init()</code>函数中实现，行锁在<code>Next()</code>中实现，要注意的是<strong>Insert</strong>和<strong>Delete</strong>的加锁顺序不同，<strong>Insert</strong>是插入完成再加锁，<strong>Delete</strong>则是先加锁，再进行删除操作，两个写算子都不需要释放锁，锁会在COMMIT的时候进行释放</p>\n<h1 id=\"Leaderboard-Task\"><a href=\"#Leaderboard-Task\" class=\"headerlink\" title=\"Leaderboard Task\"></a>Leaderboard Task</h1><p>看都没看，最近太忙，有空再来挑战一下！</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"butterfly配置文档","link_list":[{"name":"Butterfly","link":"https://butterfly.js.org/"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"Preview\"><a href=\"#Preview\" class=\"headerlink\" title=\"Preview\"></a>Preview</h1><p>二阶段锁：</p>\n<ul>\n<li>Growing</li>\n</ul>\n<p>​\t\t该阶段只能加锁，不能解锁</p>\n<ul>\n<li>Shrinking</li>\n</ul>\n<p>​\t\t该阶段只能解锁，不能加锁</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/2pl.png\"></p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><p>四种隔离等级</p>\n<ul>\n<li><strong>READ_UNCOMMITED 读未提交</strong></li>\n</ul>\n<p>​\t\t为了避免脏写，加X锁，读不加锁，每次读最新数据记录。 <strong>（存在脏读问题）</strong></p>\n<p>​\t\t在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。</p>\n<ul>\n<li><strong>READ_COMMITED 读提交</strong></li>\n</ul>\n<p>​\t\t加S锁，每次读完立即释放。 <strong>（strict-2PL）</strong></p>\n<p>​\t\t若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p>\n<ul>\n<li><strong>REPEATABLE_READ 可重复读</strong></li>\n</ul>\n<p>​\t\t加S锁，在事务提交&#x2F;中止时由TransactionManager统一释放 <strong>（rigorous-2PL）</strong></p>\n<p>​\t\t重复读可以解决不可重复读问题。不可重复读对应的是修改，<strong>即UPDATE操作</strong>。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</p>\n<ul>\n<li><strong>SERIALIZABLE 串行化</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">读未提交</td>\n<td align=\"center\">可能</td>\n<td align=\"center\">可能</td>\n<td align=\"center\">可能</td>\n</tr>\n<tr>\n<td align=\"center\">读提交</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">可能</td>\n<td align=\"center\">可能</td>\n</tr>\n<tr>\n<td align=\"center\">可重复读</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">可能</td>\n</tr>\n<tr>\n<td align=\"center\">串行化</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">不可能</td>\n<td align=\"center\">不可能</td>\n</tr>\n</tbody></table>\n<p><strong>问题：</strong></p>\n<ul>\n<li>脏读</li>\n</ul>\n<p>​\t\t指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作可能是不正确的。</p>\n<ul>\n<li>不可重复读</li>\n</ul>\n<p>​\t\t指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</p>\n<ul>\n<li>幻读</li>\n</ul>\n<p>​\t\t一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</p>\n<p>不同数据库处理隔离等级内容不相同</p>\n<h1 id=\"Task1\"><a href=\"#Task1\" class=\"headerlink\" title=\"Task1\"></a>Task1</h1><h2 id=\"LockTable\"><a href=\"#LockTable\" class=\"headerlink\" title=\"LockTable()\"></a>LockTable()</h2><p>整个<code>LockTable()</code>流程图如下所示：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/locktable.png\"></p>\n<p>仔细阅读<code>lockmanager.h</code>中的提示**[LOCK_NOTE]<strong>,可以确定三种隔离等级需要满足的条件，如果不满足则要置</strong>TransactionState<strong>为</strong>abort**状态</p>\n<h3 id=\"查找加锁页面\"><a href=\"#查找加锁页面\" class=\"headerlink\" title=\"查找加锁页面\"></a>查找加锁页面</h3><p>接下来就要对锁表进行操作了，在操作锁表之前要先将整个哈希表上锁，在拿到该txn需要操作的table后再释放锁，过程像P2的螃蟹锁一样，先锁table，再释放哈希表锁</p>\n<p>确定了需要操作的<strong>table</strong>后，下一步就是拿到该<strong>table</strong>的<strong>request_queue</strong>，<strong>request_queue</strong>里存的是该<strong>table</strong>所被请求的锁队列，总的数据结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">\tLockManager --|&gt; hash_table</span><br><span class=\"line\">\thash_table --|&gt; LockRequestQueue</span><br><span class=\"line\">\tLockRequestQueue --|&gt; LockRequest</span><br><span class=\"line\">\tclass LockManager &#123;</span><br><span class=\"line\">\t\t- 哈希表[表/行]</span><br><span class=\"line\">\t\t- 互斥锁[表/行]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclass hash_table &#123;</span><br><span class=\"line\">\t\t- LockRequestQueue</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclass LockRequestQueue &#123;</span><br><span class=\"line\">\t\t+ request_queue [LockRequest]</span><br><span class=\"line\">\t\t+ cv</span><br><span class=\"line\">\t\t+ upgrading</span><br><span class=\"line\">\t\t+ latch</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclass LockRequest &#123;</span><br><span class=\"line\">\t\t+ tid</span><br><span class=\"line\">\t\t+ oid</span><br><span class=\"line\">\t\t+ rid</span><br><span class=\"line\">\t\t+ lock_mode\t\t</span><br><span class=\"line\">\t\t+ granted</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>request_queue</strong>为一个队列，存放着加在该表（行）的锁请求，其中<strong>tid</strong>为事务id，<strong>oid</strong>为表id，<strong>rid</strong>为行id（在表锁中不需要）,<strong>lock_mode</strong>为要加锁的模式，<strong>granted</strong>为布尔变量，标志着该锁是否被授予</p>\n<p>如果需要加锁的页面没有<strong>request</strong>则新建<strong>request</strong>请求，至此，查找加锁页面结束</p>\n<h3 id=\"判断新旧事务\"><a href=\"#判断新旧事务\" class=\"headerlink\" title=\"判断新旧事务\"></a>判断新旧事务</h3><p>拿到该<strong>table</strong>的<strong>request_queue</strong>后，遍历整个队列</p>\n<ul>\n<li><p>如果<strong>request</strong>中没有改事务存在（该事务为新事务），则直接将该请求放到队尾，通过条件变量模型等待锁授权</p>\n</li>\n<li><p>如果<strong>request</strong>中已经有该事务存在，则进行<strong>锁升级</strong>的判断：</p>\n</li>\n</ul>\n<p>如果原锁模式与该锁模式相同，则不需要加锁，因为已经有这把锁了，<strong>直接return true</strong></p>\n<p>如果原锁模式与该锁模式不同，则需要先判断是否已经有锁在升级，<strong>LockRequestQueue</strong>中<strong>upgrading</strong>标记着请求队列中正在升级的事务id，若无锁升级，则<strong>upgrading</strong>的值为<strong>INVALID</strong>，存在其他正在升级的锁时，该事务置为<strong>ABORT</strong>；无其他正在升级的锁时，判断当前锁模式是否满足升级条件，锁升级条件在**[LOCK_NOTE]**中可以看到</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*        IS -&gt; [S, X, IX, SIX]</span><br><span class=\"line\">*        S -&gt; [X, SIX]</span><br><span class=\"line\">*        IX -&gt; [X, SIX]</span><br><span class=\"line\">*        SIX -&gt; [X]</span><br></pre></td></tr></table></figure>\n\n<p>若满足升级条件，则对该锁进行升级：</p>\n<p>升级需要先将原锁请求从队列中删除，再创建一个新加锁请求，让新加锁请求成为第一个未授权锁（升级锁拥有高权限），方法是遍历整个<strong>request_queue</strong>，找到第一个<strong>granted 为 false</strong>的位置，将新请求插入该位置即可，最后要更新<strong>upgrading</strong>，标记为正在升级状态,防止多个锁同时进行升级</p>\n<p>升级完成后，通过条件变量模型等待锁授权</p>\n<h3 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"*条件变量\"></a>*条件变量</h3><p>条件变量并不是某一个特定语言中的概念，而是操作系统中线程同步的一种机制。条件变量经典的使用形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(latch)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!resource) &#123;</span><br><span class=\"line\">    cv.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>条件变量与互斥锁配合使用。首先需要持有锁，并查看是否能够获取资源。这个锁与资源绑定，是用来保护资源的锁。若暂时无法获取资源，则调用条件变量的 wait 函数。调用 wait 函数后，latch 将自动<strong>释放</strong>，并且当前线程被挂起，以节省资源。这就是阻塞的过程。此外，允许有多个线程在 wait 同一个 latch。</p>\n<p>当其他线程的活动使得资源状态发生改变时，需要调用条件遍历的 <code>notify_all()</code> 函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.<span class=\"built_in\">notify_all</span>();</span><br></pre></td></tr></table></figure>\n\n<p><code>notify_all()</code> 可以看作一次广播，会唤醒所有正在此条件变量上阻塞的线程。在线程被唤醒后，其仍处于 wait 函数中。在 wait 函数中尝试获取 latch。在成功获取 latch 后，退出 wait 函数，进入循环的判断条件，检查是否能获取资源。若仍不能获取资源，就继续进入 wait 阻塞，释放锁，挂起线程。若能获取资源，则退出循环。这样就实现了阻塞等待资源的模型。条件变量中的条件指的就是满足某个条件，在这里即能够获取资源。</p>\n<p>理解条件变量的作用后，就可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(queue-&gt;latch_)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!<span class=\"built_in\">GrantLock</span>(...)) &#123;</span><br><span class=\"line\">    queue-&gt;cv_.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>GrantLock()</code>函数中，会判断出事务是否可以成功获取锁，授予锁的条件为：</p>\n<ol>\n<li>前面事务都兼容</li>\n<li>遵循FIFO，只有当前事务未第一个未授予的锁</li>\n</ol>\n<h2 id=\"UnlockTable\"><a href=\"#UnlockTable\" class=\"headerlink\" title=\"UnlockTable()\"></a>UnlockTable()</h2><p>怎么加的锁就怎么去解锁，流程如下：</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/Unlocktable.png\"></p>\n<h2 id=\"LockRow\"><a href=\"#LockRow\" class=\"headerlink\" title=\"LockRow()\"></a>LockRow()</h2><p>与<code>LockTable()</code>基本相同</p>\n<ul>\n<li>不支持意向锁（只允许S&#x2F;X锁）</li>\n<li>加锁时需要判断表的锁状态</li>\n<li>其他流程类似</li>\n</ul>\n<h2 id=\"UnLockRow\"><a href=\"#UnLockRow\" class=\"headerlink\" title=\"UnLockRow()\"></a>UnLockRow()</h2><p>与<code>UnLockTable()</code>相同</p>\n<h1 id=\"Task2\"><a href=\"#Task2\" class=\"headerlink\" title=\"Task2\"></a>Task2</h1><p>后台线程，中止阻塞的事务</p>\n<p>要求我们动态构建有向图，不需要长久维护一个图，可以从题目中给到的API入手</p>\n<p><code>AddEdge()</code>、<code>RemoveEdge()</code>、<code>GetEdgeList()</code>都是比较简单的增边删边操作，用来构建有向图，<strong>点代表事务</strong>ID，<strong>边代表依赖关系</strong>，指向被依赖的事务</p>\n<p>重要逻辑在<code>HasCycle()</code>、<code>RunCycleDetection()</code>中</p>\n<p><img src=\"https://tttuuuchuang.oss-cn-wulanchabu.aliyuncs.com/uploads/2023/09/28/deadlock.png\"></p>\n<h2 id=\"建图\"><a href=\"#建图\" class=\"headerlink\" title=\"建图\"></a>建图</h2><p><code>T1-&gt;T2</code>代表T1正在等待T2释放资源，哈希表<strong>waits_for_<strong>代表着该事务所等待释放资源的事务合集，根据Lab要求，我们遍历所有页和行的请求队列，</strong>已经被授予的锁作为箭头所指向的点</strong>，waiting中的事务将作为出发点建边。</p>\n<h2 id=\"判环\"><a href=\"#判环\" class=\"headerlink\" title=\"判环\"></a>判环</h2><p>构建完图之后，我们选择DFS进行环检测，要求保证搜索的确定性（不理解），应该就是遍历的顺序要从tid小的事务开始搜索，选择其邻居的过程也要优先最小的tid，若存在环，则挑选合适（youngest，即TID最大）的事务进行中止</p>\n<p>中止之后，需要在请求队列中移除事务，释放该事务所持有的所有锁，并通知正在阻塞的相关事务。不要忘记修改**waits_for_**，因为有可能存在多个环，需要在死锁检测线程结束时打破所有环。</p>\n<p>难度不大，主要内容在DFS中</p>\n<h1 id=\"Task3\"><a href=\"#Task3\" class=\"headerlink\" title=\"Task3\"></a>Task3</h1><p>将P3实现的执行算子中<code>SeqScan</code>、<code>Insert</code>、<code>Delete</code>三个算子实现可并发操作</p>\n<p>其中<code>SeqScan</code>代表读，<code>Insert</code>、<code>Delete</code>则代表写</p>\n<h2 id=\"读\"><a href=\"#读\" class=\"headerlink\" title=\"读\"></a>读</h2><p><strong>SeqScan</strong>在表中加IS锁，在行中加S锁，表锁可以在<code>Init()</code>函数中实现，行锁的加锁和释放则在对应读取数据时进行即可</p>\n<h2 id=\"写\"><a href=\"#写\" class=\"headerlink\" title=\"写\"></a>写</h2><p>与<strong>SeqScan</strong>类似，IX锁在<code>Init()</code>函数中实现，行锁在<code>Next()</code>中实现，要注意的是<strong>Insert</strong>和<strong>Delete</strong>的加锁顺序不同，<strong>Insert</strong>是插入完成再加锁，<strong>Delete</strong>则是先加锁，再进行删除操作，两个写算子都不需要释放锁，锁会在COMMIT的时候进行释放</p>\n<h1 id=\"Leaderboard-Task\"><a href=\"#Leaderboard-Task\" class=\"headerlink\" title=\"Leaderboard Task\"></a>Leaderboard Task</h1><p>看都没看，最近太忙，有空再来挑战一下！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cllhr6ji60001eqjgbvvkciyr","category_id":"cllhr6jid0004eqjg9xbi1e7t","_id":"cllhr6jig0008eqjg0b4tb3wg"},{"post_id":"cllhr6ji90003eqjg2d5ofxqr","category_id":"cllhr6jid0004eqjg9xbi1e7t","_id":"cllhr6jih000aeqjgf6ol3mpz"},{"post_id":"cllhr6jil000leqjg8rv94kfd","category_id":"cllhr6jid0004eqjg9xbi1e7t","_id":"cllhr6jin000oeqjgggq5alow"},{"post_id":"cllhr6jik000keqjg2urrc1tx","category_id":"cllhr6jim000meqjg2utocunz","_id":"cllhr6jin000qeqjg4asf3oft"},{"post_id":"clmuf8mjg0000cjjgbnzxhrte","category_id":"clmuf8mjm0002cjjgfkx8a6yb","_id":"clmuf8mjq0008cjjggls537v8"},{"post_id":"clmuf8mjk0001cjjghdog9ne0","category_id":"clmuf8mjm0002cjjgfkx8a6yb","_id":"clmuf8mjr000bcjjggxqj1nqf"},{"post_id":"clmuf8mjn0004cjjgd6vdgkwq","category_id":"clmuf8mjm0002cjjgfkx8a6yb","_id":"clmuf8mjs000ecjjg1d2naj1b"},{"post_id":"cloh9mybb0001dlji7n4ihp9j","category_id":"clmuf8mjm0002cjjgfkx8a6yb","_id":"cloh9mybd0003dljifzcu7nbt"}],"PostTag":[{"post_id":"cllhr6ji60001eqjgbvvkciyr","tag_id":"cllhr6jie0005eqjgdgw5be0s","_id":"cllhr6jii000deqjg7pdjbw0n"},{"post_id":"cllhr6ji60001eqjgbvvkciyr","tag_id":"cllhr6jif0007eqjg7e8m2sku","_id":"cllhr6jii000eeqjg298f7b3a"},{"post_id":"cllhr6ji60001eqjgbvvkciyr","tag_id":"cllhr6jih0009eqjgadwiexxs","_id":"cllhr6jij000geqjg2v6w8a46"},{"post_id":"cllhr6ji60001eqjgbvvkciyr","tag_id":"cllhr6jii000beqjg2ywqelzp","_id":"cllhr6jij000heqjgg5dhgydh"},{"post_id":"cllhr6ji90003eqjg2d5ofxqr","tag_id":"cllhr6jii000ceqjg9r2m8t4p","_id":"cllhr6jij000ieqjg2t6s2bxy"},{"post_id":"cllhr6ji90003eqjg2d5ofxqr","tag_id":"cllhr6jii000feqjgbnel2jpo","_id":"cllhr6jij000jeqjg7a6d20l3"},{"post_id":"cllhr6jik000keqjg2urrc1tx","tag_id":"cllhr6jim000neqjgga0q65y7","_id":"cllhr6jin000peqjg7lr29wig"},{"post_id":"clmuf8mjg0000cjjgbnzxhrte","tag_id":"clmuf8mjn0003cjjg0ypg7eo4","_id":"clmuf8mjr000acjjgahsv1rvh"},{"post_id":"clmuf8mjg0000cjjgbnzxhrte","tag_id":"clmuf8mjo0006cjjg13anfipw","_id":"clmuf8mjr000ccjjgeyob72ux"},{"post_id":"clmuf8mjk0001cjjghdog9ne0","tag_id":"clmuf8mjn0003cjjg0ypg7eo4","_id":"clmuf8mjs000gcjjg3qrfb3jj"},{"post_id":"clmuf8mjk0001cjjghdog9ne0","tag_id":"clmuf8mjo0006cjjg13anfipw","_id":"clmuf8mjs000hcjjghkmf1rax"},{"post_id":"clmuf8mjn0004cjjgd6vdgkwq","tag_id":"clmuf8mjn0003cjjg0ypg7eo4","_id":"clmuf8mjs000kcjjg5cpq2fiv"},{"post_id":"clmuf8mjn0004cjjgd6vdgkwq","tag_id":"clmuf8mjo0006cjjg13anfipw","_id":"clmuf8mjs000lcjjgbzdy2y19"},{"post_id":"clmuf8mjn0004cjjgd6vdgkwq","tag_id":"clmuf8mjs000jcjjgc31o6i9m","_id":"clmuf8mjt000mcjjggiv47k72"},{"post_id":"cloh9mybb0001dlji7n4ihp9j","tag_id":"clmuf8mjn0003cjjg0ypg7eo4","_id":"cloh9mybd0004dlji5zor2ql5"},{"post_id":"cloh9mybb0001dlji7n4ihp9j","tag_id":"clmuf8mjo0006cjjg13anfipw","_id":"cloh9mybd0005dljihu3ya2zb"},{"post_id":"cloh9mybb0001dlji7n4ihp9j","tag_id":"cloh9mybc0002dlji03jreduq","_id":"cloh9mybe0006dlji1rdvdvbo"}],"Tag":[{"name":"Excalidraw","_id":"cllhr6jie0005eqjgdgw5be0s"},{"name":"Nodejs","_id":"cllhr6jif0007eqjg7e8m2sku"},{"name":"Yarn","_id":"cllhr6jih0009eqjgadwiexxs"},{"name":"Git","_id":"cllhr6jii000beqjg2ywqelzp"},{"name":"Rainmeter","_id":"cllhr6jii000ceqjg9r2m8t4p"},{"name":"ToDoList","_id":"cllhr6jii000feqjgbnel2jpo"},{"name":"data structure","_id":"cllhr6jim000neqjgga0q65y7"},{"name":"CMU15445","_id":"clmuf8mjn0003cjjg0ypg7eo4"},{"name":"Database","_id":"clmuf8mjo0006cjjg13anfipw"},{"name":"Query Execution","_id":"clmuf8mjs000jcjjgc31o6i9m"},{"name":"Concurrency Control","_id":"cloh9mybc0002dlji03jreduq"}]}}